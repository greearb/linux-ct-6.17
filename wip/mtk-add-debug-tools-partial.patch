Remaining:

debugging counters
WED
eeprom changes
txpower changes (mostly already done in earlier patches pulled from mtk)
stas-count feature flag (skip this I think)
csi (vendor section)
rro (related to WED)
set_wireless_amsdu (VENDOR section)
debug.[ch]
channel_switch_beacon re-add when it can compile
mt7996_sta_statistics changes
mt7996_sta_link_statistics
background_radar_handle_7975
mcu_rx_all_sta_info_event (later)
mcu_uni_rx_unsolicited_event changes (done enough for now)
other mtk mcu stuff
mt76_token_consume_red_drop stats
mac_update_stats
mcu_get_rssi
agginfo_show, other in mtk_debugfs.c



From 52fd42fc8c99f7a2a670b912e533721b69ccab15 Mon Sep 17 00:00:00 2001
From: Shayne Chen <shayne.chen@mediatek.com>
Date: Tue, 18 Mar 2025 23:16:05 +0800
Subject: mtk: mt76: add debug tools

This pulls in a wide range of stuff.  Original patch from mtk
tree would not come close to compiling.  I have hacked it to
compile by pulling in bits and pieces from the complete tree.
Feature patches are jumbled up though, and should pull their
bits from this patch so less dummy code is needed. --Ben

diff --git a/drivers/net/wireless/mediatek/mt76/Makefile b/drivers/net/wireless/mediatek/mt76/Makefile
index a4663ccda0cf..e681298d0920 100644
--- a/drivers/net/wireless/mediatek/mt76/Makefile
+++ b/drivers/net/wireless/mediatek/mt76/Makefile
@@ -1,5 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0-only
 EXTRA_CFLAGS += -Werror -DCONFIG_MT76_LEDS
+ADDITIONAL_CFLAGS += $(ADDITIONAL_CFLAGS)
 obj-m := mt76.o
 obj-$(CONFIG_MT76_USB) += mt76-usb.o
 obj-$(CONFIG_MT76_SDIO) += mt76-sdio.o
@@ -11,7 +12,7 @@ obj-$(CONFIG_MT792x_USB) += mt792x-usb.o

 mt76-y := \
	mmio.o util.o trace.o dma.o mac80211.o debugfs.o eeprom.o \
-	tx.o agg-rx.o mcu.o wed.o scan.o channel.o
+	tx.o agg-rx.o mcu.o wed.o scan.o channel.o debug.o

 mt76-$(CONFIG_PCI) += pci.o
 mt76-$(CONFIG_NL80211_TESTMODE) += testmode.o
diff --git a/drivers/net/wireless/mediatek/mt76/agg-rx.c b/drivers/net/wireless/mediatek/mt76/agg-rx.c
index 07c386c7b4d0..9875baa85f2e 100644
--- a/drivers/net/wireless/mediatek/mt76/agg-rx.c
+++ b/drivers/net/wireless/mediatek/mt76/agg-rx.c
@@ -3,6 +3,7 @@
  * Copyright (C) 2018 Felix Fietkau <nbd@nbd.name>
  */
 #include "mt76.h"
+#include "trace.h"

 static unsigned long mt76_aggr_tid_to_timeo(u8 tidno)
 {
@@ -151,6 +152,7 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
	struct mt76_wcid *wcid = status->wcid;
	struct ieee80211_sta *sta;
	struct mt76_rx_tid *tid;
+	struct mt76_phy *phy;
	bool sn_less;
	u16 seqno, head, size, idx;
	u8 tidno = status->qos_ctl & IEEE80211_QOS_CTL_TID_MASK;
@@ -177,6 +179,8 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
	if (!tid)
		return;

+	phy = mt76_dev_phy(tid->dev, wcid->phy_idx);
+
	status->flag |= RX_FLAG_DUP_VALIDATED;
	spin_lock_bh(&tid->lock);

@@ -187,6 +191,7 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
	seqno = status->seqno;
	size = tid->size;
	sn_less = ieee80211_sn_less(seqno, head);
+	trace_mt76_rx_aggr_reorder(tid->dev, wcid, head, seqno, sn_less);

	if (!tid->started) {
		if (sn_less)
@@ -198,6 +203,9 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
	if (sn_less) {
		__skb_unlink(skb, frames);
		dev_kfree_skb(skb);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_drop[MT_RX_DROP_AGG_SN_LESS]++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
		goto out;
	}

@@ -224,6 +232,9 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
	/* Discard if the current slot is already in use */
	if (tid->reorder_buf[idx]) {
		dev_kfree_skb(skb);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_drop[MT_RX_DROP_AGG_DUP]++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
		goto out;
	}

diff --git a/drivers/net/wireless/mediatek/mt76/debug.c b/drivers/net/wireless/mediatek/mt76/debug.c
new file mode 100644
index 000000000000..fb28c3295f7e
--- /dev/null
+++ b/drivers/net/wireless/mediatek/mt76/debug.c
@@ -0,0 +1,67 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (C) 2024 MediaTek Inc.
+ */
+
+#include <linux/vmalloc.h>
+#include "mt76.h"
+
+void mt76_info(struct mt76_dev *dev, const char *fmt, ...)
+{
+	struct va_format vaf = {
+		.fmt = fmt,
+	};
+	va_list args;
+
+	va_start(args, fmt);
+	vaf.va = &args;
+	dev_info(dev->dev, "%pV", &vaf);
+
+	va_end(args);
+}
+EXPORT_SYMBOL_GPL(mt76_info);
+
+void mt76_err(struct mt76_dev *dev, const char *fmt, ...)
+{
+	struct va_format vaf = {
+		.fmt = fmt,
+	};
+	va_list args;
+
+	va_start(args, fmt);
+	vaf.va = &args;
+	dev_err(dev->dev, "%pV", &vaf);
+
+	va_end(args);
+}
+EXPORT_SYMBOL_GPL(mt76_err);
+
+void mt76_warn(struct mt76_dev *dev, const char *fmt, ...)
+{
+	struct va_format vaf = {
+		.fmt = fmt,
+	};
+	va_list args;
+
+	va_start(args, fmt);
+	vaf.va = &args;
+	dev_warn_ratelimited(dev->dev, "%pV", &vaf);
+
+	va_end(args);
+}
+EXPORT_SYMBOL_GPL(mt76_warn);
+
+void __mt76_dbg(struct mt76_dev *dev, const char *fmt, ...)
+{
+	struct va_format vaf = {
+		.fmt = fmt,
+	};
+	va_list args;
+
+	va_start(args, fmt);
+	vaf.va = &args;
+	dev_printk(KERN_DEBUG, dev->dev, "%pV", &vaf);
+
+	va_end(args);
+}
+EXPORT_SYMBOL_GPL(__mt76_dbg);
diff --git a/drivers/net/wireless/mediatek/mt76/debug.h b/drivers/net/wireless/mediatek/mt76/debug.h
new file mode 100644
index 000000000000..9181d75b80f7
--- /dev/null
+++ b/drivers/net/wireless/mediatek/mt76/debug.h
@@ -0,0 +1,42 @@
+/* SPDX-License-Identifier: ISC */
+/*
+ * Copyright (C) 2024 MediaTek Inc.
+ */
+#ifndef __MT76_DEBUG_H_
+#define __MT76_DEBUG_H_
+
+struct mt76_dev;
+
+enum mt76_debug_mask {
+	MT76_DBG_DEV = BIT(0),
+	MT76_DBG_BSS = BIT(1),
+	MT76_DBG_STA = BIT(2),
+	MT76_DBG_CHAN = BIT(3),
+	MT76_DBG_MLD = BIT(4),
+	MT76_DBG_TXRX = BIT(5),
+	MT76_DBG_SCAN = BIT(6),
+	MT76_DBG_TEST = BIT(7),
+
+	MT76_DBG_ALL = 0xffffffff,
+};
+
+__printf(2, 3) void mt76_info(struct mt76_dev *dev, const char *fmt, ...);
+__printf(2, 3) void mt76_err(struct mt76_dev *dev, const char *fmt, ...);
+__printf(2, 3) void mt76_warn(struct mt76_dev *dev, const char *fmt, ...);
+
+__printf(2, 3) void __mt76_dbg(struct mt76_dev *dev,
+			       const char *fmt, ...);
+void mt76_dbg_dump(struct mt76_dev *dev,
+		   enum mt76_debug_mask mask,
+		   const char *msg, const char *prefix,
+		   const void *buf, size_t len);
+
+#define mt76_dbg(dev, dbg_mask, fmt, ...)			\
+do {								\
+	typeof(dbg_mask) mask = (dbg_mask);			\
+	typeof(dev) _dev = (dev);				\
+	if ((_dev->debug_mask) & mask)				\
+		__mt76_dbg(_dev, fmt, ##__VA_ARGS__);	\
+} while (0)
+
+#endif /* __MT76_DEBUG_H_ */
diff --git a/drivers/net/wireless/mediatek/mt76/dma.c b/drivers/net/wireless/mediatek/mt76/dma.c
index 4916662ccb49..86de0d5cbc57 100644
--- a/drivers/net/wireless/mediatek/mt76/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/dma.c
@@ -250,12 +250,15 @@ mt76_dma_add_rx_buf(struct mt76_dev *dev, struct mt76_queue *q,

	if (mt76_queue_is_wed_rx(q)) {
		txwi = mt76_get_rxwi(dev);
-		if (!txwi)
+		if (!txwi) {
+			q->rx_drop[MT_RX_DROP_DMAD_GET_RXWI_FAIL]++;
			return -ENOMEM;
+		}

		rx_token = mt76_rx_token_consume(dev, data, txwi, buf->addr);
		if (rx_token < 0) {
			mt76_put_rxwi(dev, txwi);
+			q->rx_drop[MT_RX_DROP_DMAD_GET_TOKEN_FAIL]++;
			return -ENOMEM;
		}

@@ -426,6 +429,7 @@ mt76_dma_get_buf(struct mt76_dev *dev, struct mt76_queue *q, int idx,
	struct mt76_desc *desc = &q->desc[idx];
	u32 ctrl, desc_info, buf1;
	void *buf = e->buf;
+	int reason;

	if (mt76_queue_is_wed_rro_ind(q))
		goto done;
@@ -441,6 +445,8 @@ mt76_dma_get_buf(struct mt76_dev *dev, struct mt76_queue *q, int idx,
		*info = desc_info;

	buf1 = le32_to_cpu(desc->buf1);
-	mt76_dma_should_drop_buf(drop, ctrl, buf1, desc_info);
+	reason = mt76_dma_should_drop_buf(drop, ctrl, buf1, desc_info);
+	if (drop && *drop && reason >= 0)
+		q->rx_drop[reason]++;

	if (mt76_queue_is_wed_rx(q)) {
		u32 id, find = 0;
		u32 token = FIELD_GET(MT_DMA_CTL_TOKEN, buf1);
+
+			spin_unlock_bh(&dev->rx_token_lock);
+			if (!find) {
+				q->rx_drop[MT_RX_DROP_DMAD_ADDR_NOT_FOUND]++;
+				return NULL;
+			}
+		}

-		if (!t)
+		t = mt76_rx_token_release(dev, token);
+		if (!t) {
+			q->rx_drop[MT_RX_DROP_DMAD_TOKEN_NOT_FOUND]++;
			return NULL;
+		}

		dma_sync_single_for_cpu(dev->dma_dev, t->dma_addr,
				SKB_WITH_OVERHEAD(q->buf_size),
@@ -458,9 +491,11 @@ mt76_dma_get_buf(struct mt76_dev *dev, struct mt76_queue *q, int idx,
		t->dma_addr = 0;
		t->ptr = NULL;

-		mt76_put_rxwi(dev, t);
-		if (drop)
+		if (drop) {
			*drop |= !!(buf1 & MT_DMA_CTL_WO_DROP);
+			if (buf1 & MT_DMA_CTL_WO_DROP)
+				q->rx_drop[MT_RX_DROP_DMAD_WO_FRAG]++;
+		}
	} else {
		dma_sync_single_for_cpu(dev->dma_dev, e->dma_addr[0],
				SKB_WITH_OVERHEAD(q->buf_size),
@@ -550,12 +589,16 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
	dma_addr_t addr;
	u8 *txwi;

-	if (test_bit(MT76_RESET, &phy->state))
+	if (test_bit(MT76_RESET, &phy->state)) {
+		phy->tx_dbg_stats.tx_drop[MT_TX_DROP_RESET_STATE]++;
		goto free_skb;
+	}

	t = mt76_get_txwi(dev);
-	if (!t)
+	if (!t) {
+		dev->tx_dbg_stats.tx_drop[MT_TX_DROP_GET_TXWI_FAIL]++;
		goto free_skb;
+	}

	txwi = mt76_get_txwi_ptr(dev, t);

@@ -565,8 +608,10 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,

	len = skb_headlen(skb);
	addr = dma_map_single(dev->dma_dev, skb->data, len, DMA_TO_DEVICE);
-	if (unlikely(dma_mapping_error(dev->dma_dev, addr)))
+	if (unlikely(dma_mapping_error(dev->dma_dev, addr))) {
+		dev->tx_dbg_stats.tx_drop[MT_TX_DROP_DMA_FAIL]++;
		goto free;
+	}

	tx_info.buf[n].addr = t->dma_addr;
	tx_info.buf[n++].len = dev->drv->txwi_size;
@@ -574,13 +619,17 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
	tx_info.buf[n++].len = len;

	skb_walk_frags(skb, iter) {
-		if (n == ARRAY_SIZE(tx_info.buf))
+		if (n == ARRAY_SIZE(tx_info.buf)) {
+			dev->tx_dbg_stats.tx_drop[MT_TX_DROP_AGG_EXCEEDED]++;
			goto unmap;
+		}

		addr = dma_map_single(dev->dma_dev, iter->data, iter->len,
				      DMA_TO_DEVICE);
-		if (unlikely(dma_mapping_error(dev->dma_dev, addr)))
+		if (unlikely(dma_mapping_error(dev->dma_dev, addr))) {
+			dev->tx_dbg_stats.tx_drop[MT_TX_DROP_DMA_FAIL]++;
			goto unmap;
+		}

		tx_info.buf[n].addr = addr;
		tx_info.buf[n++].len = iter->len;
@@ -589,6 +638,7 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,

	if (q->queued + (tx_info.nbuf + 1) / 2 >= q->ndesc - 1) {
		ret = -ENOMEM;
+		phy->tx_dbg_stats.tx_drop[MT_TX_DROP_RING_FULL]++;
		goto unmap;
	}

@@ -600,6 +650,7 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
	if (ret < 0)
		goto unmap;

+	phy->tx_dbg_stats.tx_to_hw++;
	return mt76_dma_add_buf(dev, q, tx_info.buf, tx_info.nbuf,
				tx_info.info, tx_info.skb, t);

@@ -631,9 +682,8 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
	return ret;
 }

-static int
-mt76_dma_rx_fill_buf(struct mt76_dev *dev, struct mt76_queue *q,
-		     bool allow_direct)
+int mt76_dma_rx_fill_buf(struct mt76_dev *dev, struct mt76_queue *q,
+			 bool allow_direct)
 {
	int len = SKB_WITH_OVERHEAD(q->buf_size);
	int frames = 0;
@@ -826,16 +876,19 @@ mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,
		skb_add_rx_frag(skb, nr_frags, page, offset, len, q->buf_size);
	} else {
		mt76_put_page_pool_buf(data, allow_direct);
+		q->rx_drop[MT_RX_DROP_FRAG]++;
	}

	if (more)
		return;

	q->rx_head = NULL;
-	if (nr_frags < ARRAY_SIZE(shinfo->frags))
+	if (nr_frags < ARRAY_SIZE(shinfo->frags)) {
		dev->drv->rx_skb(dev, q - dev->q_rx, skb, &info);
-	else
+	} else {
+		q->rx_drop[MT_RX_DROP_FRAG]++;
		dev_kfree_skb(skb);
+	}
 }

 static int
@@ -880,6 +933,7 @@ mt76_dma_rx_process(struct mt76_dev *dev, struct mt76_queue *q, int budget)
			data_len = SKB_WITH_OVERHEAD(q->buf_size);

		if (data_len < len + q->buf_offset) {
+			q->rx_drop[MT_RX_DROP_FRAG]++;
			dev_kfree_skb(q->rx_head);
			q->rx_head = NULL;
			goto free_frag;
@@ -896,8 +950,10 @@ mt76_dma_rx_process(struct mt76_dev *dev, struct mt76_queue *q, int budget)
			goto free_frag;

		skb = napi_build_skb(data, q->buf_size);
-		if (!skb)
+		if (!skb) {
+			q->rx_drop[MT_RX_DROP_BUILD_SKB_FAIL]++;
			goto free_frag;
+		}

		skb_reserve(skb, q->buf_offset);
		skb_mark_for_recycle(skb);
diff --git a/drivers/net/wireless/mediatek/mt76/dma.h b/drivers/net/wireless/mediatek/mt76/dma.h
index e3ddc7a83757..07d67cd0d13e 100644
--- a/drivers/net/wireless/mediatek/mt76/dma.h
+++ b/drivers/net/wireless/mediatek/mt76/dma.h
@@ -81,10 +81,12 @@ void mt76_dma_attach(struct mt76_dev *dev);
 void mt76_dma_cleanup(struct mt76_dev *dev);
 int mt76_dma_rx_fill(struct mt76_dev *dev, struct mt76_queue *q,
		     bool allow_direct);
+int mt76_dma_rx_fill_buf(struct mt76_dev *dev, struct mt76_queue *q,
+			 bool allow_direct);
 void __mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q,
			    bool reset_idx);
 void mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q, bool reset);

 static inline void
 mt76_dma_reset_tx_queue(struct mt76_dev *dev, struct mt76_queue *q)
 {
	dev->queue_ops->reset_q(dev, q, true);
	if (mtk_wed_device_active(&dev->mmio.wed))
		mt76_wed_dma_setup(dev, q, true);
 }

-static inline void
+static inline int
 mt76_dma_should_drop_buf(bool *drop, u32 ctrl, u32 buf1, u32 info)
 {
	if (!drop)
-		return;
+		return -1;

	*drop = !!(ctrl & (MT_DMA_CTL_TO_HOST_A | MT_DMA_CTL_DROP));
	if (!(ctrl & MT_DMA_CTL_VER_MASK))
-		return;
+		return MT_RX_DROP_DMAD_WO_DROP;

	switch (FIELD_GET(MT_DMA_WED_IND_REASON, buf1)) {
	case MT_DMA_WED_IND_REASON_REPEAT:
		*drop = true;
-		break;
+		return MT_RX_DROP_DMAD_RRO_REPEAT;
	case MT_DMA_WED_IND_REASON_OLDPKT:
		*drop = !(info & MT_DMA_INFO_DMA_FRAG);
-		break;
+		return MT_RX_DROP_DMAD_RRO_OLDPKT;
	default:
		*drop = !!(ctrl & MT_DMA_CTL_PN_CHK_FAIL);
-		break;
+		return MT_RX_DROP_DMAD_RRO_PN_CHK_FAIL;
	}
+
+	return -1;
 }

 static inline void *mt76_priv(struct net_device *dev)
diff --git a/drivers/net/wireless/mediatek/mt76/eeprom.c b/drivers/net/wireless/mediatek/mt76/eeprom.c
index 30b744a1ca46..9b4a682aea01 100644
--- a/drivers/net/wireless/mediatek/mt76/eeprom.c
+++ b/drivers/net/wireless/mediatek/mt76/eeprom.c
@@ -94,12 +94,10 @@ int mt76_get_of_data_from_mtd(struct mt76_dev *dev, void *eep, int offset, int l
	}

 #ifdef CONFIG_NL80211_TESTMODE
-	dev->test_mtd.name = devm_kstrdup(dev->dev, part, GFP_KERNEL);
-	if (!dev->test_mtd.name) {
-		ret = -ENOMEM;
-		goto out_put_node;
+	if (len == dev->eeprom.size) {
+		dev->test_mtd.name = devm_kstrdup(dev->dev, part, GFP_KERNEL);
+		dev->test_mtd.offset = offset;
	}
-	dev->test_mtd.offset = offset;
 #endif

 out_put_node:
@@ -163,6 +161,29 @@ static int mt76_get_of_eeprom(struct mt76_dev *dev, void *eep, int len)
	return mt76_get_of_data_from_nvmem(dev, eep, "eeprom", len);
 }

+bool mt76_check_bin_file_mode(struct mt76_dev *dev)
+{
+	struct device_node *np = dev->dev->of_node;
+	const char *bin_file_name = NULL;
+
+	if (!np)
+		return false;
+
+	of_property_read_string(np, "bin_file_name", &bin_file_name);
+
+	dev->bin_file_name = bin_file_name;
+	if (dev->bin_file_name) {
+		dev_info(dev->dev, "Using bin file %s\n", dev->bin_file_name);
+#ifdef CONFIG_NL80211_TESTMODE
+		dev->test_mtd.name = devm_kstrdup(dev->dev, bin_file_name, GFP_KERNEL);
+		dev->test_mtd.offset = -1;
+#endif
+	}
+
+	return dev->bin_file_name ? true : false;
+}
+EXPORT_SYMBOL_GPL(mt76_check_bin_file_mode);
+
 void
 mt76_eeprom_override(struct mt76_phy *phy)
 {
@@ -322,9 +343,10 @@ mt76_apply_array_limit(s8 *pwr, size_t pwr_len, const __be32 *data,
 static void
 mt76_apply_multi_array_limit(s8 *pwr, size_t pwr_len, s8 pwr_num,
			     const __be32 *data, size_t len, s8 target_power,
-			     s8 nss_delta, s8 *max_power)
+			     s8 nss_delta)
 {
	int i, cur;
+	s8 max_power = -128;

	if (!data)
		return;
@@ -336,7 +358,7 @@ mt76_apply_multi_array_limit(s8 *pwr, size_t pwr_len, s8 pwr_num,
			break;

		mt76_apply_array_limit(pwr + pwr_len * i, pwr_len, data + 1,
-				       target_power, nss_delta, max_power);
+				       target_power, nss_delta, &max_power);
		if (--cur > 0)
			continue;

@@ -352,6 +374,7 @@ mt76_apply_multi_array_limit(s8 *pwr, size_t pwr_len, s8 pwr_num,
 s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
			      struct ieee80211_channel *chan,
			      struct mt76_power_limits *dest,
+			      struct mt76_power_path_limits *dest_path,
			      s8 target_power)
 {
	struct mt76_dev *dev = phy->dev;
@@ -359,16 +382,20 @@ s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
	const __be32 *val;
	char name[16];
	u32 mcs_rates = dev->drv->mcs_rates;
-	u32 ru_rates = ARRAY_SIZE(dest->ru[0]);
	char band;
	size_t len;
-	s8 max_power = 0;
+	s8 max_power = -127;
+	s8 max_power_backoff = -127;
	s8 txs_delta;
+	int n_chains = hweight16(phy->chainmask);
+	s8 target_power_combine = target_power + mt76_tx_power_path_delta(n_chains);

	if (!mcs_rates)
-		mcs_rates = 10;
+		mcs_rates = 12;

	memset(dest, target_power, sizeof(*dest));
+	if (dest_path != NULL)
+		memset(dest_path, 0, sizeof(*dest_path));

	if (!IS_ENABLED(CONFIG_OF))
		return target_power;
@@ -414,12 +441,44 @@ s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
	val = mt76_get_of_array(np, "rates-mcs", &len, mcs_rates + 1);
	mt76_apply_multi_array_limit(dest->mcs[0], ARRAY_SIZE(dest->mcs[0]),
				     ARRAY_SIZE(dest->mcs), val, len,
-				     target_power, txs_delta, &max_power);
+				     target_power, txs_delta);

-	val = mt76_get_of_array(np, "rates-ru", &len, ru_rates + 1);
+	val = mt76_get_of_array(np, "rates-ru", &len, ARRAY_SIZE(dest->ru[0]) + 1);
	mt76_apply_multi_array_limit(dest->ru[0], ARRAY_SIZE(dest->ru[0]),
				     ARRAY_SIZE(dest->ru), val, len,
-				     target_power, txs_delta, &max_power);
+				     target_power, txs_delta);
+
+	val = mt76_get_of_array(np, "rates-eht", &len, ARRAY_SIZE(dest->eht[0]) + 1);
+	mt76_apply_multi_array_limit(dest->eht[0], ARRAY_SIZE(dest->eht[0]),
+				     ARRAY_SIZE(dest->eht), val, len,
+				     target_power, txs_delta);
+
+	if (dest_path == NULL)
+		return max_power;
+
+	max_power_backoff = max_power;
+
+	val = mt76_get_of_array(np, "paths-cck", &len, ARRAY_SIZE(dest_path->cck));
+	mt76_apply_array_limit(dest_path->cck, ARRAY_SIZE(dest_path->cck), val,
+			       target_power_combine, txs_delta, &max_power_backoff);
+
+	val = mt76_get_of_array(np, "paths-ofdm", &len, ARRAY_SIZE(dest_path->ofdm));
+	mt76_apply_array_limit(dest_path->ofdm, ARRAY_SIZE(dest_path->ofdm), val,
+			       target_power_combine, txs_delta, &max_power_backoff);
+
+	val = mt76_get_of_array(np, "paths-ofdm-bf", &len, ARRAY_SIZE(dest_path->ofdm_bf));
+	mt76_apply_array_limit(dest_path->ofdm_bf, ARRAY_SIZE(dest_path->ofdm_bf), val,
+			       target_power_combine, txs_delta, &max_power_backoff);
+
+	val = mt76_get_of_array(np, "paths-ru", &len, ARRAY_SIZE(dest_path->ru[0]) + 1);
+	mt76_apply_multi_array_limit(dest_path->ru[0], ARRAY_SIZE(dest_path->ru[0]),
+				     ARRAY_SIZE(dest_path->ru), val, len,
+				     target_power_combine, txs_delta);
+
+	val = mt76_get_of_array(np, "paths-ru-bf", &len, ARRAY_SIZE(dest_path->ru_bf[0]) + 1);
+	mt76_apply_multi_array_limit(dest_path->ru_bf[0], ARRAY_SIZE(dest_path->ru_bf[0]),
+				     ARRAY_SIZE(dest_path->ru_bf), val, len,
+				     target_power_combine, txs_delta);

	return max_power;
 }
diff --git a/drivers/net/wireless/mediatek/mt76/firmware/LICENSE b/drivers/net/wireless/mediatek/mt76/firmware/LICENSE
new file mode 100644
index 000000000000..064ae26e973c
--- /dev/null
+++ b/drivers/net/wireless/mediatek/mt76/firmware/LICENSE
@@ -0,0 +1,39 @@
+Copyright (c) 2014, Ralink, A MediaTek Company
+All rights reserved.
+
+Redistribution.  Redistribution and use in binary form, without
+modification, are permitted provided that the following conditions are
+met:
+
+* Redistributions must reproduce the above copyright notice and the
+  following disclaimer in the documentation and/or other materials
+  provided with the distribution.
+* Neither the name of Ralink Technology Corporation nor the names of its
+  suppliers may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+* No reverse engineering, decompilation, or disassembly of this software
+  is permitted.
+
+Limited patent license. Ralink Technology Corporation grants a world-wide,
+royalty-free, non-exclusive license under patents it now or hereafter
+owns or controls to make, have made, use, import, offer to sell and
+sell ("Utilize") this software, but solely to the extent that any
+such patent is necessary to Utilize the software alone, or in
+combination with an operating system licensed under an approved Open
+Source license as listed by the Open Source Initiative at
+http://opensource.org/licenses.  The patent license shall not apply to
+any other combinations which include this software.  No hardware per
+se is licensed hereunder.
+
+DISCLAIMER.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
+BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGE.
diff --git a/drivers/net/wireless/mediatek/mt76/mac80211.c b/drivers/net/wireless/mediatek/mt76/mac80211.c
index 0d7af48e9716..24fe024052a4 100644
--- a/drivers/net/wireless/mediatek/mt76/mac80211.c
+++ b/drivers/net/wireless/mediatek/mt76/mac80211.c
@@ -5,27 +5,7 @@
 #include <linux/sched.h>
 #include <linux/of.h>
 #include "mt76.h"
-
-#define CHAN2G(_idx, _freq) {			\
-	.band = NL80211_BAND_2GHZ,		\
-	.center_freq = (_freq),			\
-	.hw_value = (_idx),			\
-	.max_power = 30,			\
-}
-
-#define CHAN5G(_idx, _freq) {			\
-	.band = NL80211_BAND_5GHZ,		\
-	.center_freq = (_freq),			\
-	.hw_value = (_idx),			\
-	.max_power = 30,			\
-}
-
-#define CHAN6G(_idx, _freq) {			\
-	.band = NL80211_BAND_6GHZ,		\
-	.center_freq = (_freq),			\
-	.hw_value = (_idx),			\
-	.max_power = 30,			\
-}
+#include "trace.h"

 static const struct ieee80211_channel mt76_channels_2ghz[] = {
	CHAN2G(1, 2412),
@@ -55,6 +35,15 @@ static const struct ieee80211_channel mt76_channels_5ghz[] = {
	CHAN5G(60, 5300),
	CHAN5G(64, 5320),

+	CHAN5G(68, 5340),
+	CHAN5G(72, 5360),
+	CHAN5G(76, 5380),
+	CHAN5G(80, 5400),
+	CHAN5G(84, 5420),
+	CHAN5G(88, 5440),
+	CHAN5G(92, 5460),
+	CHAN5G(96, 5480),
+
	CHAN5G(100, 5500),
	CHAN5G(104, 5520),
	CHAN5G(108, 5540),
@@ -432,6 +421,8 @@ mt76_phy_init(struct mt76_phy *phy, struct ieee80211_hw *hw)
	INIT_LIST_HEAD(&phy->tx_list);
	spin_lock_init(&phy->tx_lock);
	INIT_DELAYED_WORK(&phy->roc_work, mt76_roc_complete_work);
+	spin_lock_init(&phy->tx_dbg_stats.lock);
+	spin_lock_init(&phy->rx_dbg_stats.lock);

	if ((void *)phy != hw->priv)
		return 0;
@@ -683,6 +674,7 @@ mt76_alloc_device(struct device *pdev, unsigned int size,
	spin_lock_init(&dev->cc_lock);
	spin_lock_init(&dev->status_lock);
	spin_lock_init(&dev->wed_lock);
+	spin_lock_init(&dev->tx_dbg_stats.lock);
	mutex_init(&dev->mutex);
	init_waitqueue_head(&dev->tx_wait);

@@ -856,6 +848,9 @@ static void mt76_rx_release_amsdu(struct mt76_phy *phy, enum mt76_rxq_id q)
		}

		if (ether_addr_equal(skb->data + offset, rfc1042_header)) {
+			spin_lock_bh(&phy->rx_dbg_stats.lock);
+			phy->rx_dbg_stats.rx_drop[MT_RX_DROP_RFC_PKT]++;
+			spin_unlock_bh(&phy->rx_dbg_stats.lock);
			dev_kfree_skb(skb);
			return;
		}
@@ -893,11 +888,15 @@ void mt76_rx(struct mt76_dev *dev, enum mt76_rxq_id q, struct sk_buff *skb)

	if (!test_bit(MT76_STATE_RUNNING, &phy->state)) {
		dev_kfree_skb(skb);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_drop[MT_RX_DROP_STATE_ERR]++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
		return;
	}

 #ifdef CONFIG_NL80211_TESTMODE
-	if (phy->test.state == MT76_TM_STATE_RX_FRAMES) {
+	if (!(phy->test.flag & MT_TM_FW_RX_COUNT) &&
+	    phy->test.state == MT76_TM_STATE_RX_FRAMES) {
		phy->test.rx_stats.packets[q]++;
		if (status->flag & RX_FLAG_FAILED_FCS_CRC)
			phy->test.rx_stats.fcs_error[q]++;
@@ -978,6 +977,7 @@ int __mt76_set_channel(struct mt76_phy *phy, struct cfg80211_chan_def *chandef,
	struct mt76_dev *dev = phy->dev;
	int timeout = HZ / 5;
	int ret;
+	unsigned long was_scanning = ieee80211_get_scanning(phy->hw);

	set_bit(MT76_RESET, &phy->state);

@@ -1185,6 +1186,7 @@ mt76_rx_convert(struct mt76_dev *dev, struct sk_buff *skb,
 {
	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
	struct ieee80211_hdr *hdr = mt76_skb_get_hdr(skb);
+	struct mt76_phy *phy;
	struct mt76_rx_status mstat;

	mstat = *((struct mt76_rx_status *)skb->cb);
@@ -1232,6 +1234,11 @@ mt76_rx_convert(struct mt76_dev *dev, struct sk_buff *skb,

	*sta = wcid_to_sta(mstat.wcid);
	*hw = mt76_phy_hw(dev, mstat.phy_idx);
+
+	phy = mt76_dev_phy(dev, mstat.phy_idx);
+	spin_lock_bh(&phy->rx_dbg_stats.lock);
+	phy->rx_dbg_stats.rx_to_mac80211++;
+	spin_unlock_bh(&phy->rx_dbg_stats.lock);
 }

 static void
@@ -1465,6 +1472,7 @@ void mt76_rx_complete(struct mt76_dev *dev, struct sk_buff_head *frames,

		mt76_check_ccmp_pn(skb);
		skb_shinfo(skb)->frag_list = NULL;
+		trace_mt76_rx_complete(dev, (struct mt76_rx_status *)skb->cb, 0);
		mt76_rx_convert(dev, skb, &hw, &sta);
		ieee80211_rx_list(hw, sta, skb, &list);

@@ -1474,6 +1482,7 @@ void mt76_rx_complete(struct mt76_dev *dev, struct sk_buff_head *frames,
			nskb = nskb->next;
			skb->next = NULL;

+			trace_mt76_rx_complete(dev, (struct mt76_rx_status *)skb->cb, 1);
			mt76_rx_convert(dev, skb, &hw, &sta);
			ieee80211_rx_list(hw, sta, skb, &list);
		}
@@ -1706,14 +1721,10 @@ EXPORT_SYMBOL_GPL(mt76_get_power_bound);
 int mt76_get_txpower(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
		     u32 link_id, int *dbm)
 {
-	struct mt76_phy *phy = mt76_vif_phy(hw, vif);
-	int n_chains, delta;
-
-	if (!phy)
-		return -EINVAL;
+	struct mt76_phy *phy = hw->priv;
+	int n_chains = hweight16(phy->chainmask);
+	int delta = mt76_tx_power_path_delta(n_chains);

-	n_chains = hweight16(phy->chainmask);
-	delta = mt76_tx_power_path_delta(n_chains);
	*dbm = DIV_ROUND_UP(phy->txpower_cur + delta, 2);

	return 0;
@@ -1985,7 +1996,7 @@ enum mt76_dfs_state mt76_phy_dfs_state(struct mt76_phy *phy)
		return MT_DFS_STATE_DISABLED;

	if (!phy->radar_enabled) {
-		if ((hw->conf.flags & IEEE80211_CONF_MONITOR) &&
+		if (((hw->conf.flags & IEEE80211_CONF_MONITOR) || phy->monitor_vif) &&
		    (phy->chandef.chan->flags & IEEE80211_CHAN_RADAR))
			return MT_DFS_STATE_ACTIVE;

diff --git a/drivers/net/wireless/mediatek/mt76/mcu.c b/drivers/net/wireless/mediatek/mt76/mcu.c
index 3353012e8542..700d3ce8b941 100644
--- a/drivers/net/wireless/mediatek/mt76/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mcu.c
@@ -4,6 +4,7 @@
  */

 #include "mt76.h"
+#include "mt76_connac.h"

 struct sk_buff *
 __mt76_mcu_msg_alloc(struct mt76_dev *dev, const void *data,
diff --git a/drivers/net/wireless/mediatek/mt76/mt76.h b/drivers/net/wireless/mediatek/mt76/mt76.h
index 4a475f9f43b2..870ff81d5f11 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76.h
+++ b/drivers/net/wireless/mediatek/mt76/mt76.h
@@ -19,6 +19,28 @@
 #include <net/page_pool/helpers.h>
 #include "util.h"
 #include "testmode.h"
+#include "debug.h"
+
+#define CHAN2G(_idx, _freq) {			\
+	.band = NL80211_BAND_2GHZ,		\
+	.center_freq = (_freq),			\
+	.hw_value = (_idx),			\
+	.max_power = 30,			\
+}
+
+#define CHAN5G(_idx, _freq) {			\
+	.band = NL80211_BAND_5GHZ,		\
+	.center_freq = (_freq),			\
+	.hw_value = (_idx),			\
+	.max_power = 30,			\
+}
+
+#define CHAN6G(_idx, _freq) {			\
+	.band = NL80211_BAND_6GHZ,		\
+	.center_freq = (_freq),			\
+	.hw_value = (_idx),			\
+	.max_power = 30,			\
+}

 #define MT_MCU_RING_SIZE	32
 #define MT_RX_BUF_SIZE		2048
@@ -29,6 +51,8 @@

 #define MT76_TOKEN_FREE_THR	64

+#define MT76_WED_SW_TOKEN_SIZE	15360
+
 #define MT_QFLAG_WED_RING	GENMASK(1, 0)
 #define MT_QFLAG_WED_TYPE	GENMASK(4, 2)
 #define MT_QFLAG_WED		BIT(5)
@@ -163,6 +187,34 @@ enum mt76_dfs_state {
	MT_DFS_STATE_ACTIVE,
 };

+enum {
+	/* Per dev counters*/
+	MT_RX_DROP_DMAD_RRO_REPEAT,
+	MT_RX_DROP_DMAD_RRO_OLDPKT,
+	MT_RX_DROP_DMAD_RRO_PN_CHK_FAIL,
+	MT_RX_DROP_DMAD_WO_FRAG,
+	MT_RX_DROP_DMAD_WO_DROP,
+	MT_RX_DROP_DMAD_ADDR_NOT_FOUND,
+	MT_RX_DROP_DMAD_TOKEN_NOT_FOUND,
+	MT_RX_DROP_DMAD_GET_TOKEN_FAIL,
+	MT_RX_DROP_DMAD_GET_RXWI_FAIL,
+	MT_RX_DROP_DMAD_NOMEM,
+	MT_RX_DROP_DMAD_DMA_MAPPING_FAIL,
+	MT_RX_DROP_FRAG,
+	MT_RX_DROP_BUILD_SKB_FAIL,
+
+	MT_RX_DROP_PER_Q_MAX,
+
+	/* Per phy counters */
+	MT_RX_DROP_RXD_ERR = 0,
+	MT_RX_DROP_STATE_ERR,
+	MT_RX_DROP_RFC_PKT,
+	MT_RX_DROP_AGG_SN_LESS,
+	MT_RX_DROP_AGG_DUP,
+
+	MT_RX_DROP_PER_PHY_MAX,
+};
+
 struct mt76_queue_buf {
	dma_addr_t addr;
	u16 len:15,
@@ -230,6 +282,7 @@ struct mt76_queue {
	dma_addr_t desc_dma;
	struct sk_buff *rx_head;
	struct page_pool *page_pool;
+	u32 rx_drop[MT_RX_DROP_PER_Q_MAX];
 };

 struct mt76_mcu_ops {
@@ -424,6 +490,7 @@ struct mt76_rx_tid {
	u16 nframes;

	u8 num;
+	u16 session_id;

	u8 started:1, stopped:1, timer_pending:1;

@@ -727,14 +794,22 @@ struct mt76_testmode_ops {
	int (*set_params)(struct mt76_phy *phy, struct nlattr **tb,
			  enum mt76_testmode_state new_state);
	int (*dump_stats)(struct mt76_phy *phy, struct sk_buff *msg);
+	void (*reset_rx_stats)(struct mt76_phy *phy);
+	void (*tx_stop)(struct mt76_phy *phy);
+	int (*set_eeprom)(struct mt76_phy *phy, u32 offset, u8 *val, u8 action);
+	int (*dump_precal)(struct mt76_phy *mphy, struct sk_buff *msg, int flag, int type);
 };

+#define MT_TM_FW_RX_COUNT	BIT(0)
+
 struct mt76_testmode_data {
	enum mt76_testmode_state state;

	u32 param_set[DIV_ROUND_UP(NUM_MT76_TM_ATTRS, 32)];
	struct sk_buff *tx_skb;

+	u8 sku_en;
+
	u32 tx_count;
	u16 tx_mpdu_len;

@@ -753,6 +829,14 @@ struct mt76_testmode_data {
	u32 tx_time;
	u32 tx_ipg;

+	u8 txbf_act;
+	u16 txbf_param[8];
+	bool is_txbf_dut;
+	bool bf_en;
+	bool bf_ever_en;
+	bool ibf;
+	bool ebf;
+
	u32 freq_offset;

	u8 tx_power[4];
@@ -767,7 +851,24 @@ struct mt76_testmode_data {
	struct {
		u64 packets[__MT_RXQ_MAX];
		u64 fcs_error[__MT_RXQ_MAX];
+		u64 len_mismatch;
	} rx_stats;
+	u8 flag;
+
+	struct {
+		u8 type;
+		u8 enable;
+	} cfg;
+
+	u8 aid;
+
+	u8 offchan_ch;
+	u8 offchan_center_ch;
+	u8 offchan_bw;
+
+	u8 ipi_threshold;
+	u32 ipi_period;
+	u8 ipi_reset;
 };

 struct mt76_vif_link {
@@ -795,3 +896,3 @@ struct mt76_vif_data {
	struct mt76_phy *roc_phy;
	u16 valid_links;
	u8 deflink_id;

	u8 band_to_link[__MT_MAX_BAND];
};

+enum {
+	MT_TX_DROP_IN_TESTMODE,
+	MT_TX_DROP_WCID_NOT_INIT,
+	MT_TX_DROP_STOPPED_QUEUE,
+	MT_TX_DROP_RESET_STATE,
+	MT_TX_DROP_GET_TXWI_FAIL,
+	MT_TX_DROP_DMA_FAIL,
+	MT_TX_DROP_AGG_EXCEEDED,
+	MT_TX_DROP_RING_FULL,
+	MT_TX_DROP_INVALID_SKB,
+	MT_TX_DROP_GET_TOKEN_FAIL,
+	MT_TX_DROP_ADDR_TRANS_FAIL,
+	MT_TX_DROP_INVALID_WCID,
+	MT_TX_DROP_INVALID_LINK,
+	MT_TX_DROP_MAX,
+};
+
+struct mt76_tx_debug {
+	u32 tx_from_mac80211;
+	u32 tx_to_hw;
+
+	u32 tx_drop[MT_TX_DROP_MAX];
+	spinlock_t lock;
+};
+
+struct mt76_rx_debug {
+	u32 rx_from_hw;
+	u32 rx_to_mac80211;
+
+	u32 rx_drop[MT_RX_DROP_PER_PHY_MAX];
+	spinlock_t lock;
 };

 struct mt76_phy {
@@ -810,6 +946,8 @@ struct mt76_phy {
	struct list_head tx_list;
	struct mt76_queue *q_tx[__MT_TXQ_MAX];

+	struct ieee80211_vif *monitor_vif;
+
	struct cfg80211_chan_def chandef;
	struct cfg80211_chan_def main_chandef;
	bool offchannel;
@@ -840,6 +978,7 @@ struct mt76_phy {

 #ifdef CONFIG_NL80211_TESTMODE
	struct mt76_testmode_data test;
+	struct mt76_list_mode_data *lists;
 #endif

	struct delayed_work mac_work;
@@ -859,6 +998,8 @@ struct mt76_phy {
		bool al;
		u8 pin;
	} leds;
+	struct mt76_tx_debug tx_dbg_stats;
+	struct mt76_rx_debug rx_dbg_stats;
 };

 struct mt76_dev {
@@ -972,6 +1113,11 @@ struct mt76_dev {
		struct mt76_usb usb;
		struct mt76_sdio sdio;
	};
+
+	unsigned int debug_mask;
+
+	const char *bin_file_name;
+	struct mt76_tx_debug tx_dbg_stats;
 };

 /* per-phy stats.  */
@@ -1077,6 +1223,14 @@ struct mt76_power_limits {
	s8 eht[16][16];
 };

+struct mt76_power_path_limits {
+	s8 cck[5];
+	s8 ofdm[5];
+	s8 ofdm_bf[4];
+	s8 ru[16][15];
+	s8 ru_bf[16][15];
+};
+
 struct mt76_ethtool_worker_info {
	u64 *data;
	int idx;
@@ -1209,7 +1367,6 @@ static inline int mt76_wed_dma_setup(struct mt76_dev *dev, struct mt76_queue *q,
	for (i = 0; i < ARRAY_SIZE((dev)->q_rx); i++)	\
		if ((dev)->q_rx[i].ndesc)

-
 #define mt76_dereference(p, dev) \
	rcu_dereference_protected(p, lockdep_is_held(&(dev)->mutex))

@@ -1248,6 +1405,7 @@ void mt76_eeprom_override(struct mt76_phy *phy);
 int mt76_get_of_data_from_mtd(struct mt76_dev *dev, void *eep, int offset, int len);
 int mt76_get_of_data_from_nvmem(struct mt76_dev *dev, void *eep,
				const char *cell_name, int len);
+bool mt76_check_bin_file_mode(struct mt76_dev *dev);

 struct mt76_queue *
 mt76_init_queue(struct mt76_dev *dev, int qid, int idx, int n_desc,
@@ -1489,8 +1663,6 @@ void mt76_sta_pre_rcu_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,

 int mt76_get_min_avg_rssi(struct mt76_dev *dev, u8 phy_idx);

-s8 mt76_get_power_bound(struct mt76_phy *phy, s8 txpower);
-
 int mt76_get_txpower(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
		     u32 link_id, int *dbm);
 int mt76_init_sar_power(struct ieee80211_hw *hw,
@@ -1547,6 +1719,24 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *skb,
 int mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state);
 int mt76_testmode_alloc_skb(struct mt76_phy *phy, u32 len);

+static inline void
+mt76_testmode_param_set(struct mt76_testmode_data *td, u16 idx)
+{
+#ifdef CONFIG_NL80211_TESTMODE
+	td->param_set[idx / 32] |= BIT(idx % 32);
+#endif
+}
+
+static inline bool
+mt76_testmode_param_present(struct mt76_testmode_data *td, u16 idx)
+{
+#ifdef CONFIG_NL80211_TESTMODE
+	return td->param_set[idx / 32] & BIT(idx % 32);
+#else
+	return false;
+#endif
+}
+
 static inline void mt76_testmode_reset(struct mt76_phy *phy, bool disable)
 {
 #ifdef CONFIG_NL80211_TESTMODE
@@ -1727,6 +1917,7 @@ mt76_find_channel_node(struct device_node *np, struct ieee80211_channel *chan);
 s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
			      struct ieee80211_channel *chan,
			      struct mt76_power_limits *dest,
+			      struct mt76_power_path_limits *dest_path,
			      s8 target_power);

 static inline bool mt76_queue_is_rx(struct mt76_dev *dev, struct mt76_queue *q)
@@ -1883,4 +2080,6 @@ mt76_vif_link_phy(struct mt76_vif_link *mlink)
	return ctx->phy;
 }

+s8 mt76_get_power_bound(struct mt76_phy *phy, s8 txpower);
+
 #endif
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/init.c b/drivers/net/wireless/mediatek/mt76/mt7615/init.c
index aae80005a3c1..54d3ade07d40 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/init.c
@@ -277,6 +277,7 @@ void mt7615_init_txpower(struct mt7615_dev *dev,
	u8 *eep = (u8 *)dev->mt76.eeprom.data;
	enum nl80211_band band = sband->band;
	struct mt76_power_limits limits;
+	struct mt76_power_path_limits limits_path;
	u8 rate_val;

	delta_idx = mt7615_eeprom_get_power_delta_index(dev, band);
@@ -306,7 +307,7 @@ void mt7615_init_txpower(struct mt7615_dev *dev,
		}

		target_power = mt76_get_rate_power_limits(&dev->mphy, chan,
-							  &limits,
+							  &limits, &limits_path,
							  target_power);
		target_power += delta;
		target_power = DIV_ROUND_UP(target_power, 2);
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
index 4064e193d4de..57ff38092054 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
@@ -2007,6 +2007,7 @@ static void mt7615_mcu_set_txpower_sku(struct mt7615_phy *phy, u8 *sku)
	struct mt76_phy *mphy = phy->mt76;
	struct ieee80211_hw *hw = mphy->hw;
	struct mt76_power_limits limits;
+	struct mt76_power_path_limits limits_path;
	s8 *limits_array = (s8 *)&limits;
	int n_chains = hweight8(mphy->antenna_mask);
	int tx_power = hw->conf.power_level * 2;
@@ -2069,7 +2070,7 @@ static void mt7615_mcu_set_txpower_sku(struct mt7615_phy *phy, u8 *sku)
	tx_power = mt76_get_sar_power(mphy, mphy->chandef.chan, tx_power);
	tx_power -= mt76_tx_power_path_delta(n_chains);
	tx_power = mt76_get_rate_power_limits(mphy, mphy->chandef.chan,
-					      &limits, tx_power);
+					      &limits, &limits_path, tx_power);
	mphy->txpower_cur = tx_power;

	if (is_mt7663(mphy->dev)) {
diff --git a/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c b/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
index 185ba57d416d..6e38e6c96866 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
@@ -2162,7 +2162,7 @@ mt76_connac_mcu_rate_txpower_band(struct mt76_phy *phy,
			sar_power = mt76_get_sar_power(phy, &chan, reg_power);

			mt76_get_rate_power_limits(phy, &chan, limits,
-						   sar_power);
+						   NULL, sar_power);

			tx_power_tlv.last_msg = ch_list[idx] == last_ch;
			sku_tlbv.channel = ch_list[idx];
diff --git a/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h b/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
index 478cd1886736..184740e0d415 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
+++ b/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
@@ -1058,4 +1060,5 @@ enum {
	MCU_UNI_EVENT_THERMAL = 0x35,
	MCU_UNI_EVENT_NIC_CAPAB = 0x43,
+	MCU_UNI_EVENT_TESTMODE_CTRL = 0x46,
	MCU_UNI_EVENT_CSI_REPORT = 0x4A,
	MCU_UNI_EVENT_WED_RRO = 0x57,
diff --git a/drivers/net/wireless/mediatek/mt76/mt76x2/debugfs.c b/drivers/net/wireless/mediatek/mt76/mt76x2/debugfs.c
new file mode 100644
index 000000000000..a9d52ba1e270
--- /dev/null
+++ b/drivers/net/wireless/mediatek/mt76/mt76x2/debugfs.c
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2016 Felix Fietkau <nbd@nbd.name>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/debugfs.h>
+#include "mt76x02.h"
+
+static int
+mt76x02_ampdu_stat_read(struct seq_file *file, void *data)
+{
+	struct mt76x02_dev *dev = file->private;
+	int i, j;
+
+	for (i = 0; i < 4; i++) {
+		seq_puts(file, "Length: ");
+		for (j = 0; j < 8; j++)
+			seq_printf(file, "%8d | ", i * 8 + j + 1);
+		seq_puts(file, "\n");
+		seq_puts(file, "Count:  ");
+		for (j = 0; j < 8; j++)
+			seq_printf(file, "%8d | ", dev->aggr_stats[i * 8 + j]);
+		seq_puts(file, "\n");
+		seq_puts(file, "--------");
+		for (j = 0; j < 8; j++)
+			seq_puts(file, "-----------");
+		seq_puts(file, "\n");
+	}
+
+	return 0;
+}
+
+static int
+mt76x02_ampdu_stat_open(struct inode *inode, struct file *f)
+{
+	return single_open(f, mt76x02_ampdu_stat_read, inode->i_private);
+}
+
+static int read_txpower(struct seq_file *file, void *data)
+{
+	struct mt76x02_dev *dev = dev_get_drvdata(file->private);
+
+	seq_printf(file, "Target power: %d\n", dev->target_power);
+
+	mt76_seq_puts_array(file, "Delta", dev->target_power_delta,
+			    ARRAY_SIZE(dev->target_power_delta));
+	return 0;
+}
+
+static const struct file_operations fops_ampdu_stat = {
+	.open = mt76x02_ampdu_stat_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int
+mt76x02_dfs_stat_read(struct seq_file *file, void *data)
+{
+	struct mt76x02_dev *dev = file->private;
+	struct mt76x02_dfs_pattern_detector *dfs_pd = &dev->dfs_pd;
+	int i;
+
+	seq_printf(file, "allocated sequences:\t%d\n",
+		   dfs_pd->seq_stats.seq_pool_len);
+	seq_printf(file, "used sequences:\t\t%d\n",
+		   dfs_pd->seq_stats.seq_len);
+	seq_puts(file, "\n");
+
+	for (i = 0; i < MT_DFS_NUM_ENGINES; i++) {
+		seq_printf(file, "engine: %d\n", i);
+		seq_printf(file, "  hw pattern detected:\t%d\n",
+			   dfs_pd->stats[i].hw_pattern);
+		seq_printf(file, "  hw pulse discarded:\t%d\n",
+			   dfs_pd->stats[i].hw_pulse_discarded);
+		seq_printf(file, "  sw pattern detected:\t%d\n",
+			   dfs_pd->stats[i].sw_pattern);
+	}
+
+	return 0;
+}
+
+static int
+mt76x02_dfs_stat_open(struct inode *inode, struct file *f)
+{
+	return single_open(f, mt76x02_dfs_stat_read, inode->i_private);
+}
+
+static const struct file_operations fops_dfs_stat = {
+	.open = mt76x02_dfs_stat_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int read_agc(struct seq_file *file, void *data)
+{
+	struct mt76x02_dev *dev = dev_get_drvdata(file->private);
+
+	seq_printf(file, "avg_rssi: %d\n", dev->cal.avg_rssi_all);
+	seq_printf(file, "low_gain: %d\n", dev->cal.low_gain);
+	seq_printf(file, "false_cca: %d\n", dev->cal.false_cca);
+	seq_printf(file, "agc_gain_adjust: %d\n", dev->cal.agc_gain_adjust);
+
+	return 0;
+}
+
+void mt76x02_init_debugfs(struct mt76x02_dev *dev)
+{
+	struct dentry *dir;
+
+	dir = mt76_register_debugfs(&dev->mt76);
+	if (!dir)
+		return;
+
+	debugfs_create_u8("temperature", 0400, dir, &dev->cal.temp);
+	debugfs_create_bool("tpc", 0600, dir, &dev->enable_tpc);
+
+	debugfs_create_file("ampdu_stat", 0400, dir, dev, &fops_ampdu_stat);
+	debugfs_create_file("dfs_stats", 0400, dir, dev, &fops_dfs_stat);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "txpower", dir,
+				    read_txpower);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "agc", dir, read_agc);
+}
+EXPORT_SYMBOL_GPL(mt76x02_init_debugfs);
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/init.c b/drivers/net/wireless/mediatek/mt76/mt7915/init.c
index 6cde7b701e27..e57f956fd88a 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/init.c
@@ -288,6 +288,7 @@ static void __mt7915_init_txpower(struct mt7915_phy *phy,
	int nss_delta = mt76_tx_power_path_delta(n_chains);
	int pwr_delta = mt7915_eeprom_get_power_delta(dev, sband->band);
	struct mt76_power_limits limits;
+	struct mt76_power_path_limits limits_path;

	for (i = 0; i < sband->n_channels; i++) {
		struct ieee80211_channel *chan = &sband->channels[i];
@@ -303,7 +304,7 @@ static void __mt7915_init_txpower(struct mt7915_phy *phy,

		target_power += pwr_delta;
		target_power = mt76_get_rate_power_limits(phy->mt76, chan,
-							  &limits,
+							  &limits, &limits_path,
							  target_power);
		target_power += nss_delta;
		target_power = DIV_ROUND_UP(target_power, 2);
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
index 427542777abc..58ae052dc669 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
@@ -3391,13 +3391,14 @@ int mt7915_mcu_set_txpower_sku(struct mt7915_phy *phy)
		.band_idx = phy->mt76->band_idx,
	};
	struct mt76_power_limits limits_array;
+	struct mt76_power_path_limits limits_path;
	s8 *la = (s8 *)&limits_array;
	int i, idx;
	int tx_power;

	tx_power = mt76_get_power_bound(mphy, hw->conf.power_level);
	tx_power = mt76_get_rate_power_limits(mphy, mphy->chandef.chan,
-					      &limits_array, tx_power);
+					      &limits_array, &limits_path, tx_power);
	mphy->txpower_cur = tx_power;

	for (i = 0, idx = 0; i < ARRAY_SIZE(mt7915_sku_group_len); i++) {
diff --git a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
index 286f602623c0..7f4ef06b6ae3 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
@@ -3504,6 +3504,7 @@ mt7925_mcu_rate_txpower_band(struct mt76_phy *phy,
		225, 227, 229, 233
	};
	struct mt76_power_limits *limits;
+	struct mt76_power_path_limits limits_path;
	struct mt7925_sku_tlv *sku_tlbv;
	const u8 *ch_list;

@@ -3583,6 +3584,7 @@ mt7925_mcu_rate_txpower_band(struct mt76_phy *phy,
			sar_power = mt76_get_sar_power(phy, &chan, reg_power);

			mt76_get_rate_power_limits(phy, &chan, limits,
+						   &limits_path,
						   sar_power);

			tx_power_tlv->last_msg = ch_list[idx] == last_ch;
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/Makefile b/drivers/net/wireless/mediatek/mt76/mt7996/Makefile
index 07c8b555c1ac..7d5cd4298041 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/Makefile
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/Makefile
@@ -1,8 +1,20 @@
 # SPDX-License-Identifier: ISC
+EXTRA_CFLAGS += -Werror -std=gnu11
+EXTRA_CFLAGS += -DCONFIG_MT76_LEDS
+EXTRA_CFLAGS += -DCONFIG_MTK_DEBUG
+EXTRA_CFLAGS += -DCONFIG_MTK_VENDOR
+EXTRA_CFLAGS += $(ADDITIONAL_CFLAGS)
+
+# NOTE:  The EXTRA_CFLAGS above doesn't seem to work for in-kernel
+# compile.  This below resolves that.
+ccflags-y += -DCONFIG_MTK_DEBUG -DCONFIG_MTK_VENDOR -DCONFIG_MT76_LEDS

 obj-$(CONFIG_MT7996E) += mt7996e.o

 mt7996e-y := pci.o init.o dma.o eeprom.o main.o mcu.o mac.o \
-	     debugfs.o mmio.o
+	     debugfs.o mmio.o vendor.o

 mt7996e-$(CONFIG_DEV_COREDUMP) += coredump.o
+mt7996e-$(CONFIG_NL80211_TESTMODE) += testmode.o
+
+mt7996e-y += mtk_debugfs.o mtk_mcu.o mtk_debugfs_i.o trace.o
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/debugfs.c b/drivers/net/wireless/mediatek/mt76/mt7996/debugfs.c
index 25cb9b5e0be2..a38dcc3e7e58 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/debugfs.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/debugfs.c
@@ -551,12 +706,15 @@ mt7996_txbf_stat_read_phy(struct mt7996_phy *phy, struct seq_file *s)
	seq_puts(s, "\n");
 }

 static int
 mt7996_tx_stats_show(struct seq_file *file, void *data)
 {
	struct mt7996_phy *phy = file->private;
	struct mt7996_dev *dev = phy->dev;
	struct mt76_mib_stats *mib = &phy->mib;
	u32 attempts, success, per;
-	int i;
+
+	mutex_lock(&dev->mt76.mutex);

	mt7996_mac_update_stats(phy);
	mt7996_ampdu_stat_read_phy(phy, file);
@@ -567,38 +725,10 @@ mt7996_tx_stats_show_phy(struct seq_file *file, struct mt7996_phy *phy)
	seq_printf(file, "Tx attempts: %8u (MPDUs)\n", attempts);
	seq_printf(file, "Tx success: %8u (MPDUs)\n", success);
	seq_printf(file, "Tx PER: %u%%\n", per);
+	seq_printf(file, "Tx RED drop: %8u\n", phy->red_drop);

	mt7996_txbf_stat_read_phy(phy, file);

-	/* Tx amsdu info */
-	seq_puts(file, "Tx MSDU statistics:\n");
-	for (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++) {
-		seq_printf(file, "AMSDU pack count of %d MSDU in TXD: %8d ",
-			   i + 1, mib->tx_amsdu[i]);
-		if (mib->tx_amsdu_cnt)
-			seq_printf(file, "(%3d%%)\n",
-				   mib->tx_amsdu[i] * 100 / mib->tx_amsdu_cnt);
-		else
-			seq_puts(file, "\n");
-	}
-}
-
-static int
-mt7996_tx_stats_show(struct seq_file *file, void *data)
-{
-	struct mt7996_dev *dev = file->private;
-	struct mt7996_phy *phy = &dev->phy;
-
-	mutex_lock(&dev->mt76.mutex);
-
-	mt7996_tx_stats_show_phy(file, phy);
-	phy = mt7996_phy2(dev);
-	if (phy)
-		mt7996_tx_stats_show_phy(file, phy);
-	phy = mt7996_phy3(dev);
-	if (phy)
-		mt7996_tx_stats_show_phy(file, phy);
-
	mutex_unlock(&dev->mt76.mutex);

	return 0;
@@ -691,8 +821,8 @@ mt7996_sta_hw_queue_read(void *data, struct ieee80211_sta *sta)
 static int
 mt7996_hw_queues_show(struct seq_file *file, void *data)
 {
	struct mt7996_phy *phy = file->private;
	struct mt7996_dev *dev = phy->dev;
	static const struct hw_queue_map ple_queue_map[] = {
		{ "CPU_Q0",  0,  1, MT_CTX0	      },
		{ "CPU_Q1",  1,  1, MT_CTX0 + 1	      },
@@ -748,15 +878,6 @@ mt7996_hw_queues_show(struct seq_file *file, void *data)
	/* iterate per-sta ple queue */
	ieee80211_iterate_stations_atomic(phy->mt76->hw,
					  mt7996_sta_hw_queue_read, file);
-	phy = mt7996_phy2(dev);
-	if (phy)
-		ieee80211_iterate_stations_atomic(phy->mt76->hw,
-						  mt7996_sta_hw_queue_read, file);
-	phy = mt7996_phy3(dev);
-	if (phy)
-		ieee80211_iterate_stations_atomic(phy->mt76->hw,
-						  mt7996_sta_hw_queue_read, file);
-
	/* pse queue */
	seq_puts(file, "PSE non-empty queue info:\n");
	mt7996_hw_queue_read(file, ARRAY_SIZE(pse_queue_map),
@@ -770,41 +891,80 @@ DEFINE_SHOW_ATTRIBUTE(mt7996_hw_queues);
 static int
 mt7996_xmit_queues_show(struct seq_file *file, void *data)
 {
	struct mt7996_phy *phy = file->private;
	struct mt7996_dev *dev = phy->dev;
	struct {
		struct mt76_queue *q;
		char *queue;
	} queue_map[] = {
-		{ dev->mphy.q_tx[MT_TXQ_BE],	 "  MAIN0"  },
-		{ NULL,				 "  MAIN1"  },
-		{ NULL,				 "  MAIN2"  },
+		{ phy->mt76->q_tx[MT_TXQ_BE],	 "   MAIN"  },
		{ dev->mt76.q_mcu[MT_MCUQ_WM],	 "  MCUWM"  },
		{ dev->mt76.q_mcu[MT_MCUQ_WA],	 "  MCUWA"  },
		{ dev->mt76.q_mcu[MT_MCUQ_FWDL], "MCUFWDL" },
	};
	int i;

-	phy = mt7996_phy2(dev);
-	if (phy)
-		queue_map[1].q = phy->mt76->q_tx[MT_TXQ_BE];
-
-	phy = mt7996_phy3(dev);
-	if (phy)
-		queue_map[2].q = phy->mt76->q_tx[MT_TXQ_BE];
-
	seq_puts(file, "     queue | hw-queued |      head |      tail |\n");
	for (i = 0; i < ARRAY_SIZE(queue_map); i++) {
		struct mt76_queue *q = queue_map[i].q;
+
+static ssize_t
+mt7996_efuse_get(struct file *file, char __user *user_buf,
+		 size_t count, loff_t *ppos)
 {
+	struct mt7996_dev *dev = file->private_data;
+	struct mt76_dev *mdev = &dev->mt76;
+	u8 *buff = mdev->otp.data;
+	int i;
+	ssize_t ret;
+	u32 block_num;
+
+	mdev->otp.size = MT7996_EEPROM_SIZE;
+	if (is_mt7996(&dev->mt76) && dev->var.type == MT7996_VAR_TYPE_444)
+		mdev->otp.size += 3 * MT_EE_CAL_UNIT;
+
+	if (!mdev->otp.data) {
+		mdev->otp.data = devm_kzalloc(mdev->dev, mdev->otp.size, GFP_KERNEL);
+		if (!mdev->otp.data)
+			return -ENOMEM;
+
+		block_num = DIV_ROUND_UP(mdev->otp.size, MT7996_EEPROM_BLOCK_SIZE);
+		for (i = 0; i < block_num; i++) {
+			buff = mdev->otp.data + i * MT7996_EEPROM_BLOCK_SIZE;
+			ret = mt7996_mcu_get_eeprom(dev, i * MT7996_EEPROM_BLOCK_SIZE,
+						    buff, MT7996_EEPROM_BLOCK_SIZE);
+			if (ret && ret != -EINVAL)
+				return ret;
+		}
+	}
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, mdev->otp.data, mdev->otp.size);
+
+	return ret;
+}
+
+static const struct file_operations mt7996_efuse_ops = {
+	.read = mt7996_efuse_get,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
int mt7996_init_band_debugfs(struct mt7996_phy *phy)
{
	struct mt7996_dev *dev = phy->dev;
	struct dentry *dir;
	char dir_name[10];

	if (!dev->debugfs_dir)
		return -EINVAL;

	snprintf(dir_name, sizeof(dir_name), "band%d", phy->mt76->band_idx);

	dir = debugfs_create_dir(dir_name, dev->debugfs_dir);
	if (!dir)
		return -ENOMEM;

	debugfs_create_file("hw-queues", 0400, dir, phy,
			    &mt7996_hw_queues_fops);
	debugfs_create_file("xmit-queues", 0400, dir, phy,
			    &mt7996_xmit_queues_fops);
	debugfs_create_file("sys_recovery", 0600, dir, phy,
			    &mt7996_sys_recovery_ops);
	debugfs_create_file("atf_enable", 0600, dir, phy, &fops_atf_enable);
	debugfs_create_file("tx_stats", 0400, dir, phy, &mt7996_tx_stats_fops);
	if (phy->mt76->cap.has_5ghz) {
		debugfs_create_u32("dfs_hw_pattern", 0400, dir,
				   &dev->hw_pattern);
		debugfs_create_file("radar_trigger", 0200, dir, dev,
				    &fops_radar_trigger);
		debugfs_create_devm_seqfile(dev->mt76.dev, "rdd_monitor", dir,
					    mt7996_rdd_monitor);
	}

#ifdef CONFIG_MTK_DEBUG
	mt7996_mtk_init_band_debugfs(phy, dir);
	mt7996_mtk_init_band_debugfs_internal(phy, dir);
#endif
	return 0;
}

 int mt7996_init_dev_debugfs(struct mt7996_phy *phy)
 {
	struct mt7996_dev *dev = phy->dev;
	struct dentry *dir;

	dir = mt76_register_debugfs_fops(phy->mt76, NULL);
	if (!dir)
		return -ENOMEM;
	debugfs_create_file("fw_debug_wm", 0600, dir, dev, &fops_fw_debug_wm);
	debugfs_create_file("fw_debug_wa", 0600, dir, dev, &fops_fw_debug_wa);
	debugfs_create_file("fw_debug_bin", 0600, dir, dev, &fops_fw_debug_bin);
@@ -893,3 +1186,4 @@ int mt7996_init_debugfs(struct mt7996_dev *dev)
	debugfs_create_devm_seqfile(dev->mt76.dev, "twt_stats", dir,
				    mt7996_twt_stats);
	debugfs_create_file("rf_regval", 0600, dir, dev, &fops_rf_regval);
+	debugfs_create_file("otp", 0400, dir, dev, &mt7996_efuse_ops);
	debugfs_create_devm_seqfile(dev->mt76.dev, "vow_info", dir,
	                            mt7996_vow_info_read);
	debugfs_create_devm_seqfile(dev->mt76.dev, "airtime", dir,
	                            mt7996_airtime_read);

	debugfs_create_file("fw_debug_muru_disable", 0600, dir, dev,
			    &fops_fw_debug_muru_disable);

-	debugfs_create_u32("dfs_hw_pattern", 0400, dir, &dev->hw_pattern);
-	debugfs_create_file("radar_trigger", 0200, dir, dev,
-			    &fops_radar_trigger);
-	debugfs_create_devm_seqfile(dev->mt76.dev, "rdd_monitor", dir,
-				    mt7996_rdd_monitor);

	if (phy == &dev->phy) {
		dev->debugfs_dir = dir;
 #ifdef CONFIG_MTK_DEBUG
		mt7996_mtk_init_dev_debugfs_internal(phy, dir);
 #endif
	}
+#ifdef CONFIG_MTK_DEBUG
+	debugfs_create_u16("wlan_idx", 0600, dir, &dev->wlan_idx);
+	mt7996_mtk_init_dev_debugfs(dev, dir);
+#endif

	return 0;
 }

diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/dma.c b/drivers/net/wireless/mediatek/mt76/mt7996/dma.c
index fe8cc1d3f738..832c44b4c4fd 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/dma.c
@@ -12,3 +12,3 @@ int mt7996_init_tx_queues(struct mt7996_phy *phy, int idx, int n_desc,
 {
	struct mt7996_dev *dev = phy->dev;
	u32 flags = 0;
	int i;

	if (phy->mt76->band_idx == MT_BAND1 && !dev->hif2 && is_mt7996(&dev->mt76)) {
		phy->mt76->q_tx[0] = phy->mt76->dev->phys[MT_BAND0]->q_tx[0];
		for (i = 1; i <= MT_TXQ_PSD; i++)
			phy->mt76->q_tx[i] = phy->mt76->q_tx[0];
		return 0;
	}

	if (mtk_wed_device_active(wed)) {
		ring_base += MT_TXQ_ID(0) * MT_RING_SIZE;
		idx -= MT_TXQ_ID(0);

-		if (phy->mt76->band_idx == MT_BAND2)
+		if (wed == &dev->mt76.mmio.wed_hif2)
			flags = MT_WED_Q_TX(0);
		else
			flags = MT_WED_Q_TX(idx);
@@ -89,30 +97,55 @@ static void mt7996_dma_config(struct mt7996_dev *dev)
			   MT7996_RXQ_RRO_BAND0);
		RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND0, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND0,
			   MT7996_RXQ_MSDU_PG_BAND0);
-		RXQ_CONFIG(MT_RXQ_TXFREE_BAND0, WFDMA0, MT_INT_RX_TXFREE_MAIN,
-			   MT7996_RXQ_TXFREE0);
-		/* band1 */
-		RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND1, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND1,
-			   MT7996_RXQ_MSDU_PG_BAND1);
-		/* band2 */
-		RXQ_CONFIG(MT_RXQ_RRO_BAND2, WFDMA0, MT_INT_RX_DONE_RRO_BAND2,
-			   MT7996_RXQ_RRO_BAND2);
-		RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND2, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND2,
-			   MT7996_RXQ_MSDU_PG_BAND2);
-		RXQ_CONFIG(MT_RXQ_TXFREE_BAND2, WFDMA0, MT_INT_RX_TXFREE_TRI,
-			   MT7996_RXQ_TXFREE2);
+		if (is_mt7996(&dev->mt76)) {
+			RXQ_CONFIG(MT_RXQ_TXFREE_BAND0, WFDMA0, MT_INT_RX_TXFREE_MAIN,
+				   MT7996_RXQ_TXFREE0);
+			/* band1 */
+			RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND1, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND1,
+				   MT7996_RXQ_MSDU_PG_BAND1);
+			/* band2 */
+			RXQ_CONFIG(MT_RXQ_RRO_BAND2, WFDMA0, MT_INT_RX_DONE_RRO_BAND2,
+				   MT7996_RXQ_RRO_BAND2);
+			RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND2, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND2,
+				   MT7996_RXQ_MSDU_PG_BAND2);
+			RXQ_CONFIG(MT_RXQ_TXFREE_BAND2, WFDMA0, MT_INT_RX_TXFREE_TRI,
+				   MT7996_RXQ_TXFREE2);
+		} else {
+			RXQ_CONFIG(MT_RXQ_RRO_BAND1, WFDMA0, MT_INT_RX_DONE_RRO_BAND1,
+				   MT7996_RXQ_RRO_BAND1);
+		}

		RXQ_CONFIG(MT_RXQ_RRO_IND, WFDMA0, MT_INT_RX_DONE_RRO_IND,
			   MT7996_RXQ_RRO_IND);
	}

	/* data tx queue */
-	TXQ_CONFIG(0, WFDMA0, MT_INT_TX_DONE_BAND0, MT7996_TXQ_BAND0);
	if (is_mt7996(&dev->mt76)) {
-		TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
-		TXQ_CONFIG(2, WFDMA0, MT_INT_TX_DONE_BAND2, MT7996_TXQ_BAND2);
+		TXQ_CONFIG(0, WFDMA0, MT_INT_TX_DONE_BAND0, MT7996_TXQ_BAND0);
+		if (dev->hif2) {
+			if (dev->option_type == 2) {
+				/*  bn1:ring21 bn2:ring19 */
+				TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND2, MT7996_TXQ_BAND2);
+				TXQ_CONFIG(2, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+			} else {
+				/* default bn1:ring19 bn2:ring21 */
+				TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+				TXQ_CONFIG(2, WFDMA0, MT_INT_TX_DONE_BAND2, MT7996_TXQ_BAND2);
+			}
+		} else {
+			/* single pcie bn0/1:ring18 bn2:ring19 */
+			TXQ_CONFIG(2, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+		}
	} else {
-		TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+		if (dev->hif2) {
+			/*  bn0:ring18 bn1:ring21 */
+			TXQ_CONFIG(0, WFDMA0, MT_INT_TX_DONE_BAND0, MT7996_TXQ_BAND0);
+			TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND2, MT7996_TXQ_BAND2);
+		} else {
+			/* single pcie bn0:ring18 bn1:ring19 */
+			TXQ_CONFIG(0, WFDMA0, MT_INT_TX_DONE_BAND0, MT7996_TXQ_BAND0);
+			TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+		}
	}

	/* mcu tx queue */
@@ -288,8 +321,11 @@ void mt7996_dma_start(struct mt7996_dev *dev, bool reset, bool wed_reset)
	if (mt7996_band_valid(dev, MT_BAND0))
		irq_mask |= MT_INT_BAND0_RX_DONE;

-	if (mt7996_band_valid(dev, MT_BAND1))
+	if (mt7996_band_valid(dev, MT_BAND1)) {
		irq_mask |= MT_INT_BAND1_RX_DONE;
+		if (is_mt7992(&dev->mt76) && dev->hif2)
+			irq_mask |= MT_INT_RX_TXFREE_BAND1_EXT;
+	}

	if (mt7996_band_valid(dev, MT_BAND2))
		irq_mask |= MT_INT_BAND2_RX_DONE;
@@ -378,13 +414,60 @@ static void mt7996_dma_enable(struct mt7996_dev *dev, bool reset)
			 WF_WFDMA0_GLO_CFG_EXT1_TX_FCTRL_MODE);

		mt76_set(dev, MT_WFDMA_HOST_CONFIG,
-			 MT_WFDMA_HOST_CONFIG_PDMA_BAND |
-			 MT_WFDMA_HOST_CONFIG_BAND2_PCIE1);
+			 MT_WFDMA_HOST_CONFIG_PDMA_BAND);
+
+		mt76_clear(dev, MT_WFDMA_HOST_CONFIG,
+			   MT_WFDMA_HOST_CONFIG_BAND0_PCIE1 |
+			   MT_WFDMA_HOST_CONFIG_BAND1_PCIE1 |
+			   MT_WFDMA_HOST_CONFIG_BAND2_PCIE1);
+
+		switch (dev->option_type) {
+		case 2:
+			/* eagle + 7988d */
+			if (is_mt7996(&dev->mt76))
+				mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+					 MT_WFDMA_HOST_CONFIG_BAND0_PCIE1 |
+					 MT_WFDMA_HOST_CONFIG_BAND1_PCIE1);
+			else
+				mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+					 MT_WFDMA_HOST_CONFIG_BAND1_PCIE1);
+			break;
+		case 3:
+			mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+				 MT_WFDMA_HOST_CONFIG_BAND0_PCIE1);
+
+			break;
+		default:
+			if (is_mt7996(&dev->mt76))
+				mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+					 MT_WFDMA_HOST_CONFIG_BAND2_PCIE1);
+			else
+				mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+					 MT_WFDMA_HOST_CONFIG_BAND1_PCIE1);
+			break;
+		}

		/* AXI read outstanding number */
		mt76_rmw(dev, MT_WFDMA_AXI_R2A_CTRL,
			 MT_WFDMA_AXI_R2A_CTRL_OUTSTAND_MASK, 0x14);

+		if (dev->hif2->speed < PCIE_SPEED_5_0GT ||
+		    (dev->hif2->speed == PCIE_SPEED_5_0GT && dev->hif2->width < 2)) {
+			mt76_rmw(dev, WF_WFDMA0_GLO_CFG_EXT0 + hif1_ofs,
+				 WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK,
+				 FIELD_PREP(WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK, 0x1));
+			mt76_rmw(dev, MT_WFDMA_AXI_R2A_CTRL2,
+				 MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK,
+				 FIELD_PREP(MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK, 0x1));
+		} else if (dev->hif2->speed < PCIE_SPEED_8_0GT ||
+			   (dev->hif2->speed == PCIE_SPEED_8_0GT && dev->hif2->width < 2)) {
+			mt76_rmw(dev, WF_WFDMA0_GLO_CFG_EXT0 + hif1_ofs,
+				 WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK,
+				 FIELD_PREP(WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK, 0x2));
+			mt76_rmw(dev, MT_WFDMA_AXI_R2A_CTRL2,
+				 MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK,
+				 FIELD_PREP(MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK, 0x2));
+		}
		/* WFDMA rx threshold */
		mt76_wr(dev, MT_WFDMA0_PAUSE_RX_Q_45_TH + hif1_ofs, 0xc000c);
		mt76_wr(dev, MT_WFDMA0_PAUSE_RX_Q_67_TH + hif1_ofs, 0x10008);
@@ -397,12 +480,17 @@ static void mt7996_dma_enable(struct mt7996_dev *dev, bool reset)
		 * so, redirect pcie0 rx ring3 interrupt to pcie1
		 */
		if (mtk_wed_device_active(&dev->mt76.mmio.wed) &&
-		    dev->has_rro)
+		    dev->has_rro) {
+			u32 intr = is_mt7996(&dev->mt76) ?
+				   MT_WFDMA0_RX_INT_SEL_RING6 :
+				   MT_WFDMA0_RX_INT_SEL_RING9 |
+				   MT_WFDMA0_RX_INT_SEL_RING5;
			mt76_set(dev, MT_WFDMA0_RX_INT_PCIE_SEL + hif1_ofs,
-				 MT_WFDMA0_RX_INT_SEL_RING6);
-		else
+				 intr);
+		} else {
			mt76_set(dev, MT_WFDMA0_RX_INT_PCIE_SEL,
				 MT_WFDMA0_RX_INT_SEL_RING3);
+		}
	}

	mt7996_dma_start(dev, reset, true);
@@ -437,7 +525,7 @@ int mt7996_dma_rro_init(struct mt7996_dev *dev)
	if (ret)
		return ret;

-	if (mt7996_band_valid(dev, MT_BAND1)) {
+	if (mt7996_band_valid(dev, MT_BAND1) && is_mt7996(&dev->mt76)) {
		/* rx msdu page queue for band1 */
		mdev->q_rx[MT_RXQ_MSDU_PAGE_BAND1].flags =
			MT_WED_RRO_Q_MSDU_PG(1) | MT_QFLAG_WED_RRO_EN;
@@ -560,7 +648,9 @@ int mt7996_dma_init(struct mt7996_dev *dev)
		return ret;

	/* tx free notify event from WA for band0 */
-	if (mtk_wed_device_active(wed) && !dev->has_rro) {
+	if (mtk_wed_device_active(wed) &&
+	    ((is_mt7996(&dev->mt76) && !dev->has_rro) ||
+	     (is_mt7992(&dev->mt76)))) {
		dev->mt76.q_rx[MT_RXQ_MAIN_WA].flags = MT_WED_Q_TXFREE;
		dev->mt76.q_rx[MT_RXQ_MAIN_WA].wed = wed;
	}
@@ -604,6 +694,10 @@ int mt7996_dma_init(struct mt7996_dev *dev)
	if (mt7996_band_valid(dev, MT_BAND2)) {
		/* rx data queue for mt7996 band2 */
		rx_base = MT_RXQ_RING_BASE(MT_RXQ_BAND2) + hif1_ofs;
+		if (mtk_wed_device_active(wed_hif2) && mtk_wed_get_rx_capa(wed_hif2)) {
+			dev->mt76.q_rx[MT_RXQ_BAND2].flags = MT_WED_Q_RX(0);
+			dev->mt76.q_rx[MT_RXQ_BAND2].wed = wed_hif2;
+		}
		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_BAND2],
				       MT_RXQ_ID(MT_RXQ_BAND2),
				       MT7996_RX_RING_SIZE,
@@ -630,6 +724,11 @@ int mt7996_dma_init(struct mt7996_dev *dev)
	} else if (mt7996_band_valid(dev, MT_BAND1)) {
		/* rx data queue for mt7992 band1 */
		rx_base = MT_RXQ_RING_BASE(MT_RXQ_BAND1) + hif1_ofs;
+		if (mtk_wed_device_active(wed) && mtk_wed_get_rx_capa(wed)) {
+			dev->mt76.q_rx[MT_RXQ_BAND1].flags = MT_WED_Q_RX(1);
+			dev->mt76.q_rx[MT_RXQ_BAND1].wed = wed;
+		}
+
		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_BAND1],
				       MT_RXQ_ID(MT_RXQ_BAND1),
				       MT7996_RX_RING_SIZE,
@@ -641,6 +740,10 @@ int mt7996_dma_init(struct mt7996_dev *dev)
		/* tx free notify event from WA for mt7992 band1 */
		if (mt7996_has_wa(dev)) {
			rx_base = MT_RXQ_RING_BASE(MT_RXQ_BAND1_WA) + hif1_ofs;
+			if (mtk_wed_device_active(wed_hif2)) {
+				dev->mt76.q_rx[MT_RXQ_BAND1_WA].flags = MT_WED_Q_TXFREE;
+				dev->mt76.q_rx[MT_RXQ_BAND1_WA].wed = wed_hif2;
+			}
			ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_BAND1_WA],
					       MT_RXQ_ID(MT_RXQ_BAND1_WA),
					       MT7996_RX_MCU_RING_SIZE,
@@ -665,17 +768,30 @@ int mt7996_dma_init(struct mt7996_dev *dev)
		if (ret)
			return ret;

-		/* tx free notify event from WA for band0 */
-		dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].flags = MT_WED_Q_TXFREE;
-		dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].wed = wed;
+		if (is_mt7992(&dev->mt76)) {
+			dev->mt76.q_rx[MT_RXQ_RRO_BAND1].flags =
+				MT_WED_RRO_Q_DATA(1) | MT_QFLAG_WED_RRO_EN;
+			dev->mt76.q_rx[MT_RXQ_RRO_BAND1].wed = wed;
+			ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_RRO_BAND1],
+					       MT_RXQ_ID(MT_RXQ_RRO_BAND1),
+					       MT7996_RX_RING_SIZE,
+					       MT7996_RX_BUF_SIZE,
+					       MT_RXQ_RING_BASE(MT_RXQ_RRO_BAND1) + hif1_ofs);
+			if (ret)
+				return ret;
+		} else {
+			/* tx free notify event from WA for band0 */
+			dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].flags = MT_WED_Q_TXFREE;
+			dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].wed = wed;

-		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0],
-				       MT_RXQ_ID(MT_RXQ_TXFREE_BAND0),
-				       MT7996_RX_MCU_RING_SIZE,
-				       MT7996_RX_BUF_SIZE,
-				       MT_RXQ_RING_BASE(MT_RXQ_TXFREE_BAND0));
-		if (ret)
-			return ret;
+			ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0],
+					       MT_RXQ_ID(MT_RXQ_TXFREE_BAND0),
+					       MT7996_RX_MCU_RING_SIZE,
+					       MT7996_RX_BUF_SIZE,
+					       MT_RXQ_RING_BASE(MT_RXQ_TXFREE_BAND0));
+			if (ret)
+				return ret;
+		}

		if (mt7996_band_valid(dev, MT_BAND2)) {
			/* rx rro data queue for band2 */
@@ -747,11 +863,23 @@ void mt7996_dma_reset(struct mt7996_dev *dev, bool force)
	for (i = 0; i < __MT_MCUQ_MAX; i++)
		mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[i], true);

+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER tx queue clean up done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
	mt76_for_each_q_rx(&dev->mt76, i)
		mt76_queue_rx_cleanup(dev, &dev->mt76.q_rx[i]);

+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER rx queue clean up done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
	mt76_tx_status_check(&dev->mt76, true);

+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER mt76_tx_status_check done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
	/* reset wfsys */
	if (force)
		mt7996_wfsys_reset(dev);
@@ -762,7 +890,15 @@ void mt7996_dma_reset(struct mt7996_dev *dev, bool force)
	if (mtk_wed_device_active(&dev->mt76.mmio.wed))
		mtk_wed_device_dma_reset(&dev->mt76.mmio.wed);

+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER wed dma reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
	mt7996_dma_disable(dev, force);
+
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER dma disable done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
	mt76_wed_dma_reset(&dev->mt76);

	/* reset hw queues */
@@ -774,4 +910,8 @@ void mt7996_dma_reset(struct mt7996_dev *dev, bool force)
			mt76_dma_reset_tx_queue(&dev->mt76, phy3->q_tx[i]);
	}

+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER dma tx queue reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
	for (i = 0; i < __MT_MCUQ_MAX; i++)
		mt76_queue_reset(dev, dev->mt76.q_mcu[i], true);

+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER mcu queue reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
	mt76_for_each_q_rx(&dev->mt76, i) {
-		if (mtk_wed_device_active(&dev->mt76.mmio.wed))
+		if (mtk_wed_device_active(&dev->mt76.mmio.wed)) {
			if (mt76_queue_is_wed_rro(&dev->mt76.q_rx[i]) ||
-			    mt76_queue_is_wed_tx_free(&dev->mt76.q_rx[i]))
+			    mt76_queue_is_wed_tx_free(&dev->mt76.q_rx[i])) {
+				if (force && mt76_queue_is_wed_rro_data(&dev->mt76.q_rx[i]))
+					mt76_queue_reset(dev, &dev->mt76.q_rx[i], false);
				continue;
+			}
+		}

		mt76_queue_reset(dev, &dev->mt76.q_rx[i], true);
	}

+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER rx queue reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
	mt76_tx_status_check(&dev->mt76, true);

-	mt76_for_each_q_rx(&dev->mt76, i)
+	mt76_for_each_q_rx(&dev->mt76, i) {
+		if (mtk_wed_device_active(&dev->mt76.mmio.wed) && force &&
+		    (mt76_queue_is_wed_rro_ind(&dev->mt76.q_rx[i]) ||
+		     mt76_queue_is_wed_rro_msdu_pg(&dev->mt76.q_rx[i])))
+			continue;
+
		mt76_queue_rx_reset(dev, i);
+	}
+
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER rx queue rx reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));

	mt7996_dma_enable(dev, !force);
+
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER dma enable done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
 }

 void mt7996_dma_cleanup(struct mt7996_dev *dev)
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/eeprom.c b/drivers/net/wireless/mediatek/mt76/mt7996/eeprom.c
index 87c6192b6384..72e8c9ecb759 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/eeprom.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/eeprom.c
@@ -6,6 +6,80 @@
 #include <linux/firmware.h>
 #include "mt7996.h"
 #include "eeprom.h"
+#include <linux/moduleparam.h>
+
+static bool testmode_enable;
+module_param(testmode_enable, bool, 0644);
+MODULE_PARM_DESC(testmode_enable, "Enable testmode");
+
+const struct ieee80211_channel dpd_2g_ch_list_bw20[] = {
+	CHAN2G(3, 2422),
+	CHAN2G(7, 2442),
+	CHAN2G(11, 2462)
+};
+
+const struct ieee80211_channel dpd_5g_skip_ch_list[] = {
+	CHAN5G(68, 5340),
+	CHAN5G(72, 5360),
+	CHAN5G(76, 5380),
+	CHAN5G(80, 5400),
+	CHAN5G(84, 5420),
+	CHAN5G(88, 5440),
+	CHAN5G(92, 5460),
+	CHAN5G(96, 5480)
+};
+
+const struct ieee80211_channel dpd_5g_ch_list_bw80[] = {
+	CHAN5G(42, 5210),
+	CHAN5G(58, 5290),
+	CHAN5G(106, 5530),
+	CHAN5G(122, 5610),
+	CHAN5G(138, 5690),
+	CHAN5G(155, 5775),
+	CHAN5G(171, 5855)
+};
+
+const struct ieee80211_channel dpd_5g_ch_list_bw160[] = {
+	CHAN5G(50, 5250),
+	CHAN5G(114, 5570),
+	CHAN5G(163, 5815)
+};
+
+const struct ieee80211_channel dpd_6g_ch_list_bw80[] = {
+	CHAN6G(7, 5985),
+	CHAN6G(23, 6065),
+	CHAN6G(39, 6145),
+	CHAN6G(55, 6225),
+	CHAN6G(71, 6305),
+	CHAN6G(87, 6385),
+	CHAN6G(103, 6465),
+	CHAN6G(119, 6545),
+	CHAN6G(135, 6625),
+	CHAN6G(151, 6705),
+	CHAN6G(167, 6785),
+	CHAN6G(183, 6865),
+	CHAN6G(199, 6945),
+	CHAN6G(215, 7025)
+};
+
+const struct ieee80211_channel dpd_6g_ch_list_bw160[] = {
+	CHAN6G(15, 6025),
+	CHAN6G(47, 6185),
+	CHAN6G(79, 6345),
+	CHAN6G(111, 6505),
+	CHAN6G(143, 6665),
+	CHAN6G(175, 6825),
+	CHAN6G(207, 6985)
+};
+
+const struct ieee80211_channel dpd_6g_ch_list_bw320[] = {
+	CHAN6G(31, 6105),
+	CHAN6G(63, 6265),
+	CHAN6G(95, 6425),
+	CHAN6G(127, 6585),
+	CHAN6G(159, 6745),
+	CHAN6G(191, 6905)
+};

 static int mt7996_check_eeprom(struct mt7996_dev *dev)
 {
@@ -24,7 +98,7 @@ static int mt7996_check_eeprom(struct mt7996_dev *dev)
	}
 }

-static char *mt7996_eeprom_name(struct mt7996_dev *dev)
+const char *mt7996_eeprom_name(struct mt7996_dev *dev)
 {
	switch (mt76_chip(&dev->mt76)) {
	case MT7992_DEVICE_ID:
@@ -33,6 +107,8 @@ static char *mt7996_eeprom_name(struct mt7996_dev *dev)
			if (dev->var.fem == MT7996_FEM_INT)
				return MT7992_EEPROM_DEFAULT_23_INT;
			return MT7992_EEPROM_DEFAULT_23;
+		case MT7992_VAR_TYPE_24:
+			return MT7992_EEPROM_DEFAULT_24;
		case MT7992_VAR_TYPE_44:
		default:
			if (dev->var.fem == MT7996_FEM_INT)
@@ -52,6 +128,8 @@ static char *mt7996_eeprom_name(struct mt7996_dev *dev)
			if (dev->var.fem == MT7996_FEM_INT)
				return MT7996_EEPROM_DEFAULT_233_INT;
			return MT7996_EEPROM_DEFAULT_233;
+		case MT7996_VAR_TYPE_404:
+			return MT7996_EEPROM_DEFAULT_404;
		case MT7996_VAR_TYPE_444:
		default:
			if (dev->var.fem == MT7996_FEM_INT)
@@ -153,7 +231,10 @@ mt7996_eeprom_check_or_use_default(struct mt7996_dev *dev, bool use_default)

	dev_warn(dev->mt76.dev, "eeprom load fail, use default bin\n");
	memcpy(eeprom, fw->data, MT7996_EEPROM_SIZE);
+	dev->bin_file_mode = false;
	dev->flash_mode = true;
+	dev->eeprom_mode = DEFAULT_BIN_MODE;
+	eeprom[MT_EE_TESTMODE_EN] = dev->testmode_enable;

 out:
	release_firmware(fw);
@@ -161,20 +242,84 @@ mt7996_eeprom_check_or_use_default(struct mt7996_dev *dev, bool use_default)
	return ret;
 }

-static int mt7996_eeprom_load(struct mt7996_dev *dev)
+static int
+mt7996_eeprom_load_bin(struct mt7996_dev *dev)
 {
-	bool use_default = false;
+	u8 *eeprom = dev->mt76.eeprom.data;
+	const struct firmware *fw = NULL;
	int ret;

-	ret = mt76_eeprom_init(&dev->mt76, MT7996_EEPROM_SIZE);
-	if (ret < 0)
+	ret = request_firmware(&fw, dev->mt76.bin_file_name, dev->mt76.dev);
+	if (ret)
		return ret;

-	if (ret && !mt7996_check_eeprom(dev)) {
-		dev->flash_mode = true;
+	if (!fw || !fw->data) {
+		dev_err(dev->mt76.dev, "Invalid bin %s\n", dev->mt76.bin_file_name);
+		ret = -EINVAL;
		goto out;
	}

+	memcpy(eeprom, fw->data, MT7996_EEPROM_SIZE);
+	dev->flash_mode = true;
+
+out:
+	release_firmware(fw);
+	return ret;
+}
+
+static int mt7996_eeprom_load_flash(struct mt7996_dev *dev)
+{
+	int ret = 1;
+
+	/* return > 0 for load success, return 0 for load failed, return < 0 for no memory */
+	dev->bin_file_mode = mt76_check_bin_file_mode(&dev->mt76);
+	if (dev->bin_file_mode) {
+		dev->mt76.eeprom.size = MT7996_EEPROM_SIZE;
+		dev->mt76.eeprom.data = devm_kzalloc(dev->mt76.dev, dev->mt76.eeprom.size,
+						     GFP_KERNEL);
+		if (!dev->mt76.eeprom.data)
+			return -ENOMEM;
+
+		if (mt7996_eeprom_load_bin(dev))
+			return 0;
+	} else {
+		ret = mt76_eeprom_init(&dev->mt76, MT7996_EEPROM_SIZE);
+	}
+
+	if (mt7996_check_eeprom(dev))
+		return 0;
+
+	return ret;
+}
+
+int mt7996_eeprom_check_fw_mode(struct mt7996_dev *dev)
+{
+	u8 *eeprom;
+	int ret;
+
+	dev->testmode_enable = testmode_enable;
+
+	/* load eeprom in flash or bin file mode to determine fw mode */
+	ret = mt7996_eeprom_load_flash(dev);
+	if (ret <= 0)
+		goto out;
+
+	dev->flash_mode = true;
+	dev->eeprom_mode = dev->bin_file_mode ? BIN_FILE_MODE : FLASH_MODE;
+	eeprom = dev->mt76.eeprom.data;
+	/* testmode enable priority: eeprom field > module parameter */
+	dev->testmode_enable = eeprom[MT_EE_TESTMODE_EN];
+
+out:
+	return ret;
+}
+
+static int mt7996_eeprom_load(struct mt7996_dev *dev)
+{
+	bool use_default = false;
+	int ret;
+
+	/* flash or bin file mode eeprom is loaded before mcu init */
	if (!dev->flash_mode) {
		u32 eeprom_blk_size = MT7996_EEPROM_BLOCK_SIZE;
		u32 block_num = DIV_ROUND_UP(MT7996_EEPROM_SIZE, eeprom_blk_size);
@@ -212,6 +357,7 @@ static int mt7996_eeprom_load(struct mt7996_dev *dev)
				goto out;
			}
		}
+		dev->eeprom_mode = EFUSE_MODE;
	}

 out:
@@ -232,6 +378,8 @@ static int mt7996_eeprom_parse_efuse_hw_cap(struct mt7996_phy *phy,
	if (ret)
		return ret;

+	/* for internal development */
+	dev->has_eht = true;
	if (cap) {
		u8 band_offs = phy->mt76->band_idx * 3;

@@ -321,14 +469,118 @@ int mt7996_eeprom_parse_hw_cap(struct mt7996_dev *dev, struct mt7996_phy *phy)
	return mt7996_eeprom_parse_band_config(phy);
 }

+static int
+mt7996_eeprom_load_precal_binfile(struct mt7996_dev *dev, u32 offs, u32 size)
+{
+	const struct firmware *fw = NULL;
+	int ret;
+
+	ret = request_firmware(&fw, dev->mt76.bin_file_name, dev->mt76.dev);
+	if (ret)
+		return ret;
+
+	if (!fw || !fw->data) {
+		dev_err(dev->mt76.dev, "Invalid bin (bin file mode), load precal fail\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	memcpy(dev->cal, fw->data + offs, size);
+
+out:
+	release_firmware(fw);
+
+	return ret;
+}
+
+static void mt7996_eeprom_init_precal(struct mt7996_dev *dev)
+{
+#define MT76_CHANNELS_5GHZ_SIZE		36	/* ARRAY_SIZE(mt76_channels_5ghz) */
+#define MT76_CHANNELS_6GHZ_SIZE		59	/* ARRAY_SIZE(mt76_channels_6ghz) */
+
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_2G] = ARRAY_SIZE(dpd_2g_ch_list_bw20);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_5G_SKIP] = ARRAY_SIZE(dpd_5g_skip_ch_list);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_5G] = MT76_CHANNELS_5GHZ_SIZE -
+						   DPD_CH_NUM(BW20_5G_SKIP);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW160_5G] = ARRAY_SIZE(dpd_5g_ch_list_bw160);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_6G] = MT76_CHANNELS_6GHZ_SIZE;
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW160_6G] = ARRAY_SIZE(dpd_6g_ch_list_bw160);
+
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		dev->prek.rev = mt7996_prek_rev;
+		if (dev->var.type == MT7996_VAR_TYPE_233)
+			dev->prek.rev = mt7996_prek_rev_233;
+		/* 5g & 6g bw 80 dpd channel list is not used */
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW320_6G] = ARRAY_SIZE(dpd_6g_ch_list_bw320);
+		break;
+	case MT7992_DEVICE_ID:
+		dev->prek.rev  = mt7992_prek_rev;
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW80_5G] = ARRAY_SIZE(dpd_5g_ch_list_bw80);
+		/* 6g is not used in current sku */
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_6G] = 0;
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW80_6G] = 0;
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW160_6G] = 0;
+		break;
+	default:
+		dev->prek.rev  = mt7996_prek_rev;
+		break;
+	}
+}
+
+static int mt7996_eeprom_load_precal(struct mt7996_dev *dev)
+{
+	struct mt76_dev *mdev = &dev->mt76;
+	u8 *eeprom = mdev->eeprom.data;
+	u32 val = eeprom[MT_EE_DO_PRE_CAL];
+	u32 size, offs = MT_EE_PRECAL;
+	int ret;
+
+	mt7996_eeprom_init_precal(dev);
+
+	if (!dev->flash_mode || !val)
+		return 0;
+
+	size = MT_EE_CAL_GROUP_SIZE + MT_EE_CAL_DPD_SIZE;
+
+	dev->cal = devm_kzalloc(mdev->dev, size, GFP_KERNEL);
+	if (!dev->cal) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	if (dev->bin_file_mode) {
+		ret = mt7996_eeprom_load_precal_binfile(dev, offs, size);
+		if (ret)
+			goto fail;
+	}
+
+	ret = mt76_get_of_data_from_mtd(mdev, dev->cal, offs, size);
+	if (!ret)
+		return 0;
+
+	ret = mt76_get_of_data_from_nvmem(mdev, dev->cal, "precal", size);
+	if (!ret)
+		return 0;
+
+fail:
+	dev_warn(dev->mt76.dev, "Failed to load precal data: %d\n", ret);
+	devm_kfree(dev->mt76.dev, dev->cal);
+	dev->cal = NULL;
+
+	return ret;
+}
+
 int mt7996_eeprom_init(struct mt7996_dev *dev)
 {
	int ret;

	ret = mt7996_eeprom_load(dev);
-	if (ret < 0)
+	if (ret)
		return ret;

+	mt7996_eeprom_load_precal(dev);
+
	ret = mt7996_eeprom_parse_hw_cap(dev, &dev->phy);
	if (ret < 0)
		return ret;
@@ -404,3 +656,37 @@ bool mt7996_eeprom_has_background_radar(struct mt7996_dev *dev)

	return true;
 }
+
+const u8 mt7996_sku_group_len[] = {
+	[SKU_CCK] = 4,
+	[SKU_OFDM] = 8,
+	[SKU_HT20] = 8,
+	[SKU_HT40] = 9,
+	[SKU_VHT20] = 12,
+	[SKU_VHT40] = 12,
+	[SKU_VHT80] = 12,
+	[SKU_VHT160] = 12,
+	[SKU_HE26] = 12,
+	[SKU_HE52] = 12,
+	[SKU_HE106] = 12,
+	[SKU_HE242] = 12,
+	[SKU_HE484] = 12,
+	[SKU_HE996] = 12,
+	[SKU_HE2x996] = 12,
+	[SKU_EHT26] = 16,
+	[SKU_EHT52] = 16,
+	[SKU_EHT106] = 16,
+	[SKU_EHT242] = 16,
+	[SKU_EHT484] = 16,
+	[SKU_EHT996] = 16,
+	[SKU_EHT2x996] = 16,
+	[SKU_EHT4x996] = 16,
+	[SKU_EHT26_52] = 16,
+	[SKU_EHT26_106] = 16,
+	[SKU_EHT484_242] = 16,
+	[SKU_EHT996_484] = 16,
+	[SKU_EHT996_484_242] = 16,
+	[SKU_EHT2x996_484] = 16,
+	[SKU_EHT3x996] = 16,
+	[SKU_EHT3x996_484] = 16,
+};
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/eeprom.h b/drivers/net/wireless/mediatek/mt76/mt7996/eeprom.h
index 7a771ca2434c..0f10ef0b6949 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/eeprom.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/eeprom.h
@@ -14,6 +14,8 @@ enum mt7996_eeprom_field {
	MT_EE_MAC_ADDR =	0x004,
	MT_EE_MAC_ADDR2 =	0x00a,
	MT_EE_WIFI_CONF =	0x190,
+	MT_EE_DO_PRE_CAL =	0x1a5,
+	MT_EE_TESTMODE_EN =	0x1af,
	MT_EE_MAC_ADDR3 =	0x2c0,
	MT_EE_RATE_DELTA_2G =	0x1400,
	MT_EE_RATE_DELTA_5G =	0x147d,
@@ -23,12 +25,108 @@ enum mt7996_eeprom_field {
	MT_EE_TX0_POWER_6G =	0x1310,

	__MT_EE_MAX =	0x1dff,
+	/* 0x1e10 ~ 0x2d644 used to save group cal data */
+	MT_EE_PRECAL =		0x1e10,
 };

 #define MT_EE_WIFI_CONF0_TX_PATH		GENMASK(2, 0)
 #define MT_EE_WIFI_CONF0_BAND_SEL		GENMASK(2, 0)
 #define MT_EE_WIFI_CONF1_BAND_SEL		GENMASK(5, 3)
 #define MT_EE_WIFI_CONF2_BAND_SEL		GENMASK(2, 0)
+#define MT_EE_WIFI_PA_LNA_CONFIG		GENMASK(1, 0)
+
+#define MT_EE_WIFI_CAL_GROUP_2G			BIT(0)
+#define MT_EE_WIFI_CAL_GROUP_5G			BIT(1)
+#define MT_EE_WIFI_CAL_GROUP_6G			BIT(2)
+#define MT_EE_WIFI_CAL_GROUP			GENMASK(2, 0)
+#define MT_EE_WIFI_CAL_DPD_2G			BIT(3)
+#define MT_EE_WIFI_CAL_DPD_5G			BIT(4)
+#define MT_EE_WIFI_CAL_DPD_6G			BIT(5)
+#define MT_EE_WIFI_CAL_DPD			GENMASK(5, 3)
+
+#define MT_EE_CAL_UNIT				1024
+
+enum mt7996_prek_rev {
+	GROUP_SIZE_2G,
+	GROUP_SIZE_5G,
+	GROUP_SIZE_6G,
+	ADCDCOC_SIZE_2G,
+	ADCDCOC_SIZE_5G,
+	ADCDCOC_SIZE_6G,
+	DPD_LEGACY_SIZE,
+	DPD_MEM_SIZE,
+	DPD_OTFG0_SIZE,
+};
+
+static const u32 mt7996_prek_rev[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			45 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			125 * MT_EE_CAL_UNIT,
+	[ADCDCOC_SIZE_2G] =			4 * 4,
+	[ADCDCOC_SIZE_5G] =			4 * 4,
+	[ADCDCOC_SIZE_6G] =			4 * 5,
+	[DPD_LEGACY_SIZE] =			4 * MT_EE_CAL_UNIT,
+	[DPD_MEM_SIZE] =			13 * MT_EE_CAL_UNIT,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
+static const u32 mt7996_prek_rev_233[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			44 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			125 * MT_EE_CAL_UNIT,
+	[ADCDCOC_SIZE_2G] =			4 * 4,
+	[ADCDCOC_SIZE_5G] =			4 * 4,
+	[ADCDCOC_SIZE_6G] =			4 * 5,
+	[DPD_LEGACY_SIZE] =			4 * MT_EE_CAL_UNIT,
+	[DPD_MEM_SIZE] =			13 * MT_EE_CAL_UNIT,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
+/* kite 2/5g config */
+static const u32 mt7992_prek_rev[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			110 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			0,
+	[ADCDCOC_SIZE_2G] =			4 * 4,
+	[ADCDCOC_SIZE_5G] =			4 * 5,
+	[ADCDCOC_SIZE_6G] =			0,
+	[DPD_LEGACY_SIZE] =			5 * MT_EE_CAL_UNIT,
+	[DPD_MEM_SIZE] =			16 * MT_EE_CAL_UNIT,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
+extern const struct ieee80211_channel dpd_2g_ch_list_bw20[];
+extern const struct ieee80211_channel dpd_5g_skip_ch_list[];
+extern const struct ieee80211_channel dpd_5g_ch_list_bw80[];
+extern const struct ieee80211_channel dpd_5g_ch_list_bw160[];
+extern const struct ieee80211_channel dpd_6g_ch_list_bw80[];
+extern const struct ieee80211_channel dpd_6g_ch_list_bw160[];
+extern const struct ieee80211_channel dpd_6g_ch_list_bw320[];
+
+#define PREK(id)				(dev->prek.rev[(id)])
+#define DPD_CH_NUM(_type)			(dev->prek.dpd_ch_num[DPD_CH_NUM_##_type])
+#define MT_EE_CAL_GROUP_SIZE			(PREK(GROUP_SIZE_2G) + PREK(GROUP_SIZE_5G) + \
+						 PREK(GROUP_SIZE_6G) + PREK(ADCDCOC_SIZE_2G) + \
+						 PREK(ADCDCOC_SIZE_5G) + PREK(ADCDCOC_SIZE_6G))
+#define DPD_PER_CH_BW20_SIZE			(PREK(DPD_LEGACY_SIZE) + PREK(DPD_OTFG0_SIZE))
+#define DPD_PER_CH_GT_BW20_SIZE			(PREK(DPD_MEM_SIZE) + PREK(DPD_OTFG0_SIZE))
+#define MT_EE_CAL_DPD_SIZE_2G			(DPD_CH_NUM(BW20_2G) * DPD_PER_CH_BW20_SIZE)
+#define MT_EE_CAL_DPD_SIZE_5G			(DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE + \
+						 DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE + \
+						 DPD_CH_NUM(BW160_5G) * DPD_PER_CH_GT_BW20_SIZE)
+#define MT_EE_CAL_DPD_SIZE_6G			(DPD_CH_NUM(BW20_6G) * DPD_PER_CH_BW20_SIZE + \
+						 DPD_CH_NUM(BW80_6G) * DPD_PER_CH_GT_BW20_SIZE + \
+						 DPD_CH_NUM(BW160_6G) * DPD_PER_CH_GT_BW20_SIZE + \
+						 DPD_CH_NUM(BW320_6G) * DPD_PER_CH_GT_BW20_SIZE)
+#define MT_EE_CAL_DPD_SIZE			(MT_EE_CAL_DPD_SIZE_2G + MT_EE_CAL_DPD_SIZE_5G + \
+						 MT_EE_CAL_DPD_SIZE_6G)
+
+#define RF_DPD_FLAT_CAL				BIT(28)
+#define RF_PRE_CAL				BIT(29)
+#define RF_DPD_FLAT_5G_CAL			GENMASK(29, 28)
+#define RF_DPD_FLAT_5G_MEM_CAL			(BIT(30) | BIT(28))
+#define RF_DPD_FLAT_6G_CAL			GENMASK(30, 28)
+#define RF_DPD_FLAT_6G_MEM_CAL			(BIT(31) | BIT(28))

 #define MT_EE_WIFI_CONF1_TX_PATH_BAND0		GENMASK(5, 3)
 #define MT_EE_WIFI_CONF2_TX_PATH_BAND1		GENMASK(2, 0)
@@ -53,6 +151,13 @@ enum mt7996_eeprom_band {
	MT_EE_BAND_SEL_6GHZ,
 };

+enum mt7915_eeprom_mode {
+	DEFAULT_BIN_MODE,
+	EFUSE_MODE,
+	FLASH_MODE,
+	BIN_FILE_MODE,
+};
+
 static inline int
 mt7996_get_channel_group_5g(int channel)
 {
@@ -76,4 +181,46 @@ mt7996_get_channel_group_6g(int channel)
	return DIV_ROUND_UP(channel - 29, 32);
 }

+enum mt7996_sku_rate_group {
+	SKU_CCK,
+	SKU_OFDM,
+
+	SKU_HT20,
+	SKU_HT40,
+
+	SKU_VHT20,
+	SKU_VHT40,
+	SKU_VHT80,
+	SKU_VHT160,
+
+	SKU_HE26,
+	SKU_HE52,
+	SKU_HE106,
+	SKU_HE242,
+	SKU_HE484,
+	SKU_HE996,
+	SKU_HE2x996,
+
+	SKU_EHT26,
+	SKU_EHT52,
+	SKU_EHT106,
+	SKU_EHT242,
+	SKU_EHT484,
+	SKU_EHT996,
+	SKU_EHT2x996,
+	SKU_EHT4x996,
+	SKU_EHT26_52,
+	SKU_EHT26_106,
+	SKU_EHT484_242,
+	SKU_EHT996_484,
+	SKU_EHT996_484_242,
+	SKU_EHT2x996_484,
+	SKU_EHT3x996,
+	SKU_EHT3x996_484,
+
+	MAX_SKU_RATE_GROUP_NUM,
+};
+
+extern const u8 mt7996_sku_group_len[MAX_SKU_RATE_GROUP_NUM];
+
 #endif
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/init.c b/drivers/net/wireless/mediatek/mt76/mt7996/init.c
index 62c882cdf20c..31b083b436a3 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/init.c
@@ -321,7 +371,12 @@ static void __mt7996_init_txpower(struct mt7996_phy *phy,
	int path_delta = mt76_tx_power_path_delta(path);
	int pwr_delta = mt7996_eeprom_get_power_delta(dev, sband->band);
	struct mt76_power_limits limits;
+	struct mt76_power_path_limits limits_path;
+	struct device_node *np;

+	phy->sku_limit_en = true;
+	phy->sku_path_en = true;
+	np = mt76_find_power_limits_node(&dev->mt76);
	for (i = 0; i < sband->n_channels; i++) {
		struct ieee80211_channel *chan = &sband->channels[i];
		int target_power = mt7996_eeprom_get_target_power(dev, chan);
@@ -329,11 +384,18 @@ static void __mt7996_init_txpower(struct mt7996_phy *phy,
		target_power += pwr_delta;
		target_power = mt76_get_rate_power_limits(phy->mt76, chan,
							  &limits,
+							  &limits_path,
							  target_power);
+		if (!limits_path.ofdm[0])
+			phy->sku_path_en = false;
+
		target_power += path_delta;
		target_power = DIV_ROUND_UP(target_power, 2);
-		chan->max_power = min_t(int, chan->max_reg_power,
-					target_power);
+		if (!np)
+			chan->max_power = min_t(int, chan->max_reg_power,
+						target_power);
+		else
+			chan->max_power = target_power;
		phy->txpower = max(phy->txpower, chan->max_power);
		chan->orig_mpwr = target_power;
	}
@@ -341,15 +403,22 @@ static void __mt7996_init_txpower(struct mt7996_phy *phy,

 void mt7996_init_txpower(struct mt7996_phy *phy)
 {
+	struct mt7996_phy *phy_2g, *phy_5g, *phy_6g;
+
	if (!phy)
		return;

-	if (phy->mt76->cap.has_2ghz)
-		__mt7996_init_txpower(phy, &phy->mt76->sband_2g.sband);
-	if (phy->mt76->cap.has_5ghz)
-		__mt7996_init_txpower(phy, &phy->mt76->sband_5g.sband);
-	if (phy->mt76->cap.has_6ghz)
-		__mt7996_init_txpower(phy, &phy->mt76->sband_6g.sband);
+	/* FIXME refactor after single wiphy multiple radios merged */
+	phy_2g = mt7996_band_phy(phy->dev, NL80211_BAND_2GHZ);
+	phy_5g = mt7996_band_phy(phy->dev, NL80211_BAND_5GHZ);
+	phy_6g = mt7996_band_phy(phy->dev, NL80211_BAND_6GHZ);
+
+	if (phy_2g && phy_2g->mt76->cap.has_2ghz)
+		__mt7996_init_txpower(phy_2g, &phy_2g->mt76->sband_2g.sband);
+	if (phy_5g && phy_5g->mt76->cap.has_5ghz)
+		__mt7996_init_txpower(phy_5g, &phy_5g->mt76->sband_5g.sband);
+	if (phy_6g && phy_6g->mt76->cap.has_6ghz)
+		__mt7996_init_txpower(phy_6g, &phy_6g->mt76->sband_6g.sband);
 }

 static void
@@ -479,4 +549,5 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER);
	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_PUNCT);
+	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_STAS_COUNT);

	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION);
@@ -563,7 +646,7 @@ static void mt7996_mac_init_basic_rates(struct mt7996_dev *dev)
 void mt7996_mac_init(struct mt7996_dev *dev)
 {
 #define HIF_TXD_V2_1	0x21
-	int i;
+	int i, rx_path_type, rro_bypass, txfree_path;

	mt76_clear(dev, MT_MDP_DCR2, MT_MDP_DCR2_RX_TRANS_SHORT);

@@ -577,22 +660,52 @@ void mt7996_mac_init(struct mt7996_dev *dev)
	}

	/* rro module init */
-	if (is_mt7996(&dev->mt76))
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_PLATFORM_TYPE, 2);
-	else
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_PLATFORM_TYPE,
-				   dev->hif2 ? 7 : 0);
+	rx_path_type = is_mt7996(&dev->mt76) ? 2 : 7;
+	rro_bypass = is_mt7996(&dev->mt76) ? 1 : 2;
+	txfree_path = is_mt7996(&dev->mt76) ? 0: 1;
+
+	switch (dev->option_type) {
+	case 2:
+		if (is_mt7996(&dev->mt76)) {
+			/* eagle + 7988d */
+			rx_path_type = 3;
+			rro_bypass = 1;
+			txfree_path = 0;
+		}
+		break;
+	case 3:
+		/* Airoha */
+		if (is_mt7996(&dev->mt76)) {
+			rx_path_type = 6;
+			rro_bypass = 1;
+			txfree_path = 0;
+		} else {
+			rx_path_type = 8;
+			rro_bypass = 2;
+			txfree_path = 1;
+		}
+		break;
+	case 4:
+		if (is_mt7996(&dev->mt76)) {
+			/* Bollinger */
+			rx_path_type = 2;
+			rro_bypass = 1;
+			txfree_path = 0;
+		}
+		break;
+	default:
+		break;
+	}
+
+	mt7996_mcu_set_rro(dev, UNI_RRO_SET_PLATFORM_TYPE, dev->hif2 ? rx_path_type : 0);
+	mt7996_mcu_set_rro(dev, UNI_RRO_SET_BYPASS_MODE, dev->has_rro ? rro_bypass : 3);
+	mt7996_mcu_set_rro(dev, UNI_RRO_SET_TXFREE_PATH, dev->has_rro ? txfree_path : 1);

	if (dev->has_rro) {
		u16 timeout;

		timeout = mt76_rr(dev, MT_HW_REV) == MT_HW_REV1 ? 512 : 128;
		mt7996_mcu_set_rro(dev, UNI_RRO_SET_FLUSH_TIMEOUT, timeout);
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_BYPASS_MODE, 1);
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_TXFREE_PATH, 0);
-	} else {
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_BYPASS_MODE, 3);
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_TXFREE_PATH, 1);
	}

	mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),
@@ -636,9 +780,23 @@ static int mt7996_register_phy(struct mt7996_dev *dev, enum mt76_band_id band)
	if (!mt7996_band_valid(dev, band))
		return 0;

-	if (is_mt7996(&dev->mt76) && band == MT_BAND2 && dev->hif2) {
-		hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
-		wed = &dev->mt76.mmio.wed_hif2;
+	if (dev->hif2) {
+		switch (dev->option_type) {
+		case 2:
+			/* eagle + 7988d */
+			if (band == MT_BAND1) {
+				hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
+				wed = &dev->mt76.mmio.wed_hif2;
+			}
+			break;
+		default:
+			if ((is_mt7996(&dev->mt76) && band == MT_BAND2) ||
+			    (is_mt7992(&dev->mt76) && band == MT_BAND1)) {
+				hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
+				wed = &dev->mt76.mmio.wed_hif2;
+			}
+			break;
+		}
	}

	mphy = mt76_alloc_radio_phy(&dev->mt76, sizeof(*phy), band);
@@ -681,15 +839,18 @@ static int mt7996_register_phy(struct mt7996_dev *dev, enum mt76_band_id band)
	if (ret)
		goto error;

+#ifdef CONFIG_MTK_VENDOR
+	mt7996_vendor_register(phy);
+#endif
+
	ret = mt76_register_phy(mphy, true, mt76_rates,
				ARRAY_SIZE(mt76_rates));
	if (ret)
		goto error;

-	if (wed == &dev->mt76.mmio.wed_hif2 && mtk_wed_device_active(wed)) {
-		u32 irq_mask = dev->mt76.mmio.irqmask | MT_INT_TX_DONE_BAND2;
-		mt76_wr(dev, MT_INT1_MASK_CSR, irq_mask);
-		mtk_wed_device_start(&dev->mt76.mmio.wed_hif2, irq_mask);
+	if (wed == &dev->mt76.mmio.wed_hif2 && mtk_wed_device_active(wed)) {
+		mt76_wr(dev, MT_INT_PCIE1_MASK_CSR, MT_INT_TX_RX_DONE_EXT);
+		mtk_wed_device_start(&dev->mt76.mmio.wed_hif2, MT_INT_TX_RX_DONE_EXT);
	}

	return 0;
@@ -700,11 +866,35 @@ static int mt7996_register_phy(struct mt7996_dev *dev, enum mt76_band_id band)
	return ret;
 }

+#ifdef CONFIG_MTK_VENDOR
+static int mt7996_unregister_csi(struct mt7996_phy *phy)
+{
+	struct csi_data *c, *tmp_c;
+
+	spin_lock_bh(&phy->csi.lock);
+	phy->csi.enable = 0;
+
+	list_for_each_entry_safe(c, tmp_c, &phy->csi.list, node) {
+		list_del(&c->node);
+		kfree(c);
+	}
+	spin_unlock_bh(&phy->csi.lock);
+
+	return 0;
+}
+#endif
+
 static void
 mt7996_unregister_phy(struct mt7996_phy *phy)
 {
-	if (phy)
-		mt7996_unregister_thermal(phy);
+	if (!phy)
+		return;
+
+#ifdef CONFIG_MTK_VENDOR
+	mt7996_unregister_csi(phy);
+#endif
+
+	mt7996_unregister_thermal(phy);
 }

 static void mt7996_init_work(struct work_struct *work)
@@ -715,6 +905,7 @@ static void mt7996_init_work(struct work_struct *work)
	mt7996_mcu_set_eeprom(dev);
	mt7996_mac_init(dev);
	mt7996_txbf_init(dev);
+	mt7996_mcu_set_dup_wtbl(dev);
 }

 void mt7996_wfsys_reset(struct mt7996_dev *dev)
@@ -726,11 +917,96 @@ void mt7996_wfsys_reset(struct mt7996_dev *dev)
	msleep(20);
 }

-static int mt7996_wed_rro_init(struct mt7996_dev *dev)
+void mt7996_rro_hw_init(struct mt7996_dev *dev)
 {
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
	u32 reg = MT_RRO_ADDR_ELEM_SEG_ADDR0;
+	int i;
+
+	if (!dev->has_rro)
+		return;
+
+	if (is_mt7992(&dev->mt76)) {
+		/* set emul 3.0 function */
+		mt76_wr(dev, MT_RRO_3_0_EMU_CONF,
+			MT_RRO_3_0_EMU_CONF_EN_MASK);
+
+		mt76_wr(dev, MT_RRO_ADDR_ARRAY_BASE0,
+			dev->wed_rro.addr_elem[0].phy_addr);
+	} else {
+		INIT_LIST_HEAD(&dev->wed_rro.pg_addr_cache);
+		for (i = 0; i < MT7996_RRO_MSDU_PG_HASH_SIZE; i++)
+			INIT_LIST_HEAD(&dev->wed_rro.pg_hash_head[i]);
+
+		/* TODO: remove line after WM has set */
+		mt76_clear(dev, WF_RRO_AXI_MST_CFG, WF_RRO_AXI_MST_CFG_DIDX_OK);
+
+		/* setup BA bitmap cache address */
+		mt76_wr(dev, MT_RRO_BA_BITMAP_BASE0,
+			dev->wed_rro.ba_bitmap[0].phy_addr);
+		mt76_wr(dev, MT_RRO_BA_BITMAP_BASE1, 0);
+		mt76_wr(dev, MT_RRO_BA_BITMAP_BASE_EXT0,
+			dev->wed_rro.ba_bitmap[1].phy_addr);
+		mt76_wr(dev, MT_RRO_BA_BITMAP_BASE_EXT1, 0);
+
+		/* setup Address element address */
+		for (i = 0; i < ARRAY_SIZE(dev->wed_rro.addr_elem); i++) {
+			mt76_wr(dev, reg, dev->wed_rro.addr_elem[i].phy_addr >> 4);
+			reg += 4;
+		}
+
+		/* setup Address element address - separate address segment mode */
+		mt76_wr(dev, MT_RRO_ADDR_ARRAY_BASE1,
+			MT_RRO_ADDR_ARRAY_ELEM_ADDR_SEG_MODE);
+	}
+	wed->wlan.ind_cmd.win_size = ffs(MT7996_RRO_WINDOW_MAX_LEN) - 6;
+	if (is_mt7996(&dev->mt76))
+		wed->wlan.ind_cmd.particular_sid = MT7996_RRO_MAX_SESSION;
+	else
+		wed->wlan.ind_cmd.particular_sid = 1;
+	wed->wlan.ind_cmd.particular_se_phys = dev->wed_rro.session.phy_addr;
+	wed->wlan.ind_cmd.se_group_nums = MT7996_RRO_ADDR_ELEM_LEN;
+	wed->wlan.ind_cmd.ack_sn_addr = MT_RRO_ACK_SN_CTRL;
+
+	mt76_wr(dev, MT_RRO_IND_CMD_SIGNATURE_BASE0, 0x15010e00);
+	mt76_set(dev, MT_RRO_IND_CMD_SIGNATURE_BASE1,
+		 MT_RRO_IND_CMD_SIGNATURE_BASE1_EN);
+
+	/* particular session configure */
+	/* use max session idx + 1 as particular session id */
+	mt76_wr(dev, MT_RRO_PARTICULAR_CFG0, dev->wed_rro.session.phy_addr);
+
+	if (is_mt7992(&dev->mt76)) {
+		reg = MT_RRO_MSDU_PG_SEG_ADDR0;
+
+		mt76_set(dev, MT_RRO_3_1_GLOBAL_CONFIG,
+			 MT_RRO_3_1_GLOBAL_CONFIG_INTERLEAVE_EN);
+
+		/* setup Msdu page address */
+		for (i = 0; i < MT7996_RRO_MSDU_PG_CR_CNT; i++) {
+			mt76_wr(dev, reg, dev->wed_rro.msdu_pg[i].phy_addr >> 4);
+			reg += 4;
+		}
+		mt76_wr(dev, MT_RRO_PARTICULAR_CFG1,
+			MT_RRO_PARTICULAR_CONFG_EN |
+			FIELD_PREP(MT_RRO_PARTICULAR_SID, 1));
+	} else {
+		mt76_wr(dev, MT_RRO_PARTICULAR_CFG1,
+			MT_RRO_PARTICULAR_CONFG_EN |
+			FIELD_PREP(MT_RRO_PARTICULAR_SID, MT7996_RRO_MAX_SESSION));
+	}
+	/* interrupt enable */
+	mt76_wr(dev, MT_RRO_HOST_INT_ENA,
+		MT_RRO_HOST_INT_ENA_HOST_RRO_DONE_ENA);
+
+#endif
+}
+
+static int mt7996_wed_rro_init(struct mt7996_dev *dev)
+{
+#ifdef CONFIG_NET_MEDIATEK_SOC_WED
+	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
	struct mt7996_wed_rro_addr *addr;
	void *ptr;
	int i;
@@ -776,6 +1052,17 @@ static int mt7996_wed_rro_init(struct mt7996_dev *dev)
			dev->wed_rro.addr_elem[i].phy_addr;
	}

+	for (i = 0; i < MT7996_RRO_MSDU_PG_CR_CNT; i++) {
+		ptr = dmam_alloc_coherent(dev->mt76.dma_dev, MT7996_RRO_MSDU_PG_SIZE_PER_CR,
+					  &dev->wed_rro.msdu_pg[i].phy_addr,
+					  GFP_KERNEL);
+		if (!ptr)
+			return -ENOMEM;
+		dev->wed_rro.msdu_pg[i].ptr = ptr;
+
+		memset(dev->wed_rro.msdu_pg[i].ptr, 0, MT7996_RRO_MSDU_PG_SIZE_PER_CR);
+	}
+
	ptr = dmam_alloc_coherent(dev->mt76.dma_dev,
				  MT7996_RRO_WINDOW_MAX_LEN * sizeof(*addr),
				  &dev->wed_rro.session.phy_addr,
@@ -790,50 +1077,9 @@ static int mt7996_wed_rro_init(struct mt7996_dev *dev)
		addr++;
	}

-	/* rro hw init */
-	/* TODO: remove line after WM has set */
-	mt76_clear(dev, WF_RRO_AXI_MST_CFG, WF_RRO_AXI_MST_CFG_DIDX_OK);
-
-	/* setup BA bitmap cache address */
-	mt76_wr(dev, MT_RRO_BA_BITMAP_BASE0,
-		dev->wed_rro.ba_bitmap[0].phy_addr);
-	mt76_wr(dev, MT_RRO_BA_BITMAP_BASE1, 0);
-	mt76_wr(dev, MT_RRO_BA_BITMAP_BASE_EXT0,
-		dev->wed_rro.ba_bitmap[1].phy_addr);
-	mt76_wr(dev, MT_RRO_BA_BITMAP_BASE_EXT1, 0);
-
-	/* setup Address element address */
-	for (i = 0; i < ARRAY_SIZE(dev->wed_rro.addr_elem); i++) {
-		mt76_wr(dev, reg, dev->wed_rro.addr_elem[i].phy_addr >> 4);
-		reg += 4;
-	}
-
-	/* setup Address element address - separate address segment mode */
-	mt76_wr(dev, MT_RRO_ADDR_ARRAY_BASE1,
-		MT_RRO_ADDR_ARRAY_ELEM_ADDR_SEG_MODE);
-
-	wed->wlan.ind_cmd.win_size = ffs(MT7996_RRO_WINDOW_MAX_LEN) - 6;
-	wed->wlan.ind_cmd.particular_sid = MT7996_RRO_MAX_SESSION;
-	wed->wlan.ind_cmd.particular_se_phys = dev->wed_rro.session.phy_addr;
-	wed->wlan.ind_cmd.se_group_nums = MT7996_RRO_ADDR_ELEM_LEN;
-	wed->wlan.ind_cmd.ack_sn_addr = MT_RRO_ACK_SN_CTRL;
-
-	mt76_wr(dev, MT_RRO_IND_CMD_SIGNATURE_BASE0, 0x15010e00);
-	mt76_set(dev, MT_RRO_IND_CMD_SIGNATURE_BASE1,
-		 MT_RRO_IND_CMD_SIGNATURE_BASE1_EN);
-
-	/* particular session configure */
-	/* use max session idx + 1 as particular session id */
-	mt76_wr(dev, MT_RRO_PARTICULAR_CFG0, dev->wed_rro.session.phy_addr);
-	mt76_wr(dev, MT_RRO_PARTICULAR_CFG1,
-		MT_RRO_PARTICULAR_CONFG_EN |
-		FIELD_PREP(MT_RRO_PARTICULAR_SID, MT7996_RRO_MAX_SESSION));
-
-	/* interrupt enable */
-	mt76_wr(dev, MT_RRO_HOST_INT_ENA,
-		MT_RRO_HOST_INT_ENA_HOST_RRO_DONE_ENA);
-
	/* rro ind cmd queue init */
+	mt7996_rro_hw_init(dev);
+
	return mt7996_dma_rro_init(dev);
 #else
	return 0;
@@ -872,6 +1118,16 @@ static void mt7996_wed_rro_free(struct mt7996_dev *dev)
				   dev->wed_rro.addr_elem[i].phy_addr);
	}

+	for (i = 0; i < ARRAY_SIZE(dev->wed_rro.msdu_pg); i++) {
+		if (!dev->wed_rro.msdu_pg[i].ptr)
+			continue;
+
+		dmam_free_coherent(dev->mt76.dma_dev,
+				   MT7996_RRO_MSDU_PG_SIZE_PER_CR,
+				   dev->wed_rro.msdu_pg[i].ptr,
+				   dev->wed_rro.msdu_pg[i].phy_addr);
+	}
+
	if (!dev->wed_rro.session.ptr)
		return;

@@ -949,7 +1205,7 @@ static int mt7996_variant_type_init(struct mt7996_dev *dev)
		else if (u32_get_bits(val, MT_PAD_GPIO_ADIE_COMB_7992))
			var_type = MT7992_VAR_TYPE_44;
		else
-			return -EINVAL;
+			var_type = MT7992_VAR_TYPE_24;
		break;
	case MT7990_DEVICE_ID:
		var_type = MT7990_VAR_TYPE_23;
@@ -1007,6 +1263,9 @@ static int mt7996_variant_fem_init(struct mt7996_dev *dev)
 static int mt7996_init_hardware(struct mt7996_dev *dev)
 {
	int ret, idx;
+	struct device_node *np = dev->mt76.dev->of_node;
+
+	of_property_read_u32(np, "option_type", &dev->option_type);

	mt76_wr(dev, MT_INT_SOURCE_CSR, ~0);
	if (is_mt7992(&dev->mt76)) {
@@ -1029,6 +1288,10 @@ static int mt7996_init_hardware(struct mt7996_dev *dev)

	set_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);

+	ret = mt7996_eeprom_check_fw_mode(dev);
+	if (ret < 0)
+		return ret;
+
	ret = mt7996_mcu_init(dev);
	if (ret)
		return ret;
@@ -1045,6 +1308,12 @@ static int mt7996_init_hardware(struct mt7996_dev *dev)
	if (ret < 0)
		return ret;

+	if (dev->cal) {
+		ret = mt7996_mcu_apply_group_cal(dev);
+		if (ret)
+			return ret;
+	}
+
	/* Beacon and mgmt frames should occupy wcid 0 */
	idx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7996_WTBL_STA);
	if (idx)
@@ -1499,6 +1769,14 @@ int mt7996_register_device(struct mt7996_dev *dev)

	mt7996_init_wiphy(hw, &dev->mt76.mmio.wed);

+#ifdef CONFIG_NL80211_TESTMODE
+	dev->mt76.test_ops = &mt7996_testmode_ops;
+#endif
+
+#ifdef CONFIG_MTK_VENDOR
+	mt7996_vendor_register(&dev->phy);
+#endif
+
	ret = mt7996_register_phy(dev, MT_BAND1);
	if (ret)
		return ret;
@@ -1518,16 +1798,21 @@ int mt7996_register_device(struct mt7996_dev *dev)
	if (ret)
		return ret;

	ret = mt7996_init_dev_debugfs(&dev->phy);
	if (ret)
		goto error;

	mt7996_for_each_phy(dev, phy) {
		mt7996_thermal_init(phy);
		ret = mt7996_init_band_debugfs(phy);
		if (ret)
			goto error;
	}

	ieee80211_queue_work(mt76_hw(dev), &dev->init_work);

	dev->recovery.hw_init_done = true;

	ret = mt7996_coredump_register(dev);
	if (ret)
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mac.c b/drivers/net/wireless/mediatek/mt76/mt7996/mac.c
index ec5646c4fc7f..2b216db373ef 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mac.c
@@ -10,8 +10,8 @@
 #include "../dma.h"
 #include "mac.h"
 #include "mcu.h"
-
-#define to_rssi(field, rcpi)	((FIELD_GET(field, rcpi) - 220) / 2)
+#include "vendor.h"
+#include "mt7996_trace.h"

 static const struct mt7996_dfs_radar_spec etsi_radar_specs = {
	.pulse_th = { 110, -10, -80, 40, 5200, 128, 5200 },
@@ -473,3 +367,3 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
	int idx;
	u8 hw_aggr = false;
	struct mt7996_sta *msta = NULL;
	struct mt7996_sta_link *msta_link = NULL;

+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_rx_raw)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_RX_RAW, 0);
+	mt7996_dump_bmac_rxd_info(dev, rxd);
+#endif
	hw_aggr = status->aggr;
	memset(status, 0, sizeof(*status));

@@ -482,6 +382,8 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
	phy = mphy->priv;
	status->phy_idx = mphy->band_idx;

+	trace_mt7996_fill_rx(phy, skb->data, skb->len);
+
	if (!test_bit(MT76_STATE_RUNNING, &mphy->state))
		return -EINVAL;

@@ -656,6 +556,10 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
		return -EINVAL;

	hdr_gap = (u8 *)rxd - skb->data + 2 * remove_pad;
+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_rx_pkt)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_RX, hdr_gap);
+#endif
	if (hdr_trans && ieee80211_has_morefrags(fc)) {
		if (mt7996_reverse_frag0_hdr_trans(skb, hdr_gap))
			return -EINVAL;
@@ -710,3 +614,3 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
			 */
			if (ieee80211_has_a4(fc) && is_mesh && status->amsdu)
				*qos &= ~IEEE80211_QOS_CTL_A_MSDU_PRESENT;
		} else if (ieee80211_is_beacon(fc)) {
			struct ieee80211_hw *hw = phy->mt76->hw;
			struct ieee80211_sta *sta;
			struct mt7996_sta *msta;
			unsigned int link_id = 0;

			sta = ieee80211_find_sta_by_link_addrs(hw, hdr->addr2, NULL, &link_id);
			if (!sta)
				sta = ieee80211_find_sta_by_ifaddr(hw, hdr->addr2, NULL);

			if (sta) {
				msta = (struct mt7996_sta *)sta->drv_priv;
				if (msta && msta->vif) {
					msta->vif->beacon_received_time[band_idx] = jiffies;
					/* FIXME: This is a temporary workaround.
					 * Lost links should be resumed via TTLM or
					 * link reconfig.
					 */
					if (msta->vif->lost_links & BIT(link_id)) {
						msta->vif->lost_links &= ~BIT(link_id);
						wiphy_info(hw->wiphy,
							   "link %d: resume beacon monitoring\n",
							   link_id);
					}
				}
			}
		}
		skb_set_mac_header(skb, (unsigned char *)hdr - skb->data);
+
+#ifdef CONFIG_MTK_VENDOR
+		if (phy->amnt_ctrl.enable && !ieee80211_is_beacon(fc))
+			mt7996_vendor_amnt_fill_rx(phy, skb);
+#endif
	} else {
		status->flag |= RX_FLAG_8023;
		mt7996_wed_check_ppe(dev, &dev->mt76.q_rx[q], msta_link ? msta_link->sta : NULL, skb,
				     *info);
@@ -731,6 +667,8 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
		}
	}

+	trace_mt7996_fill_rx_done(phy, status->seqno, hdr_gap);
+
	if (!status->wcid || !ieee80211_is_data_qos(fc) || hw_aggr)
		return 0;

@@ -785,6 +723,8 @@ mt7996_mac_write_txwi_80211(struct mt7996_dev *dev, __le32 *txwi,
			    struct ieee80211_key_conf *key,
			    struct mt76_wcid *wcid)
 {
+	struct mt76_phy *mphy =
+		mt76_dev_phy(&dev->mt76, le32_get_bits(txwi[1], MT_TXD1_TGID));
	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
@@ -795,6 +735,14 @@ mt7996_mac_write_txwi_80211(struct mt7996_dev *dev, __le32 *txwi,
	u8 fc_type, fc_stype;
	u32 val;

+	if (ieee80211_is_cert_mode(mphy->hw) && ieee80211_is_deauth(fc)) {
+		/* In WPA3 cert TC-4.8.1, the deauth must be transmitted without
+		 * considering PSM bit
+		 */
+		txwi[0] &= ~cpu_to_le32(MT_TXD0_Q_IDX);
+		txwi[0] |= cpu_to_le32(FIELD_PREP(MT_TXD0_Q_IDX, MT_LMAC_ALTX0));
+	}
+
	if (ieee80211_is_action(fc) &&
	    mgmt->u.action.category == WLAN_CATEGORY_BACK &&
	    mgmt->u.action.u.addba_req.action_code == WLAN_ACTION_ADDBA_REQ) {
@@ -1024,1 +974,1 @@ int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
	u8 *txwi = (u8 *)txwi_ptr;
	u8 link_id;

-	if (unlikely(tx_info->skb->len <= ETH_HLEN))
+	if (unlikely(tx_info->skb->len <= ETH_HLEN)) {
+		mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_INVALID_SKB]++;
		return -EINVAL;
+	}

-	if (!wcid)
-		wcid = &dev->mt76.global_wcid;
+	if (WARN_ON(!wcid)) {
+		mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_INVALID_WCID]++;
+		return -EINVAL;
+	}
+
	msta = sta ? (struct mt7996_sta *)sta->drv_priv : &mvif->sta;
	if ((is_8023 || ieee80211_is_data_qos(hdr->frame_control)) && sta && sta->mlo) {
		if (unlikely(tx_info->skb->protocol == cpu_to_be16(ETH_P_PAE))) {
			link_id = msta->deflink_id;
		} else {
			u8 tid = tx_info->skb->priority & IEEE80211_QOS_CTL_TID_MASK;

			link_id = (tid % 2) ? msta->sec_link : msta->deflink_id;
		}
	} else {
		link_id = u32_get_bits(info->control.flags, IEEE80211_TX_CTRL_MLO_LINK);

		if (link_id == IEEE80211_LINK_UNSPECIFIED || (sta && !sta->mlo))
			link_id = wcid->link_id;
	}

	if (link_id != wcid->link_id) {
		struct mt7996_sta_link *msta_link = rcu_dereference(msta->link[link_id]);

		if (msta_link)
			wcid = &msta_link->wcid;
	}

	mconf = (struct mt7996_vif_link *)rcu_dereference(mvif->mt76.link[wcid->link_id]);
	if (!mconf) {
+		mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_INVALID_LINK]++;
		return -ENOLINK;
	}

	t = (struct mt76_txwi_cache *)(txwi + mdev->drv->txwi_size);
	t->skb = tx_info->skb;

	id = mt76_token_consume(mdev, &t);
-	if (id < 0)
+	if (id < 0) {
+		mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_GET_TOKEN_FAIL]++;
		return id;
+	}
+#ifdef CONFIG_MTK_DEBUG
+	t->jiffies = jiffies;
+#endif

	pid = mt76_tx_status_skb_add(mdev, wcid, tx_info->skb);
	memset(txwi_ptr, 0, MT_TXD_SIZE);
@@ -1102,6 +1121,15 @@ int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
	tx_info->buf[1].skip_unmap = true;
	tx_info->nbuf = MT_CT_DMA_BUF_NUM;

+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_txd)
+		mt7996_packet_log_to_host(dev, txwi, MT_TXD_SIZE, PKT_BIN_DEBUG_TXD, 0);
+	if (dev->dbg.dump_tx_pkt)
+		mt7996_packet_log_to_host(dev, t->skb->data, t->skb->len, PKT_BIN_DEBUG_TX, 0);
+	mt7996_dump_bmac_txd_info(NULL, dev, (__le32 *)txwi, true, false);
+#endif
+	trace_mt7996_tx_prepare(dev, wcid, qid, txwi, t->skb->data, t->skb->len);
+
	return 0;
 }

@@ -1276,6 +1317,13 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)

			wcid->stats.tx_retries += tx_retries;
			wcid->stats.tx_failed += tx_failed;
+
+			if (FIELD_GET(MT_TXFREE_INFO_STAT, info) == 2) {
+				struct mt7996_phy *mphy =
+					__mt7996_phy(dev, wcid->phy_idx);
+
+				mphy->red_drop++;
+			}
			continue;
		}

@@ -1289,3 +1337,3 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)
			if (!txwi)
				continue;

			mt7996_txwi_free(dev, txwi, sta, wcid, &free_list);
+			txwi->jiffies = 0;
		}
	}

	if (wake)
		mt76_set_tx_blocked(&dev->mt76, false);

@@ -1528,9 +1592,11 @@ void mt7996_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,
			 struct sk_buff *skb, u32 *info)
 {
	struct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);
+	struct mt76_phy *phy;
	__le32 *rxd = (__le32 *)skb->data;
	__le32 *end = (__le32 *)&skb->data[skb->len];
	enum rx_pkt_type type;
+	u8 band_idx;

	type = le32_get_bits(rxd[0], MT_RXD0_PKT_TYPE);
	if (type != PKT_TYPE_NORMAL) {
@@ -1565,12 +1631,23 @@ void mt7996_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,
		dev_kfree_skb(skb);
		break;
	case PKT_TYPE_NORMAL:
+		band_idx = le32_get_bits(rxd[1], MT_RXD1_NORMAL_BAND_IDX);
+		phy = mt76_dev_phy(mdev, band_idx);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_from_hw++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
+
		if (!mt7996_mac_fill_rx(dev, q, skb, info)) {
			mt76_rx(&dev->mt76, q, skb);
			return;
		}
		fallthrough;
	default:
+		band_idx = le32_get_bits(rxd[1], MT_RXD1_NORMAL_BAND_IDX);
+		phy = mt76_dev_phy(mdev, band_idx);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_drop[MT_RX_DROP_RXD_ERR]++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
		dev_kfree_skb(skb);
		break;
	}
@@ -1841,6 +1928,31 @@ mt7996_mac_restart(struct mt7996_dev *dev)
	if (ret)
		goto out;

+	if (mtk_wed_device_active(&dev->mt76.mmio.wed) && dev->has_rro) {
+		u32 wed_irq_mask = dev->mt76.mmio.irqmask |
+				   MT_INT_RRO_RX_DONE |
+				   MT_INT_TX_DONE_BAND2;
+
+		mt7996_rro_hw_init(dev);
+		mt76_for_each_q_rx(&dev->mt76, i) {
+			if (mt76_queue_is_wed_rro_ind(&dev->mt76.q_rx[i]) ||
+			    mt76_queue_is_wed_rro_msdu_pg(&dev->mt76.q_rx[i]))
+				mt76_queue_rx_reset(dev, i);
+		}
+
+		mt76_wr(dev, MT_INT_MASK_CSR, wed_irq_mask);
+		mtk_wed_device_start_hw_rro(&dev->mt76.mmio.wed, wed_irq_mask, false);
+		mt7996_irq_enable(dev, wed_irq_mask);
+		mt7996_irq_disable(dev, 0);
+	}
+
+	if (mtk_wed_device_active(&dev->mt76.mmio.wed_hif2)) {
+		mt76_wr(dev, MT_INT_PCIE1_MASK_CSR,
+			MT_INT_TX_RX_DONE_EXT);
+		mtk_wed_device_start(&dev->mt76.mmio.wed_hif2,
+				     MT_INT_TX_RX_DONE_EXT);
+	}
+
	/* set the necessary init items */
	ret = mt7996_mcu_set_eeprom(dev);
	if (ret)
@@ -2038,8 +2179,13 @@ void mt7996_mac_reset_work(struct work_struct *work)

		mt76_wr(dev, MT_INT_MASK_CSR, wed_irq_mask);

+		if (is_mt7992(&dev->mt76) && dev->has_rro)
+			mt76_wr(dev, MT_RRO_3_0_EMU_CONF,
+				MT_RRO_3_0_EMU_CONF_EN_MASK);
+
		mtk_wed_device_start_hw_rro(&dev->mt76.mmio.wed, wed_irq_mask,
					    true);
+
		mt7996_irq_enable(dev, wed_irq_mask);
		mt7996_irq_disable(dev, 0);
	}
@@ -2207,10 +2388,19 @@ void mt7996_mac_update_stats(struct mt7996_phy *phy)
 {
	struct mt76_mib_stats *mib = &phy->mib;
	struct mt7996_dev *dev = phy->dev;
+	struct mt76_mib_stats *main_mib = &dev->phy.mib;
	u8 band_idx = phy->mt76->band_idx;
	u32 cnt;
	int i;

+	/* Update per-dev structures */
+	for (i = 0; i < ARRAY_SIZE(main_mib->tx_amsdu); i++) {
+		cnt = mt76_rr(dev, MT_PLE_AMSDU_PACK_MSDU_CNT(i));
+		main_mib->tx_amsdu[i] += cnt;
+		main_mib->tx_amsdu_cnt += cnt;
+	}
+
+	/* Update per-phy structures */
	cnt = mt76_rr(dev, MT_MIB_RSCR1(band_idx));
	mib->fcs_err_cnt += cnt;

@@ -2316,12 +2506,6 @@ void mt7996_mac_update_stats(struct mt7996_phy *phy)
	cnt = mt76_rr(dev, MT_MIB_BSCR17(band_idx));
	mib->tx_bf_fb_cpl_cnt += cnt;

-	for (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++) {
-		cnt = mt76_rr(dev, MT_PLE_AMSDU_PACK_MSDU_CNT(i));
-		mib->tx_amsdu[i] += cnt;
-		mib->tx_amsdu_cnt += cnt;
-	}
-
	/* rts count */
	cnt = mt76_rr(dev, MT_MIB_BTSCR5(band_idx));
	mib->rts_cnt += cnt;
@@ -2706,6 +2921,7 @@ void mt7996_mac_add_twt_setup(struct ieee80211_hw *hw,
		goto out;

	mutex_lock(&dev->mt76.mutex);
+	msta_link = mt76_dereference(msta->link[0], &dev->mt76);

	if (dev->twt.n_agrt == MT7996_MAX_TWT_AGRT)
		goto unlock;
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/main.c b/drivers/net/wireless/mediatek/mt76/mt7996/main.c
index 8ab06d5e9cb6..537406d4a0f5 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/main.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/main.c
@@ -6,6 +6,25 @@
 #include "mt7996.h"
 #include "mcu.h"
 #include "mac.h"
+#ifdef CONFIG_MTK_DEBUG
+#include "mtk_mcu.h"
+#endif
+
+unsigned int mt7996_debug_mask = 0x1f;
+module_param(mt7996_debug_mask, uint, 0644);
+MODULE_PARM_DESC(mt7996_debug_mask, "Debugging mask");
+
+static void mt7996_testmode_disable_all(struct mt7996_dev *dev)
+{
+	struct mt7996_phy *phy;
+	int i;
+
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		phy = __mt7996_phy(dev, i);
+		if (phy)
+			mt76_testmode_set_state(phy->mt76, MT76_TM_STATE_OFF);
+	}
+}

 int mt7996_run(struct mt7996_phy *phy)
 {
@@ -34,3 +58,3 @@ int mt7996_run(struct mt7996_phy *phy)
	if (ret)
		return ret;

	ret = mt7996_mcu_set_scs(phy, SCS_ENABLE);
	if (ret)
		return ret;

+#ifdef CONFIG_MTK_DEBUG
	phy->sr_enable = true;
	phy->enhanced_sr_enable = true;
	phy->thermal_protection_enable = true;
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
+					   dev->dbg.sku_disable ? 0 : phy->sku_limit_en);
+
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
+					   dev->dbg.sku_disable ? 0 : phy->sku_path_en);
+#else
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
+					   phy->sku_limit_en);
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
+					   phy->sku_path_en);
+#endif
+	if (ret)
+		return ret;
+
	set_bit(MT76_STATE_RUNNING, &phy->mt76->state);

	ieee80211_queue_delayed_work(dev->mphy.hw, &phy->mt76->mac_work,
@@ -60,10 +106,13 @@ static int mt7996_start(struct ieee80211_hw *hw)
		u8 queue = mt76_connac_lmac_mapping(IEEE80211_AC_VI);

		ret = mt7996_mcu_cp_support(dev, queue);
 #ifdef CONFIG_MTK_DEBUG
		dev->sr_pp_enable = true;
		dev->uba_enable = true;
 #endif
	}
+
+	mt7996_testmode_disable_all(dev);
+
	mutex_unlock(&dev->mt76.mutex);

	ieee80211_queue_delayed_work(hw, &dev->scs_work, HZ);
static inline int get_free_idx(u64 mask, u8 start, u8 end)
{
@@ -86,0 +141,0 @@ static void mt7996_vif_link_add(struct mt7996_phy *phy)
	if (idx < 0) {
		ret = -ENOSPC;
		goto error;
	}
+	if (!dev->testmode_enable) {
+		mlink->idx = __ffs64(~dev->mt76.vif_mask);
+		if (mlink->idx >= mt7996_max_interface_num(dev)) {
+			ret = -ENOSPC;
+			goto error;
+		}
+
+		idx = get_omac_idx(vif->type, phy->omac_mask);
+		if (idx < 0) {
+			ret = -ENOSPC;
+			goto error;
+		}
+	} else {
		/* bss idx & omac idx should be set to band idx for ibf cal */
		if (dev->mt76.vif_mask & BIT_ULL(band_idx) ||
@@ -352,3 +394,3 @@ void mt7996_vif_link_remove(struct mt76_phy *mphy, struct ieee80211_vif *vif,
	struct mt7996_vif_link *link = container_of(mlink, struct mt7996_vif_link, mt76);
	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
	struct mt7996_sta_link *msta_link = &link->msta_link;
	struct mt7996_phy *phy = link->phy;
	struct mt7996_dev *dev;
	int idx = msta_link->wcid.idx;
	int link_id = msta_link->wcid.link_id;

	if (!phy || !mlink->wcid)
		goto out;

	dev = phy->dev;

+	mt76_dbg(&dev->mt76, MT76_DBG_BSS,
+		 "%s: band=%u, bss_idx=%u, link_id=%u, wcid=%u\n",
+		 __func__, phy->mt76->band_idx, mlink->idx, link_id, idx);

	cancel_delayed_work(&link->sta_chsw_work);

	mt7996_mcu_add_sta(dev, link_conf, NULL, link, NULL,
			   CONN_STATE_DISCONNECT, false);
@@ -439,10 +494,24 @@ static int mt7996_add_interface(struct ieee80211_hw *hw,
	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
	int i, err = 0;

	mutex_lock(&dev->mt76.mutex);
+	if (dev->testmode_enable && vif->type != NL80211_IFTYPE_MONITOR) {
+		mutex_unlock(&dev->mt76.mutex);
+		dev_err(dev->mt76.dev, "Only monitor interface is allowed in testmode\n");
+		return -EINVAL;
+	}

	for (i = 0; i < MT7996_MAX_RADIOS; i++) {
-		struct mt7996_phy *phy = dev->radio_phy[i];
+		/* FIXME: only set the required radio temporarily for testmode.
+		 * The TX speed of testmode will be affected if the unused radio is enabled.
+		 * Normal mode should also skip enabling the unused radio once the
+		 * real single wiphy codebase is stable.
+		 */
+		if (dev->testmode_enable && !(wdev->radio_mask & BIT(i)))
+			continue;
+
+		phy = dev->radio_phy[i];

		if (phy && !mvif->deflink.phy && (wdev->radio_mask & BIT(i)))
			mvif->deflink.phy = phy;

		if (!phy || test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
			continue;

		err = mt7996_run(phy);
		if (err)
			goto out;

-		if (vif->type == NL80211_IFTYPE_MONITOR)
+		if (vif->type == NL80211_IFTYPE_MONITOR) {
			mt7996_set_monitor(phy, true);
+			phy->mt76->monitor_vif = vif;
+		}
	}

	vif->offload_flags |= IEEE80211_OFFLOAD_ENCAP_4ADDR;

@@ -520,7 +632,7 @@ int mt7996_set_channel(struct mt76_phy *mphy)
	if (ret)
		goto out;

-	ret = mt7996_mcu_set_txpower_sku(phy);
+	ret = 0; // TODO:  Broken mt7996_mcu_set_txpower_sku(phy, current_txpower);
	if (ret)
		goto out;

@@ -667,28 +830,29 @@ static int
 mt7996_get_txpower(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
		   unsigned int link_id, int *dbm)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mt7996_vif_link_phy(&mvif->deflink);
	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct wireless_dev *wdev;
-	int n_chains, delta, i;
-
-	if (!phy) {
-		wdev = ieee80211_vif_to_wdev(vif);
-		for (i = 0; i < hw->wiphy->n_radio; i++)
-			if (wdev->radio_mask & BIT(i))
-				phy = dev->radio_phy[i];
+	struct mt7996_vif_link *mconf;
+	struct mt76_phy *mphy;
+	int delta;

-		if (!phy)
-			return -EINVAL;
+	mutex_lock(&dev->mt76.mutex);
+	mconf = mt7996_vif_link(dev, vif, link_id);
+	if (!mconf || !mconf->phy) {
+		*dbm = 0;
+		goto out;
	}

-	n_chains = hweight16(phy->mt76->chainmask);
-	delta = mt76_tx_power_path_delta(n_chains);
-	*dbm = DIV_ROUND_UP(phy->mt76->txpower_cur + delta, 2);
+	mphy = mconf->phy->mt76;
+
+	delta = mt76_tx_power_path_delta(hweight16(mphy->chainmask));

+	*dbm = DIV_ROUND_UP(mphy->txpower_cur + delta, 2);
+out:
+	mutex_unlock(&dev->mt76.mutex);
	return 0;
 }
+
+
 static u8
 mt7996_get_rates_table(struct mt7996_phy *phy, struct ieee80211_bss_conf *conf,
		       bool beacon, bool mcast)
@@ -701,6 +865,11 @@ mt7996_get_rates_table(struct mt7996_phy *phy, struct ieee80211_bss_conf *conf,
	rate = mt76_connac2_mac_tx_rate_val(phy->mt76, conf, beacon, mcast);

	if (beacon) {
+		/* For WFA Cert TGax T/C 4.73.1 */
+		if (dev->cert_mode && phy->mt76->band_idx == MT_BAND2 &&
+		    conf->he_support && !conf->eht_support)
+			rate = 0x0200;
+
		/* odd index for driver, even index for firmware */
		idx = MT7996_BEACON_RATES_TBL + 2 * phy->mt76->band_idx;
		if (phy->beacon_rate != rate)
@@ -850,11 +1019,8 @@ mt7996_link_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
	if (changed & BSS_CHANGED_MU_GROUPS)
		mt7996_update_mu_group(hw, link, info);

-	if (changed & BSS_CHANGED_TXPOWER &&
-	    info->txpower != phy->txpower) {
-		phy->txpower = info->txpower;
-		mt7996_mcu_set_txpower_sku(phy);
-	}
+	if (changed & BSS_CHANGED_TXPOWER)
+		mt7996_mcu_set_txpower_sku(phy, info);

 out:
	mutex_unlock(&dev->mt76.mutex);
@@ -865,8 +1031,28 @@ mt7996_channel_switch_beacon(struct ieee80211_hw *hw,
			     struct ieee80211_vif *vif,
			     struct cfg80211_chan_def *chandef)
 {
+#if 0
+	//Buggy, won't compile, subsequent patch fixes it I guess. --Ben
	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_phy *phy = mt7996_band_phy(dev, chandef->chan->band);
+	struct ieee80211_bss_conf *conf;
+	struct mt7996_vif_link *mconf;
+	u16 valid_links = vif->valid_links ?: BIT(0);
+	unsigned int link_id;

	mutex_lock(&dev->mt76.mutex);
-	mt7996_mcu_add_beacon(hw, vif, &vif->bss_conf);
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_vif_link *mconf =
+			mt7996_vif_link(dev, vif, link_id);
+		struct ieee80211_bss_conf *conf =
+			link_conf_dereference_protected(vif, link_id);
+
+		if (!mconf || phy != mconf->phy)
+			continue;
+
+		mt7996_mcu_add_beacon(hw, vif, conf, true);
+	}
	mutex_unlock(&dev->mt76.mutex);
+#endif
+}

static int
mt7996_post_channel_switch(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			   struct ieee80211_bss_conf *link_conf)
@@ -1190,4 +1391,4 @@ mt7996_sta_state(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 static void mt7996_tx(struct ieee80211_hw *hw,
		      struct ieee80211_tx_control *control,
		      struct sk_buff *skb)
 {
	struct mt76_phy *mphy;
	struct mt7996_dev *dev = mt7996_hw_dev(hw);
	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
	struct ieee80211_vif *vif = info->control.vif;
	struct mt76_wcid *wcid;
	struct mt7996_vif *mvif;
	struct mt7996_sta *msta;
+	bool addr_trans_success = false;
+
	if (control->sta) {
		msta = (struct mt7996_sta *)control->sta->drv_priv;
		mvif = msta->vif;
	} else if (vif) {
		mvif = (struct mt7996_vif *)vif->drv_priv;
		msta = &mvif->sta;
	}

	rcu_read_lock();
	if (mvif && msta) {
		struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
		struct mt7996_vif_link *mconf;
		struct mt7996_sta_link *msta_link;
		u8 link_id = u32_get_bits(info->control.flags,
					  IEEE80211_TX_CTRL_MLO_LINK);
		struct ieee80211_sta *sta = ieee80211_find_sta(vif, hdr->addr1);

		if (link_id >= IEEE80211_LINK_UNSPECIFIED) {
			if (sta) {
				struct mt7996_sta *peer;

				peer = (struct mt7996_sta *)sta->drv_priv;
				link_id = peer->deflink_id;
			} else {
				link_id = mvif->mt76.deflink_id;
			}
		}

		/* translate mld addr to link addr */
		if (ieee80211_vif_is_mld(vif)) {
			struct ieee80211_bss_conf *conf;
			if (sta) {
				struct ieee80211_link_sta *link_sta =
					rcu_dereference(sta->link[link_id]);

				if (!link_sta) {
					link_id = msta->deflink_id;
					link_sta = rcu_dereference(sta->link[link_id]);

					if (!link_sta) {
						goto unlock;
					}
				}

				memcpy(hdr->addr1, link_sta->addr, ETH_ALEN);
				if (ether_addr_equal(sta->addr, hdr->addr3))
					memcpy(hdr->addr3, link_sta->addr, ETH_ALEN);
			}

			conf = rcu_dereference(vif->link_conf[link_id]);
			if (unlikely(!conf))
				goto unlock;

			memcpy(hdr->addr2, conf->addr, ETH_ALEN);
			if (ether_addr_equal(vif->addr, hdr->addr3))
				memcpy(hdr->addr3, conf->addr, ETH_ALEN);
		}
		mconf = (struct mt7996_vif_link *)rcu_dereference(mvif->mt76.link[link_id]);
		msta_link = rcu_dereference(msta->link[link_id]);

		if (!mconf || !msta_link)
			goto unlock;

		mphy = mconf->phy->mt76;
		wcid = &msta_link->wcid;
	} else {
		mphy = hw->priv;
		wcid = &dev->mt76.global_wcid;
	}
+
+	addr_trans_success = true;
	mt76_tx(mphy, control->sta, wcid, skb);
 unlock:
+	if (!addr_trans_success) {
+		spin_lock_bh(&dev->mt76.tx_dbg_stats.lock);
+		dev->mt76.tx_dbg_stats.tx_drop[MT_TX_DROP_ADDR_TRANS_FAIL]++;
+		spin_unlock_bh(&dev->mt76.tx_dbg_stats.lock);
+	}
	rcu_read_unlock();
 }

@@ -1523,7 +1802,6 @@ mt7996_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
		mt76_set_stream_caps(phy->mt76, true);
		mt7996_set_stream_vht_txbf_caps(phy);
		mt7996_set_stream_he_eht_caps(phy);
-		mt7996_mcu_set_txpower_sku(phy);
	}

	mutex_unlock(&dev->mt76.mutex);
@@ -1568,20 +1853,17 @@ static void mt7996_sta_statistics(struct ieee80211_hw *hw,
	sinfo->ack_signal = (s8)msta_link->ack_signal;
	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL);

-	sinfo->avg_ack_signal =
-		-(s8)ewma_avg_signal_read(&msta_link->avg_ack_signal);
+	sinfo->avg_ack_signal = -(s8)ewma_avg_signal_read(&msta_link->avg_ack_signal);
	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG);

-	if (mtk_wed_device_active(&dev->mt76.mmio.wed)) {
-		sinfo->tx_bytes = msta_link->wcid.stats.tx_bytes;
-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);
+	sinfo->tx_bytes = msta_link->wcid.stats.tx_bytes;
+	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);

-		sinfo->rx_bytes = msta_link->wcid.stats.rx_bytes;
-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);
+	sinfo->rx_bytes = msta_link->wcid.stats.rx_bytes;
+	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);

-		sinfo->tx_packets = msta_link->wcid.stats.tx_packets;
-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);
+	sinfo->tx_packets = msta_link->wcid.stats.tx_packets;
+	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);

-		sinfo->rx_packets = msta_link->wcid.stats.rx_packets;
-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS);
-	}
+	sinfo->rx_packets = msta_link->wcid.stats.rx_packets;
+	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS);
out:
	mutex_unlock(&dev->mt76.mutex);
}
@@ -1965,18 +2354,67 @@ mt7996_twt_teardown_request(struct ieee80211_hw *hw,
+static void
+mt7996_background_radar_handle_7975_ifem(struct ieee80211_hw *hw,
+					 struct cfg80211_chan_def *user_chandef,
+					 struct cfg80211_chan_def *fw_chandef)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct cfg80211_chan_def *c = user_chandef;
+	struct ieee80211_channel *first_chan;
+	bool is_ifem_adie, expand = false;
+
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		is_ifem_adie = dev->var.fem == MT7996_FEM_INT &&
+			       dev->var.type != MT7996_VAR_TYPE_233;
+		break;
+	case MT7992_DEVICE_ID:
+		is_ifem_adie = dev->var.type == MT7992_VAR_TYPE_44 &&
+			       dev->var.fem != MT7996_FEM_EXT;
+		break;
+	default:
+		return;
+	}
+
+	if (!user_chandef || !is_ifem_adie)
+		goto out;
+
+	if (user_chandef->width == NL80211_CHAN_WIDTH_160) {
+		first_chan = ieee80211_get_channel(hw->wiphy, user_chandef->center_freq1 - 70);
+		if (dev->bg_nxt_freq)
+			goto out;
+
+		if (first_chan->flags & IEEE80211_CHAN_RADAR)
+			dev->bg_nxt_freq = first_chan->center_freq;
+		else
+			c = fw_chandef;
+
+		c->chan = ieee80211_get_channel(hw->wiphy, first_chan->center_freq + 80);
+	} else {
+		if (!dev->bg_nxt_freq)
+			goto out;
+
+		c->chan = ieee80211_get_channel(hw->wiphy, dev->bg_nxt_freq);
+		dev->bg_nxt_freq = 0;
+		expand = true;
+	}
+	c->width = NL80211_CHAN_WIDTH_80;
+	c->center_freq1 = c->chan->center_freq + 30;
+
+	if (c == user_chandef)
+		cfg80211_background_radar_update_channel(hw->wiphy, c, expand);
+	return;
+out:
+	dev->bg_nxt_freq = 0;
+}
+
 static int
 mt7996_set_radar_background(struct ieee80211_hw *hw,
			    struct cfg80211_chan_def *chandef)
 {
	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy;
+	struct mt7996_phy *phy = mt7996_band_phy(dev, NL80211_BAND_5GHZ);
	int ret = -EINVAL;
	bool running;
-
-	if (chandef)
-		phy = mt7996_band_phy(dev, chandef->chan->band);
-	else
-		phy = dev->rdd2_phy;
-	if (!phy)
-	    return -EINVAL;
+	struct cfg80211_chan_def ifem_chandef = {};

	mutex_lock(&dev->mt76.mutex);

@@ -2001,13 +2442,14 @@ mt7996_set_radar_background(struct ieee80211_hw *hw,
		goto out;
	}

+	mt7996_background_radar_handle_7975_ifem(hw, chandef, &ifem_chandef);
+
	/* rdd2 already configured on a radar channel */
	running = dev->rdd2_phy &&
		  cfg80211_chandef_valid(&dev->rdd2_chandef) &&
		  !!(dev->rdd2_chandef.chan->flags & IEEE80211_CHAN_RADAR);

-	if (!chandef || running ||
-	    !(chandef->chan->flags & IEEE80211_CHAN_RADAR)) {
+	if (!chandef || running) {
		ret = mt7996_mcu_rdd_background_enable(phy, NULL);
		if (ret)
			goto out;
@@ -2016,7 +2458,9 @@ mt7996_set_radar_background(struct ieee80211_hw *hw,
			goto update_phy;
	}

-	ret = mt7996_mcu_rdd_background_enable(phy, chandef);
+	ret = mt7996_mcu_rdd_background_enable(phy,
+					       ifem_chandef.chan ?
+					       &ifem_chandef : chandef);
	if (ret)
		goto out;

@@ -2043,9 +2487,7 @@ mt7996_net_fill_forward_path(struct ieee80211_hw *hw,
	struct mt7996_dev *dev = mt7996_hw_dev(hw);
	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
	struct mt7996_sta_link *msta_link;
-	struct mt7996_vif_link *link;
	struct mt76_vif_link *mlink;
-	struct mt7996_phy *phy;

	mlink = rcu_dereference(mvif->mt76.link[msta->deflink_id]);
	if (!mlink)
@@ -2058,13 +2500,20 @@ mt7996_net_fill_forward_path(struct ieee80211_hw *hw,
	if (!msta_link->wcid.sta || msta_link->wcid.idx > MT7996_WTBL_STA)
		return -EIO;

-	link = (struct mt7996_vif_link *)mlink;
-	phy = mt7996_vif_link_phy(link);
-	if (!phy)
-		return -ENODEV;
-
-	if (phy != &dev->phy && phy->mt76->band_idx == MT_BAND2)
-		wed = &dev->mt76.mmio.wed_hif2;
+	if (dev->hif2) {
+		switch (dev->option_type) {
+		case 2:
+			/* eagle + 7988d */
+			if (msta_link->wcid.phy_idx == MT_BAND1)
+				wed = &dev->mt76.mmio.wed_hif2;
+			break;
+		default:
+			if ((is_mt7996(&dev->mt76) && msta_link->wcid.phy_idx == MT_BAND2) ||
+			    (is_mt7992(&dev->mt76) && msta_link->wcid.phy_idx == MT_BAND1))
+				wed = &dev->mt76.mmio.wed_hif2;
+			break;
+		}
+	}

	if (!mtk_wed_device_active(wed))
		return -ENODEV;
@@ -2076,7 +2525,12 @@ mt7996_net_fill_forward_path(struct ieee80211_hw *hw,
	path->mtk_wdma.queue = 0;
	path->mtk_wdma.wcid = msta_link->wcid.idx;

-	path->mtk_wdma.amsdu = mtk_wed_is_amsdu_supported(wed);
+	if (ieee80211_hw_check(hw, SUPPORTS_AMSDU_IN_AMPDU) &&
+	    mtk_wed_is_amsdu_supported(wed))
+		path->mtk_wdma.amsdu = msta_link->wcid.amsdu;
+	else
+		path->mtk_wdma.amsdu = 0;
+
	ctx->dev = NULL;

	return 0;
@@ -2136,4 +2702,6 @@ const struct ieee80211_ops mt7996_ops = {
	.add_twt_setup = mt7996_mac_add_twt_setup,
	.twt_teardown_request = mt7996_twt_teardown_request,
+	CFG80211_TESTMODE_CMD(mt76_testmode_cmd)
+	CFG80211_TESTMODE_DUMP(mt76_testmode_dump)
 #ifdef CONFIG_MAC80211_DEBUGFS
	.sta_add_debugfs = mt7996_sta_add_debugfs,
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c
index fdc517873fa6..dad8e5df07ab 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c
@@ -9,6 +9,7 @@
 #include "mcu.h"
 #include "mac.h"
 #include "eeprom.h"
+#include "mt7996_trace.h"

 #define fw_name(_dev, name, ...)	({			\
	char *_fw;						\
@@ -18,6 +19,9 @@
		case MT7992_VAR_TYPE_23:			\
			_fw = MT7992_##name##_23;		\
			break;					\
+		case MT7992_VAR_TYPE_24:			\
+			_fw = MT7992_##name##_24;		\
+			break;					\
		default:					\
			_fw = MT7992_##name;			\
		}						\
@@ -301,6 +313,9 @@ mt7996_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,
		else if (cmd & __MCU_CMD_FIELD_WM)
			uni_txd->s2d_index = MCU_S2D_H2N;

+		trace_mt7996_mcu_cmd(dev, 1, uni_txd->cid, 0,
+				    skb->data, skb->len);
+
		goto exit;
	}

@@ -328,5 +343,7 @@ mt7996_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,
	else
		mcu_txd->s2d_index = MCU_S2D_H2N;

+	trace_mt7996_mcu_cmd(dev, 0, mcu_txd->cid, mcu_txd->ext_cid,
+			    skb->data, skb->len);
 exit:
	if (dev->dbg.dump_mcu_pkt)
@@ -400,11 +432,12 @@ mt7996_mcu_rx_radar_detected(struct mt7996_dev *dev, struct sk_buff *skb)
	if (!mphy)
		return;

-	if (r->rdd_idx == MT_RDD_IDX_BACKGROUND)
+	if (r->rdd_idx == MT_RDD_IDX_BACKGROUND) {
+		dev->bg_nxt_freq = 0;
		cfg80211_background_radar_event(mphy->hw->wiphy,
						&dev->rdd2_chandef,
						GFP_ATOMIC);
-	else
+	} else
		ieee80211_radar_detected(mphy->hw, NULL);
	dev->hw_pattern++;
 }
@@ -537,8 +583,284 @@ mt7996_mcu_update_tx_gi(struct rate_info *rate, struct all_sta_trx_rate *mcu_rat
	return 0;
 }

+static inline void __mt7996_stat_to_netdev(struct mt76_phy *mphy,
+					   struct mt76_wcid *wcid,
+					   u32 tx_bytes, u32 rx_bytes,
+					   u32 tx_packets, u32 rx_packets)
+{
+	struct mt7996_sta_link *msta_link;
+	struct ieee80211_vif *vif;
+	struct wireless_dev *wdev;
+
+	if (wiphy_ext_feature_isset(mphy->hw->wiphy,
+				    NL80211_EXT_FEATURE_STAS_COUNT)) {
+		msta_link = container_of(wcid, struct mt7996_sta_link, wcid);
+		vif = container_of((void *)msta_link->sta->vif, struct ieee80211_vif,
+				   drv_priv);
+		wdev = ieee80211_vif_to_wdev(vif);
+
+		if (vif->type == NL80211_IFTYPE_MONITOR)
+			return;
+
+		dev_sw_netstats_tx_add(wdev->netdev, tx_packets, tx_bytes);
+		dev_sw_netstats_rx_add_p(wdev->netdev, rx_packets, rx_bytes);
+	}
+}
+
+static int
+csi_integrate_segment_data(struct mt7996_phy *phy, struct csi_data *csi)
+{
+	struct csi_data *csi_temp = NULL;
+
+	if (csi->segment_num == 0 && csi->remain_last == 0)
+		return CSI_CHAIN_COMPLETE;
+	else if (csi->segment_num == 0 && csi->remain_last == 1) {
+		memcpy(&phy->csi.buffered_csi,
+		       csi, sizeof(struct csi_data));
+
+		return CSI_CHAIN_SEGMENT_FIRST;
+	} else if (csi->segment_num != 0) {
+		csi_temp = &phy->csi.buffered_csi;
+		if (csi->chain_info != csi_temp->chain_info ||
+		csi->segment_num != (csi_temp->segment_num + 1))
+			return CSI_CHAIN_SEGMENT_ERR;
+
+		memcpy(&csi_temp->data_i[csi_temp->data_num],
+		       csi->data_i, csi->data_num * sizeof(s16));
+
+		memcpy(&csi_temp->data_q[csi_temp->data_num],
+		       csi->data_q, csi->data_num * sizeof(s16));
+
+		csi_temp->data_num += csi->data_num;
+		csi_temp->segment_num = csi->segment_num;
+		csi_temp->remain_last = csi->remain_last;
+
+		if (csi->remain_last == 0)
+			return CSI_CHAIN_SEGMENT_LAST;
+		else if (csi->remain_last == 1)
+			return CSI_CHAIN_SEGMENT_MIDDLE;
+	}
+
+	return CSI_CHAIN_ERR;
+}
+
+static int
+mt7996_mcu_csi_report_data(struct mt7996_phy *phy, u8 *tlv_buf, u32 len)
+{
+	int ret, i;
+	struct csi_data *current_csi;
+	struct csi_data *target_csi;
+	struct csi_tlv *tlv_data;
+	u8 *buf_tmp;
+	u32 rx_info, tx_rx_idx;
+	u32 buf_len_last, offset;
+
+	buf_tmp = tlv_buf;
+	buf_len_last = len;
+	offset = sizeof(((struct csi_tlv *)0)->basic);
+
+	current_csi = kzalloc(sizeof(*current_csi), GFP_KERNEL);
+	if (!current_csi)
+		return -ENOMEM;
+
+	while (buf_len_last >= offset) {
+		u32 tag, len;
+		s16 *data_tmp = NULL;
+
+		tlv_data = (struct csi_tlv *)buf_tmp;
+		tag = le32_to_cpu(tlv_data->basic.tag);
+		len = le32_to_cpu(tlv_data->basic.len);
+
+		switch (tag) {
+		case CSI_EVENT_FW_VER:
+			current_csi->fw_ver = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_CBW:
+			current_csi->ch_bw = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_RSSI:
+			current_csi->rssi = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_SNR:
+			current_csi->snr = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_BAND:
+			current_csi->band = le32_to_cpu(tlv_data->info);
+
+			if (current_csi->band != phy->mt76->band_idx) {
+				kfree(current_csi);
+				return -EINVAL;
+			}
+
+			break;
+		case CSI_EVENT_CSI_NUM:
+			current_csi->data_num = le32_to_cpu(tlv_data->info);
+
+			if (current_csi->data_num > CSI_BW80_DATA_COUNT) {
+				kfree(current_csi);
+				return -EINVAL;
+			}
+
+			break;
+		case CSI_EVENT_CSI_I_DATA:
+			if (len != sizeof(s16) * current_csi->data_num) {
+				kfree(current_csi);
+				return -EINVAL;
+			}
+
+			data_tmp = tlv_data->data;
+			for (i = 0; i < current_csi->data_num; i++)
+				current_csi->data_i[i] = le16_to_cpu(*(data_tmp + i));
+			break;
+		case CSI_EVENT_CSI_Q_DATA:
+			if (len != sizeof(s16) * current_csi->data_num) {
+				kfree(current_csi);
+				return -EINVAL;
+			}
+
+			data_tmp = tlv_data->data;
+			for (i = 0; i < current_csi->data_num; i++)
+				current_csi->data_q[i] = le16_to_cpu(*(data_tmp + i));
+			break;
+		case CSI_EVENT_DBW:
+			current_csi->data_bw = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_CH_IDX:
+			current_csi->pri_ch_idx = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_TA:
+			memcpy(current_csi->ta, tlv_data->mac, ETH_ALEN);
+			break;
+		case CSI_EVENT_EXTRA_INFO:
+			current_csi->ext_info = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_RX_MODE:
+			rx_info = le32_to_cpu(tlv_data->info);
+			current_csi->rx_mode = u32_get_bits(rx_info, GENMASK(15, 0));
+			current_csi->rx_rate = u32_get_bits(rx_info, GENMASK(31, 16));
+			break;
+		case CSI_EVENT_H_IDX:
+			current_csi->chain_info = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_TX_RX_IDX:
+			tx_rx_idx = le32_to_cpu(tlv_data->info);
+			current_csi->tx_idx = u32_get_bits(tx_rx_idx, GENMASK(31, 16));
+			current_csi->rx_idx = u32_get_bits(tx_rx_idx, GENMASK(15, 0));
+			break;
+		case CSI_EVENT_TS:
+			current_csi->ts = le32_to_cpu(tlv_data->info);
+
+			if (phy->csi.interval &&
+				current_csi->ts < phy->csi.last_record + phy->csi.interval) {
+				kfree(current_csi);
+				return 0;
+			}
+
+			break;
+		case CSI_EVENT_PKT_SN:
+			current_csi->pkt_sn = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_BW_SEG:
+			current_csi->segment_num = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_REMAIN_LAST:
+			current_csi->remain_last = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_TR_STREAM:
+			current_csi->tr_stream = le32_to_cpu(tlv_data->info);
+			break;
+		default:
+			break;
+		};
+
+		buf_len_last -= (offset + len);
+
+		if (buf_len_last >= offset)
+			buf_tmp += (offset + len);
+	}
+
+	/* integret the bw80 segment */
+	if (current_csi->ch_bw >= CSI_BW80) {
+		ret = csi_integrate_segment_data(phy, current_csi);
+
+		switch (ret) {
+		case CSI_CHAIN_ERR:
+		case CSI_CHAIN_SEGMENT_ERR:
+			kfree(current_csi);
+			return -EINVAL;
+			break;
+		case CSI_CHAIN_SEGMENT_FIRST:
+		case CSI_CHAIN_SEGMENT_MIDDLE:
+			kfree(current_csi);
+			return 0;
+			break;
+		case CSI_CHAIN_COMPLETE:
+			target_csi = current_csi;
+			break;
+		case CSI_CHAIN_SEGMENT_LAST:
+			target_csi = current_csi;
+			memcpy(target_csi, &phy->csi.buffered_csi, sizeof(struct csi_data));
+			memset(&phy->csi.buffered_csi, 0, sizeof(struct csi_data));
			break;
		default:
			break;
		}
+	} else {
+		target_csi = current_csi;
+	}
+
+	/* put the csi data into list */
+	INIT_LIST_HEAD(&target_csi->node);
+	spin_lock_bh(&phy->csi.lock);
+
+	if (!phy->csi.enable) {
+		kfree(target_csi);
+		goto out;
+	}
+
+	list_add_tail(&target_csi->node, &phy->csi.list);
+	phy->csi.count++;
+
+	if (phy->csi.count > CSI_MAX_BUF_NUM) {
+		struct csi_data *old;
+
+		old = list_first_entry(&phy->csi.list,
+				       struct csi_data, node);
+
+		list_del(&old->node);
+		kfree(old);
+		phy->csi.count--;
+	}
+
+	if (target_csi->chain_info & BIT(15)) /* last chain */
+		phy->csi.last_record = target_csi->ts;
+
+out:
+	spin_unlock_bh(&phy->csi.lock);
+	return 0;
+}
+
+static void
+mt7996_mcu_csi_report_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_mcu_csi_event *event;
+	struct mt76_phy *mphy;
+	struct mt7996_phy *phy;
+
+	event = (struct mt7996_mcu_csi_event *)skb->data;
+
+	mphy = dev->mt76.phys[event->band_idx];
+	if (!mphy)
+		return;
+
+	phy = mphy->priv;
+
+	switch (le16_to_cpu(event->tag)) {
+	case UNI_EVENT_CSI_DATA:
+		mt7996_mcu_csi_report_data(phy, event->tlv_buf, le16_to_cpu(event->len) - 4);
+		break;
+	default:
+		break;
+	}
+}

@@ -727,6 +1167,10 @@ mt7996_mcu_uni_rx_unsolicited_event(struct mt7996_dev *dev, struct sk_buff *skb)
 {
	struct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;

+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_mcu_event)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_MCU_EVENT, 0);
+#endif
	switch (rxd->eid) {
	case MCU_UNI_EVENT_FW_LOG_2_HOST:
		mt7996_mcu_rx_log_message(dev, skb);
@@ -743,6 +1187,16 @@ mt7996_mcu_uni_rx_unsolicited_event(struct mt7996_dev *dev, struct sk_buff *skb)
	case MCU_UNI_EVENT_THERMAL:
		mt7996_mcu_rx_thermal_notify(dev, skb);
		break;
+#ifdef CONFIG_NL80211_TESTMODE
+	case MCU_UNI_EVENT_TESTMODE_CTRL:
+		mt7996_tm_rf_test_event(dev, skb);
+		break;
+#endif
+#ifdef CONFIG_MTK_VENDOR
+	case MCU_UNI_EVENT_CSI_REPORT:
+		mt7996_mcu_csi_report_event(dev, skb);
+		break;
+#endif
	default:
		break;
	}
@@ -753,6 +1220,8 @@ void mt7996_mcu_rx_event(struct mt7996_dev *dev, struct sk_buff *skb)
 {
	struct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;

+	trace_mt7996_mcu_event(dev, rxd->option & MCU_UNI_CMD_UNSOLICITED_EVENT,
+			      rxd->eid, rxd->ext_eid, skb->data, skb->len);
	if (rxd->option & MCU_UNI_CMD_UNSOLICITED_EVENT) {
		mt7996_mcu_uni_rx_unsolicited_event(dev, skb);
		return;
@@ -1052,8 +1534,13 @@ mt7996_mcu_bss_basic_tlv(struct sk_buff *skb,
	bss->hw_bss_idx = idx;

	if (vif->type == NL80211_IFTYPE_MONITOR) {
-		memcpy(bss->bssid, phy->macaddr, ETH_ALEN);
+		struct mt76_testmode_data *td = &phy->test;
+
+		if (!td->bf_en)
+			memcpy(bss->bssid, phy->macaddr, ETH_ALEN);
+		else
+			memcpy(bss->bssid, td->addr[2], ETH_ALEN);
		return 0;
	}

	memcpy(bss->bssid, link_conf->bssid, ETH_ALEN);
@@ -1326,6 +1819,10 @@ mt7996_mcu_sta_vht_tlv(struct sk_buff *skb, struct ieee80211_link_sta *link_sta)
 {
	struct sta_rec_vht *vht;
	struct tlv *tlv;
+#ifdef CONFIG_MTK_VENDOR
+	struct mt7996_sta *msta = (struct mt7996_sta *)link_sta->sta->drv_priv;
+	struct mt7996_phy *phy = (struct mt7996_phy *)msta->vif->deflink.phy;
+#endif

	/* For 6G band, this tlv is necessary to let hw work normally */
	if (!link_sta->he_6ghz_capa.capa && !link_sta->vht_cap.vht_supported)
@@ -1337,6 +1834,9 @@ mt7996_mcu_sta_vht_tlv(struct sk_buff *skb, struct ieee80211_link_sta *link_sta)
	vht->vht_cap = cpu_to_le32(link_sta->vht_cap.cap);
	vht->vht_rx_mcs_map = link_sta->vht_cap.vht_mcs.rx_mcs_map;
	vht->vht_tx_mcs_map = link_sta->vht_cap.vht_mcs.tx_mcs_map;
+#ifdef CONFIG_MTK_VENDOR
+	vht->rts_bw_sig = phy->rts_bw_sig;
+#endif
 }

 static void
@@ -2670,6 +3178,11 @@ mt7996_mcu_beacon_cont(struct mt7996_dev *dev,
			      BSS_CHANGED_BEACON);

	memcpy(buf + MT_TXD_SIZE, skb->data, skb->len);
+
+	if (dev->dbg.dump_txd)
+		mt7996_packet_log_to_host(dev, (__le32 *)buf, MT_TXD_SIZE, PKT_BIN_DEBUG_TXD, 0);
+	if (dev->dbg.dump_tx_pkt)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_TX, 0);
 }

 int mt7996_mcu_add_beacon(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			  struct ieee80211_bss_conf *link_conf, int en)
 {
	struct mt7996_dev *dev = mt7996_hw_dev(hw);
	struct mt76_vif_link *mlink = mt76_vif_conf_link(&dev->mt76, vif, link_conf);
@@ -3028,8 +3546,12 @@ static int mt7996_load_ram(struct mt7996_dev *dev)
 {
	int ret;

-	ret = __mt7996_load_ram(dev, "WM", fw_name(dev, FIRMWARE_WM),
-				MT7996_RAM_TYPE_WM);
+	if (dev->testmode_enable)
+		ret = __mt7996_load_ram(dev, "WM_TM", fw_name(dev, FIRMWARE_WM_TM),
+					MT7996_RAM_TYPE_WM_TM);
+	else
+		ret = __mt7996_load_ram(dev, "WM", fw_name(dev, FIRMWARE_WM),
+					MT7996_RAM_TYPE_WM);
	if (ret)
		return ret;

@@ -3664,7 +4295,151 @@ int mt7996_mcu_set_chan_info(struct mt7996_phy *phy, u16 tag)
				 &req, sizeof(req), true);
 }

-static int mt7996_mcu_set_eeprom_flash(struct mt7996_dev *dev)
+static int mt7996_mcu_set_cal_free_data(struct mt7996_dev *dev)
+{
+#define MT_EE_CAL_FREE_MAX_SIZE		30
+#define MT_EE_7977BN_OFFSET		(0x1200 - 0x500)
+#define MT_EE_END_OFFSET		0xffff
+	enum adie_type {
+		ADIE_7975,
+		ADIE_7976,
+		ADIE_7977,
+		ADIE_7978,
+		ADIE_7979,
+	};
+	static const u16 adie_offs_list[][MT_EE_CAL_FREE_MAX_SIZE] = {
+		[ADIE_7975] = {0x5cd, 0x5cf, 0x5d1, 0x5d3, 0x6c0, 0x6c1, 0x6c2, 0x6c3,
+			       0x7a1, 0x7a6, 0x7a8, 0x7aa, -1},
+		[ADIE_7976] = {0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x53, 0x55, 0x57, 0x59,
+			       0x70, 0x71, 0x790, 0x791, 0x794, 0x795, 0x7a6, 0x7a8, 0x7aa, -1},
+		[ADIE_7977] = {0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x53, 0x55, 0x57, 0x59,
+			       0x69, 0x6a, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, -1},
+		[ADIE_7978] = {0x91, 0x95, 0x100, 0x102, 0x104, 0x106, 0x107,
+			       0x108, 0x109, 0x10a, 0x10b, 0x10c, 0x10e, 0x110, -1},
+		[ADIE_7979] = {0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x53, 0x55, 0x57, 0x59,
+			       0x69, 0x6a, 0x7a, 0x7b, 0x7c, 0x7e, 0x80, -1},
+	};
+	static const u16 eep_offs_list[][MT_EE_CAL_FREE_MAX_SIZE] = {
+		[ADIE_7975] = {0x451, 0x453, 0x455, 0x457, 0x44c, 0x44d, 0x44e, 0x44f,
+			       0xba1, 0xba6, 0xba8, 0xbaa, -1},
+		[ADIE_7976] = {0x44c, 0x44d, 0x44e, 0x44f, 0x450,
+			       0x451, 0x453, 0x455, 0x457, 0x459,
+			       0x470, 0x471, 0xb90, 0xb91, 0xb94, 0xb95,
+			       0xba6, 0xba8, 0xbaa, -1},
+		[ADIE_7977] = {0x124c, 0x124d, 0x124e, 0x124f, 0x1250,
+			       0x1251, 0x1253, 0x1255, 0x1257, 0x1259,
+			       0x1269, 0x126a, 0x127a, 0x127b, 0x127c, 0x127d, 0x127e, -1},
+		[ADIE_7978] = {0xb91, 0xb95, 0x480, 0x482, 0x484, 0x486, 0x487, 0x488, 0x489,
+			       0x48a, 0x48b, 0x48c, 0x48e, 0x490, -1},
+		[ADIE_7979] = {0x124c, 0x124d, 0x124e, 0x124f, 0x1250, 0x1251,
+			       0x1253, 0x1255, 0x1257, 0x1259, 0x1269, 0x126a,
+			       0x127a, 0x127b, 0x127c, 0x127e, 0x1280, -1},
+	};
+	static const u16 adie_base_7996[] = {
+		0x400, 0x1e00, 0x1200
+	};
+	static const u16 adie_base_7992[] = {
+		0x400, 0x1200, 0x0
+	};
+	static const u16 *adie_offs[__MT_MAX_BAND];
+	static const u16 *eep_offs[__MT_MAX_BAND];
+	static const u16 *adie_base;
+	int adie_id, band, i, ret;
+
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		adie_base = adie_base_7996;
+		/* adie 0 */
+		if (dev->var.fem == MT7996_FEM_INT && dev->var.type != MT7996_VAR_TYPE_233)
+			adie_id = ADIE_7975;
+		else
+			adie_id = ADIE_7976;
+		adie_offs[0] = adie_offs_list[adie_id];
+		eep_offs[0] = eep_offs_list[adie_id];
+
+		/* adie 1 */
+		if (dev->var.type == MT7996_VAR_TYPE_444) {
+			adie_offs[1] = adie_offs_list[ADIE_7977];
+			eep_offs[1] = eep_offs_list[ADIE_7977];
+		}
+
+		/* adie 2 */
+		adie_offs[2] = adie_offs_list[ADIE_7977];
+		eep_offs[2] = eep_offs_list[ADIE_7977];
+		break;
+	case MT7992_DEVICE_ID:
+		adie_base = adie_base_7992;
+		/* adie 0 */
+		if (dev->var.type == MT7992_VAR_TYPE_44 &&
+		    dev->var.fem != MT7996_FEM_EXT)
+			adie_id = ADIE_7975;
+		else if (dev->var.type == MT7992_VAR_TYPE_24)
+			adie_id = ADIE_7978;
+		else
+			adie_id = ADIE_7976;
+		adie_offs[0] = adie_offs_list[adie_id];
+		eep_offs[0] = eep_offs_list[adie_id];
+
+		/* adie 1 */
+		if (dev->var.type == MT7992_VAR_TYPE_44 &&
+		    dev->var.fem != MT7996_FEM_INT)
+			adie_id = ADIE_7977;
+		else if (dev->var.type != MT7992_VAR_TYPE_23)
+			adie_id = ADIE_7979;
+		else
+			break;
+		adie_offs[1] = adie_offs_list[adie_id];
+		eep_offs[1] = eep_offs_list[adie_id];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	for (band = 0; band < __MT_MAX_BAND; band++) {
+		struct {
+			/* fixed field */
+			u8 __rsv[4];
+
+			__le16 tag;
+			__le16 len;
+			__le16 adie_offset;
+			__le16 eep_offset;
+			__le16 count;
+			u8 rsv[2];
+		} __packed req = {
+			.tag = cpu_to_le16(UNI_EFUSE_PATCH),
+			.len = cpu_to_le16(sizeof(req) - 4),
+			.count = cpu_to_le16(1),
+		};
+		u16 adie_offset, eep_offset;
+
+		if (!adie_offs[band])
+			continue;
+
+		for (i = 0; i < MT_EE_CAL_FREE_MAX_SIZE; i++) {
+			adie_offset = adie_offs[band][i] + adie_base[band];
+			eep_offset = eep_offs[band][i];
+
+			if (adie_offs[band][i] == MT_EE_END_OFFSET)
+				break;
+
+			if (is_mt7996(&dev->mt76) && dev->var.type == MT7996_VAR_TYPE_444 &&
+			    band == MT_BAND1)
+				eep_offset -= MT_EE_7977BN_OFFSET;
+
+			req.eep_offset = cpu_to_le16(eep_offset);
+			req.adie_offset = cpu_to_le16(adie_offset);
+			ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),
+						&req, sizeof(req), true);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+int mt7996_mcu_set_eeprom_flash(struct mt7996_dev *dev)
 {
 #define MAX_PAGE_IDX_MASK	GENMASK(7, 5)
 #define PAGE_IDX_MASK		GENMASK(4, 2)
@@ -3717,25 +4492,22 @@ int mt7996_mcu_set_eeprom(struct mt7996_dev *dev)
		.buffer_mode = EE_MODE_EFUSE,
		.format = EE_FORMAT_WHOLE
	};
+	int ret;

	if (dev->flash_mode)
-		return mt7996_mcu_set_eeprom_flash(dev);
+		ret = mt7996_mcu_set_eeprom_flash(dev);
+	else
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),
+					&req, sizeof(req), true);
+	if (ret)
+		return ret;

-	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),
-				 &req, sizeof(req), true);
+	return mt7996_mcu_set_cal_free_data(dev);
 }

 int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_len)
 {
-	struct {
-		u8 _rsv[4];
-
-		__le16 tag;
-		__le16 len;
-		__le32 addr;
-		__le32 valid;
-		u8 data[16];
-	} __packed req = {
+	struct mt7996_mcu_eeprom_info req = {
		.tag = cpu_to_le16(UNI_EFUSE_ACCESS),
		.len = cpu_to_le16(sizeof(req) - 4),
		.addr = cpu_to_le32(round_down(offset,
@@ -3757,6 +4529,7 @@ int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_l

		if (!buf)
			buf = (u8 *)dev->mt76.eeprom.data + addr;
+
		if (!buf_len || buf_len > MT7996_EEPROM_BLOCK_SIZE)
			buf_len = MT7996_EEPROM_BLOCK_SIZE;

@@ -3801,6 +4574,192 @@ int mt7996_mcu_get_eeprom_free_block(struct mt7996_dev *dev, u8 *block_num)
	return 0;
 }

+static int mt7996_mcu_set_pre_cal(struct mt7996_dev *dev, u32 idx,
+				  u8 *cal, u32 len, u32 cal_id)
+{
+#define PRECAL_CMD_PRE_CAL_RESULT	0x0
+	struct {
+		/* fixed field */
+		u8 action;
+		u8 dest;
+		u8 attribute;
+		u8 tag_num;
+
+		__le16 tag;
+		__le16 len;
+
+		__le32 cal_id;
+		s8 precal;
+		u8 band;
+		u8 rsv[2];
+		__le32 idx;
+		__le32 cal_len;
+	} req = {
+		.tag = cpu_to_le16(PRECAL_CMD_PRE_CAL_RESULT),
+		.len = cpu_to_le16(sizeof(req) - 4 + len),
+		.cal_id = cpu_to_le32(cal_id),
+		.idx = cpu_to_le32(idx),
+		.cal_len = cpu_to_le32(len),
+	};
+	struct sk_buff *skb;
+
+	if (!len)
+		return 0;
+
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, sizeof(req) + len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_put_data(skb, &req, sizeof(req));
+	skb_put_data(skb, cal, len);
+
+	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_WM_UNI_CMD(PRECAL_RESULT), false);
+}
+
+int mt7996_mcu_apply_group_cal(struct mt7996_dev *dev)
+{
+	u8 *cal = dev->cal, *eeprom = dev->mt76.eeprom.data;
+	u32 idx = 0, total_idx = MT_EE_CAL_GROUP_SIZE / MT_EE_CAL_UNIT;
+	u32 offs = MT_EE_DO_PRE_CAL;
+	int ret = 0;
+
+	if (!(eeprom[offs] & MT_EE_WIFI_CAL_GROUP))
+		return 0;
+
+	for (idx = 0; idx < total_idx; idx++, cal += MT_EE_CAL_UNIT) {
+		ret = mt7996_mcu_set_pre_cal(dev, idx, cal, MT_EE_CAL_UNIT, RF_PRE_CAL);
+		if (ret)
+			goto out;
+	}
+
+	ret = mt7996_mcu_set_pre_cal(dev, total_idx, cal,
+				     MT_EE_CAL_GROUP_SIZE % MT_EE_CAL_UNIT, RF_PRE_CAL);
+
+out:
+	return ret;
+}
+
+int mt7996_mcu_apply_tx_dpd(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_phy *mphy = phy->mt76;
+	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+	enum nl80211_band band = chandef->chan->band;
+	enum nl80211_chan_width bw = chandef->width;
+	const struct ieee80211_channel *chan_list;
+	u32 cal_id, chan_list_size, base_offset = 0, offs = MT_EE_DO_PRE_CAL;
+	u32 per_chan_size = DPD_PER_CH_BW20_SIZE;
+	u16 channel = ieee80211_frequency_to_channel(chandef->center_freq1);
+	u8 dpd_mask, *cal = dev->cal, *eeprom = dev->mt76.eeprom.data;
+	int idx, i, ret;
+	bool has_skip_ch = (band == NL80211_BAND_5GHZ);
+
+	switch (band) {
+	case NL80211_BAND_2GHZ:
+		dpd_mask = MT_EE_WIFI_CAL_DPD_2G;
+		/* channel 14 don't need DPD cal */
+		if (channel >= 1 && channel <= 4)
+			channel = 3;
+		else if (channel >= 5 && channel <= 9)
+			channel = 7;
+		else if (channel >= 10 && channel <= 13)
+			channel = 11;
+		else
+			return 0;
+		cal_id = RF_DPD_FLAT_CAL;
+		chan_list = dpd_2g_ch_list_bw20;
+		chan_list_size = DPD_CH_NUM(BW20_2G);
+		break;
+	case NL80211_BAND_5GHZ:
+		dpd_mask = MT_EE_WIFI_CAL_DPD_5G;
+		cal_id = RF_DPD_FLAT_5G_CAL;
+		chan_list = mphy->sband_5g.sband.channels;
+		chan_list_size = mphy->sband_5g.sband.n_channels;
+		base_offset += MT_EE_CAL_DPD_SIZE_2G;
+		if (bw == NL80211_CHAN_WIDTH_160) {
+			base_offset += DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE +
+				       DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_5G_MEM_CAL;
+			chan_list = dpd_5g_ch_list_bw160;
+			chan_list_size = DPD_CH_NUM(BW160_5G);
+			has_skip_ch = false;
+		} else if (is_mt7992(&dev->mt76) && bw == NL80211_CHAN_WIDTH_80) {
+			base_offset += DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_5G_MEM_CAL;
+			chan_list = dpd_5g_ch_list_bw80;
+			chan_list_size = DPD_CH_NUM(BW80_5G);
+			has_skip_ch = false;
+		} else if (bw > NL80211_CHAN_WIDTH_20) {
+			/* apply (center channel - 2)'s dpd cal data for bw 40/80 channels */
+			channel -= 2;
+		}
+		if (channel >= dpd_5g_skip_ch_list[0].hw_value &&
+		    channel <= dpd_5g_skip_ch_list[DPD_CH_NUM(BW20_5G_SKIP) - 1].hw_value)
+			return 0;
+		break;
+	case NL80211_BAND_6GHZ:
+		dpd_mask = MT_EE_WIFI_CAL_DPD_6G;
+		cal_id = RF_DPD_FLAT_6G_CAL;
+		chan_list = mphy->sband_6g.sband.channels;
+		chan_list_size = mphy->sband_6g.sband.n_channels;
+		base_offset += MT_EE_CAL_DPD_SIZE_2G + MT_EE_CAL_DPD_SIZE_5G;
+		if (bw == NL80211_CHAN_WIDTH_160) {
+			base_offset += mphy->sband_6g.sband.n_channels * DPD_PER_CH_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_6G_MEM_CAL;
+			chan_list = dpd_6g_ch_list_bw160;
+			chan_list_size = DPD_CH_NUM(BW160_6G);
+		} else if (is_mt7996(&dev->mt76) && bw == NL80211_CHAN_WIDTH_320) {
+			base_offset += mphy->sband_6g.sband.n_channels * DPD_PER_CH_BW20_SIZE +
+				       DPD_CH_NUM(BW80_6G) * DPD_PER_CH_GT_BW20_SIZE +
+				       DPD_CH_NUM(BW160_6G) * DPD_PER_CH_GT_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_6G_MEM_CAL;
+			chan_list = dpd_6g_ch_list_bw320;
+			chan_list_size = DPD_CH_NUM(BW320_6G);
+		} else if (is_mt7992(&dev->mt76) && bw == NL80211_CHAN_WIDTH_80) {
+			base_offset += mphy->sband_6g.sband.n_channels * DPD_PER_CH_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_6G_MEM_CAL;
+			chan_list = dpd_6g_ch_list_bw80;
+			chan_list_size = DPD_CH_NUM(BW80_6G);
+		} else if (bw > NL80211_CHAN_WIDTH_20) {
+			/* apply (center channel - 2)'s dpd cal data for bw 40/80 channels */
+			channel -= 2;
+		}
+		break;
+	default:
+		dpd_mask = 0;
+		break;
+	}
+
+	if (!(eeprom[offs] & dpd_mask))
+		return 0;
+
+	for (idx = 0; idx < chan_list_size; idx++)
+		if (channel == chan_list[idx].hw_value)
+			break;
+	if (idx == chan_list_size)
+		return -EINVAL;
+
+	if (has_skip_ch && channel > dpd_5g_skip_ch_list[DPD_CH_NUM(BW20_5G_SKIP) - 1].hw_value)
+		idx -= DPD_CH_NUM(BW20_5G_SKIP);
+
+	cal += MT_EE_CAL_GROUP_SIZE + base_offset + idx * per_chan_size;
+
+	for (i = 0; i < per_chan_size / MT_EE_CAL_UNIT; i++) {
+		ret = mt7996_mcu_set_pre_cal(dev, i, cal, MT_EE_CAL_UNIT, cal_id);
+		if (ret)
+			return ret;
+
+		cal += MT_EE_CAL_UNIT;
+	}
+
+	return ret;
+}
+
 int mt7996_mcu_get_chip_config(struct mt7996_dev *dev, u32 *cap)
 {
 #define NIC_CAP	3
@@ -4087,7 +5048,6 @@ int mt7996_mcu_set_ser(struct mt7996_dev *dev, u8 action, u8 val, u8 band)
 int mt7996_mcu_set_txbf(struct mt7996_dev *dev, u8 action)
 {
 #define MT7996_BF_MAX_SIZE	sizeof(union bf_tag_tlv)
-#define BF_PROCESSING	4
	struct uni_header hdr;
	struct sk_buff *skb;
	struct tlv *tlv;
@@ -4484,3 +5454,3 @@ int mt7996_mcu_rdd_cmd(struct mt7996_dev *dev, int cmd, u8 rdd_idx, u8 val)
				 &req, sizeof(req), true);
 }

@@ -4692,8 +5819,32 @@ int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled)
-int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy)
+static void
+mt7996_update_max_txpower_cur(struct mt7996_phy *phy, int tx_power)
+{
+	struct mt76_phy *mphy = phy->mt76;
+	struct ieee80211_channel *chan = mphy->main_chandef.chan;
+	int e2p_power_limit = 0;
+
+	if (chan == NULL) {
+		mphy->txpower_cur = tx_power;
+		return;
+	}
+
+	e2p_power_limit = mt7996_eeprom_get_target_power(phy->dev, chan);
+	e2p_power_limit += mt7996_eeprom_get_power_delta(phy->dev, chan->band);
+
+	if (phy->sku_limit_en)
+		mphy->txpower_cur = min_t(int, e2p_power_limit, tx_power);
+	else
+		mphy->txpower_cur = e2p_power_limit;
+}
+
+int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy,
+			       struct ieee80211_bss_conf *conf)
 {
 #define TX_POWER_LIMIT_TABLE_RATE	0
+#define TX_POWER_LIMIT_TABLE_PATH	1
	struct mt7996_dev *dev = phy->dev;
	struct mt76_phy *mphy = phy->mt76;
+	struct ieee80211_hw *hw = mphy->hw;
	struct tx_power_limit_table_ctrl {
		u8 __rsv1[4];

@@ -4718,13 +5868,22 @@ int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy)
		.band_idx = phy->mt76->band_idx,
	};
	struct mt76_power_limits la = {};
+	struct mt76_power_path_limits la_path = {};
	struct sk_buff *skb;
-	int i, tx_power;
+	int i, ret, txpower_limit;

-	tx_power = mt76_get_power_bound(mphy, phy->txpower);
-	tx_power = mt76_get_rate_power_limits(mphy, mphy->chandef.chan,
-					      &la, tx_power);
-	mphy->txpower_cur = tx_power;
+	if (hw->conf.power_level == INT_MIN)
+		hw->conf.power_level = 127;
+	txpower_limit = mt7996_get_power_bound(phy, conf->txpower);
+
+	if (phy->sku_limit_en) {
+		txpower_limit = mt76_get_rate_power_limits(mphy, mphy->chandef.chan,
+							   &la, &la_path, txpower_limit);
+		mt7996_update_max_txpower_cur(phy, txpower_limit);
+	} else {
+		mt7996_update_max_txpower_cur(phy, txpower_limit);
+		return 0;
+	}

	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
				 sizeof(req) + MT7996_SKU_PATH_NUM);
@@ -4754,6 +5913,34 @@ int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy)
	/* padding */
	skb_put_zero(skb, MT7996_SKU_PATH_NUM - MT7996_SKU_RATE_NUM);

+	ret = mt76_mcu_skb_send_msg(&dev->mt76, skb,
+				    MCU_WM_UNI_CMD(TXPOWER), true);
+	if (ret)
+		return ret;
+
+	/* only set per-path power table when it's configured */
+	if (!phy->sku_path_en)
+		return 0;
+
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
+				 sizeof(req) + MT7996_SKU_PATH_NUM);
+	if (!skb)
+		return -ENOMEM;
+	req.power_limit_type = TX_POWER_LIMIT_TABLE_PATH;
+
+	skb_put_data(skb, &req, sizeof(req));
+	skb_put_data(skb, &la_path.cck, sizeof(la_path.cck));
+	skb_put_data(skb, &la_path.ofdm, sizeof(la_path.ofdm));
+	skb_put_data(skb, &la_path.ofdm_bf, sizeof(la_path.ofdm_bf));
+
+	for (i = 0; i < 32; i++) {
+		bool bf = i % 2;
+		u8 idx = i / 2;
+		s8 *buf = bf ? la_path.ru_bf[idx] : la_path.ru[idx];
+
+		skb_put_data(skb, buf, sizeof(la_path.ru[0]));
+	}
+
	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
				     MCU_WM_UNI_CMD(TXPOWER), true);
 }
@@ -4789,6 +5976,40 @@ int mt7996_mcu_cp_support(struct mt7996_dev *dev, u8 mode)
	phy->pp_mode = mode;

	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(PP),
				 &req, sizeof(req), false);
 }

+int mt7996_mcu_set_tx_power_ctrl(struct mt7996_phy *phy, u8 power_ctrl_id, u8 data)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct tx_power_ctrl req = {
+		.tag = cpu_to_le16(power_ctrl_id),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.power_ctrl_id = power_ctrl_id,
+		.band_idx = phy->mt76->band_idx,
+	};
+
+	switch (power_ctrl_id) {
+	case UNI_TXPOWER_SKU_POWER_LIMIT_CTRL:
+		req.sku_enable = !!data;
+		break;
+	case UNI_TXPOWER_PERCENTAGE_CTRL:
+		req.percentage_ctrl_enable = !!data;
+		break;
+	case UNI_TXPOWER_PERCENTAGE_DROP_CTRL:
+		req.power_drop_level = data;
+		break;
+	case UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL:
+		req.bf_backoff_enable = !!data;
+		break;
+	case UNI_TXPOWER_ATE_MODE_CTRL:
+		req.ate_mode_enable = !!data;
+		break;
+	default:
+		req.sku_enable = !!data;
+	}
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TXPOWER),
+				 &req, sizeof(req), false);
+}
+
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.h b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.h
index 49429ed2d166..e7277fad5de3 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.h
@@ -157,6 +171,16 @@ struct mt7996_mcu_eeprom {
	__le16 buf_len;
 } __packed;

+struct mt7996_mcu_eeprom_info {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+	__le32 addr;
+	__le32 valid;
+	u8 data[MT7996_EEPROM_BLOCK_SIZE];
+} __packed;
+
 struct mt7996_mcu_phy_rx_info {
	u8 category;
	u8 rate;
@@ -506,6 +573,13 @@ struct sta_rec_ba_uni {
	u8 __rsv[3];
 } __packed;

+struct sta_rec_tx_cap {
+	__le16 tag;
+	__le16 len;
+	u8 ampdu_limit_en;
+	u8 rsv[3];
+} __packed;
+
 struct sta_rec_eht {
	__le16 tag;
	__le16 len;
@@ -704,7 +778,23 @@ struct bf_sounding_on {
	__le32 snd_period;
 } __packed;

+enum sounding_mode {
+	SU_SOUNDING,
+	MU_SOUNDING,
+	SU_PERIODIC_SOUNDING,
+	MU_PERIODIC_SOUNDING,
+	BF_PROCESSING,
+	TXCMD_NONTB_SU_SOUNDING,
+	TXCMD_VHT_MU_SOUNDING,
+	TXCMD_TB_PER_BRP_SOUNDING,
+	TXCMD_TB_SOUNDING,
+
+	/* keep last */
+	NUM_SOUNDING_MODE,
+	SOUNDING_MODE_MAX = NUM_SOUNDING_MODE - 1,
+};
+
 struct bf_hw_en_status_update {
	__le16 tag;
	__le16 len;
 #define MT7996_BEACON_UPDATE_SIZE	(sizeof(struct bss_req_hdr) +		\
@@ -873,7 +999,8 @@ enum {
	UNI_EFUSE_BUFFER_MODE,
	UNI_EFUSE_FREE_BLOCK,
	UNI_EFUSE_BUFFER_RD,
+	UNI_EFUSE_PATCH,
 };

 enum {
	UNI_VOW_DRR_CTRL,
@@ -921,5 +1058,24 @@ enum {
	UNI_CMD_THERMAL_PROTECT_DUTY_CONFIG,
 };

+struct tx_power_ctrl {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+
+	u8 power_ctrl_id;
+	union {
+		bool sku_enable;
+		bool ate_mode_enable;
+		bool percentage_ctrl_enable;
+		bool bf_backoff_enable;
+		u8 show_info_category;
+		u8 power_drop_level;
+	};
+	u8 band_idx;
+	u8 rsv[1];
+} __packed;
+
 enum {
	UNI_TXPOWER_SKU_POWER_LIMIT_CTRL = 0,
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mmio.c b/drivers/net/wireless/mediatek/mt76/mt7996/mmio.c
index 2c44a8b1aefa..e732f4c587fe 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/mmio.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mmio.c
@@ -14,7 +14,7 @@
 #include "../trace.h"
 #include "../dma.h"

-static bool wed_enable;
+static bool wed_enable = true;
 module_param(wed_enable, bool, 0644);

 static const struct __base mt7996_reg_base[] = {
@@ -466,7 +466,8 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,

	dev->has_rro = true;

-	hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
+	if (dev->hif2)
+		hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);

	if (hif2)
		wed = &dev->mt76.mmio.wed_hif2;
@@ -488,10 +489,16 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
					     MT_TXQ_RING_BASE(0) +
					     MT7996_TXQ_BAND2 * MT_RING_SIZE;
		if (dev->has_rro) {
+			u8 rxq_id = is_mt7996(&dev->mt76) ?
+				    MT7996_RXQ_TXFREE2 : MT7996_RXQ_MCU_WA_EXT;
+
			wed->wlan.wpdma_txfree = wed->wlan.phy_base + hif1_ofs +
						 MT_RXQ_RING_BASE(0) +
-						 MT7996_RXQ_TXFREE2 * MT_RING_SIZE;
-			wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_EXT) - 1;
+						 rxq_id * MT_RING_SIZE;
+			if (is_mt7996(&dev->mt76))
+				wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_EXT) - 1;
+			else
+				wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_BAND1_EXT) - 1;
		} else {
			wed->wlan.wpdma_txfree = wed->wlan.phy_base + hif1_ofs +
						 MT_RXQ_RING_BASE(0) +
@@ -500,9 +507,9 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
		}

		wed->wlan.wpdma_rx_glo = wed->wlan.phy_base + hif1_ofs + MT_WFDMA0_GLO_CFG;
-		wed->wlan.wpdma_rx = wed->wlan.phy_base + hif1_ofs +
-				     MT_RXQ_RING_BASE(MT7996_RXQ_BAND0) +
-				     MT7996_RXQ_BAND0 * MT_RING_SIZE;
+		wed->wlan.wpdma_rx[0] = wed->wlan.phy_base + hif1_ofs +
+				     MT_RXQ_RING_BASE(MT7996_RXQ_BAND2) +
+				     MT7996_RXQ_BAND2 * MT_RING_SIZE;

		wed->wlan.id = MT7996_DEVICE_ID_2;
		wed->wlan.tx_tbit[0] = ffs(MT_INT_TX_DONE_BAND2) - 1;
@@ -515,16 +522,26 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,

		wed->wlan.wpdma_rx_glo = wed->wlan.phy_base + MT_WFDMA0_GLO_CFG;

-		wed->wlan.wpdma_rx = wed->wlan.phy_base +
+		wed->wlan.wpdma_rx[0] = wed->wlan.phy_base +
				     MT_RXQ_RING_BASE(MT7996_RXQ_BAND0) +
				     MT7996_RXQ_BAND0 * MT_RING_SIZE;

		wed->wlan.wpdma_rx_rro[0] = wed->wlan.phy_base +
					    MT_RXQ_RING_BASE(MT7996_RXQ_RRO_BAND0) +
					    MT7996_RXQ_RRO_BAND0 * MT_RING_SIZE;
-		wed->wlan.wpdma_rx_rro[1] = wed->wlan.phy_base + hif1_ofs +
-					    MT_RXQ_RING_BASE(MT7996_RXQ_RRO_BAND2) +
-					    MT7996_RXQ_RRO_BAND2 * MT_RING_SIZE;
+		if (is_mt7996(&dev->mt76)) {
+			wed->wlan.wpdma_rx_rro[1] = wed->wlan.phy_base + hif1_ofs +
+						    MT_RXQ_RING_BASE(MT7996_RXQ_RRO_BAND2) +
+						    MT7996_RXQ_RRO_BAND2 * MT_RING_SIZE;
+		} else {
+			wed->wlan.wpdma_rx_rro[1] = wed->wlan.phy_base + hif1_ofs +
+						    MT_RXQ_RING_BASE(MT7996_RXQ_RRO_BAND1) +
+						    MT7996_RXQ_RRO_BAND1 * MT_RING_SIZE;
+			wed->wlan.wpdma_rx[1] = wed->wlan.phy_base + hif1_ofs +
+						MT_RXQ_RING_BASE(MT7996_RXQ_BAND1) +
+						MT7996_RXQ_BAND1 * MT_RING_SIZE;
+		}
+
		wed->wlan.wpdma_rx_pg = wed->wlan.phy_base +
					MT_RXQ_RING_BASE(MT7996_RXQ_MSDU_PG_BAND0) +
					MT7996_RXQ_MSDU_PG_BAND0 * MT_RING_SIZE;
@@ -534,10 +551,14 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
		wed->wlan.rx_size = SKB_WITH_OVERHEAD(MT_RX_BUF_SIZE);

		wed->wlan.rx_tbit[0] = ffs(MT_INT_RX_DONE_BAND0) - 1;
-		wed->wlan.rx_tbit[1] = ffs(MT_INT_RX_DONE_BAND2) - 1;
-
		wed->wlan.rro_rx_tbit[0] = ffs(MT_INT_RX_DONE_RRO_BAND0) - 1;
-		wed->wlan.rro_rx_tbit[1] = ffs(MT_INT_RX_DONE_RRO_BAND2) - 1;
+		if (is_mt7996(&dev->mt76)) {
+			wed->wlan.rx_tbit[1] = ffs(MT_INT_RX_DONE_BAND2) - 1;
+			wed->wlan.rro_rx_tbit[1] = ffs(MT_INT_RX_DONE_RRO_BAND2) - 1;
+		} else {
+			wed->wlan.rx_tbit[1] = ffs(MT_INT_RX_DONE_BAND1) - 1;
+			wed->wlan.rro_rx_tbit[1] = ffs(MT_INT_RX_DONE_RRO_BAND1) - 1;
+		}

		wed->wlan.rx_pg_tbit[0] = ffs(MT_INT_RX_DONE_MSDU_PG_BAND0) - 1;
		wed->wlan.rx_pg_tbit[1] = ffs(MT_INT_RX_DONE_MSDU_PG_BAND1) - 1;
@@ -545,20 +566,28 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,

		wed->wlan.tx_tbit[0] = ffs(MT_INT_TX_DONE_BAND0) - 1;
		wed->wlan.tx_tbit[1] = ffs(MT_INT_TX_DONE_BAND1) - 1;
-		if (dev->has_rro) {
-			wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
-						 MT7996_RXQ_TXFREE0 * MT_RING_SIZE;
-			wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_MAIN) - 1;
+		if (is_mt7996(&dev->mt76)) {
+			if (dev->has_rro) {
+				wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
+							 MT7996_RXQ_TXFREE0 * MT_RING_SIZE;
+				wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_MAIN) - 1;
+			} else {
+				wed->wlan.txfree_tbit = ffs(MT_INT_RX_DONE_WA_MAIN) - 1;
+				wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
+							 MT7996_RXQ_MCU_WA_MAIN * MT_RING_SIZE;
+			}
		} else {
			wed->wlan.txfree_tbit = ffs(MT_INT_RX_DONE_WA_MAIN) - 1;
			wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
-						  MT7996_RXQ_MCU_WA_MAIN * MT_RING_SIZE;
+						 MT7996_RXQ_MCU_WA_MAIN * MT_RING_SIZE;
		}
		dev->mt76.rx_token_size = MT7996_TOKEN_SIZE + wed->wlan.rx_npkt;
+		if(dev->hif2 && is_mt7992(&dev->mt76))
+			wed->wlan.id = 0x7992;
	}

-	wed->wlan.nbuf = MT7996_HW_TOKEN_SIZE;
-	wed->wlan.token_start = MT7996_TOKEN_SIZE - wed->wlan.nbuf;
+	wed->wlan.nbuf = MT7996_TOKEN_SIZE;
+	wed->wlan.token_start = 0;

	wed->wlan.amsdu_max_subframes = 8;
	wed->wlan.amsdu_max_len = 1536;
@@ -582,6 +611,8 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
	*irq = wed->irq;
	dev->mt76.dma_dev = wed->dev;

+	dev->mt76.token_size = MT7996_SW_TOKEN_SIZE;
+
	return 1;
 #else
	return 0;
@@ -655,10 +686,9 @@ void mt7996_dual_hif_set_irq_mask(struct mt7996_dev *dev, bool write_reg,
		if (mtk_wed_device_active(&mdev->mmio.wed)) {
			mtk_wed_device_irq_set_mask(&mdev->mmio.wed,
						    mdev->mmio.irqmask);
-			if (mtk_wed_device_active(&mdev->mmio.wed_hif2)) {
+			if (mtk_wed_device_active(&mdev->mmio.wed_hif2))
				mtk_wed_device_irq_set_mask(&mdev->mmio.wed_hif2,
							    mdev->mmio.irqmask);
-			}
		} else {
			mt76_wr(dev, MT_INT_MASK_CSR, mdev->mmio.irqmask);
			mt76_wr(dev, MT_INT1_MASK_CSR, mdev->mmio.irqmask);
@@ -690,12 +720,18 @@ static void mt7996_irq_tasklet(struct tasklet_struct *t)
					       dev->mt76.mmio.irqmask);
		if (intr1 & MT_INT_RX_TXFREE_EXT)
			napi_schedule(&dev->mt76.napi[MT_RXQ_TXFREE_BAND2]);
+
+		if (intr1 & MT_INT_RX_DONE_BAND2_EXT)
+			napi_schedule(&dev->mt76.napi[MT_RXQ_BAND2]);
+
+		if (is_mt7992(&dev->mt76) && (intr1 & MT_INT_RX_TXFREE_BAND1_EXT))
+			napi_schedule(&dev->mt76.napi[MT_RXQ_BAND1_WA]);
	}

	if (mtk_wed_device_active(wed)) {
		mtk_wed_device_irq_set_mask(wed, 0);
		intr = mtk_wed_device_irq_get(wed, dev->mt76.mmio.irqmask);
-		intr |= (intr1 & ~MT_INT_RX_TXFREE_EXT);
+		intr |= (intr1 & ~MT_INT_TX_RX_DONE_EXT);
	} else {
		mt76_wr(dev, MT_INT_MASK_CSR, 0);
		if (dev->hif2)
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h b/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h
index c75189a02316..58fee1c66ccb 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h
@@ -40,38 +42,51 @@
 #define MT7996_FIRMWARE_WA		"mediatek/mt7996/mt7996_wa.bin"
 #define MT7996_FIRMWARE_WM		"mediatek/mt7996/mt7996_wm.bin"
 #define MT7996_FIRMWARE_DSP		"mediatek/mt7996/mt7996_dsp.bin"
+#define MT7996_FIRMWARE_WM_TM		"mediatek/mt7996/mt7996_wm_tm.bin"
 #define MT7996_ROM_PATCH		"mediatek/mt7996/mt7996_rom_patch.bin"

 #define MT7996_FIRMWARE_WA_233		"mediatek/mt7996/mt7996_wa_233.bin"
 #define MT7996_FIRMWARE_WM_233		"mediatek/mt7996/mt7996_wm_233.bin"
 #define MT7996_FIRMWARE_DSP_233		MT7996_FIRMWARE_DSP
+#define MT7996_FIRMWARE_WM_TM_233	"mediatek/mt7996/mt7996_wm_tm_233.bin"
 #define MT7996_ROM_PATCH_233		"mediatek/mt7996/mt7996_rom_patch_233.bin"

 #define MT7992_FIRMWARE_WA		"mediatek/mt7996/mt7992_wa.bin"
 #define MT7992_FIRMWARE_WM		"mediatek/mt7996/mt7992_wm.bin"
 #define MT7992_FIRMWARE_DSP		"mediatek/mt7996/mt7992_dsp.bin"
+#define MT7992_FIRMWARE_WM_TM		"mediatek/mt7996/mt7992_wm_tm.bin"
 #define MT7992_ROM_PATCH		"mediatek/mt7996/mt7992_rom_patch.bin"

 #define MT7992_FIRMWARE_WA_23		"mediatek/mt7996/mt7992_wa_23.bin"
 #define MT7992_FIRMWARE_WM_23		"mediatek/mt7996/mt7992_wm_23.bin"
 #define MT7992_FIRMWARE_DSP_23		"mediatek/mt7996/mt7992_dsp_23.bin"
+#define MT7992_FIRMWARE_WM_TM_23	"mediatek/mt7996/mt7992_wm_tm_23.bin"
 #define MT7992_ROM_PATCH_23		"mediatek/mt7996/mt7992_rom_patch_23.bin"

+#define MT7992_FIRMWARE_WA_24		"mediatek/mt7996/mt7992_wa_24.bin"
+#define MT7992_FIRMWARE_WM_24		"mediatek/mt7996/mt7992_wm_24.bin"
+#define MT7992_FIRMWARE_DSP_24		"mediatek/mt7996/mt7992_dsp_24.bin"
+#define MT7992_FIRMWARE_WM_TM_24	"mediatek/mt7996/mt7992_wm_tm_24.bin"
+#define MT7992_ROM_PATCH_24		"mediatek/mt7996/mt7992_rom_patch_24.bin"
+
 #define MT7990_FIRMWARE_WA		""
 #define MT7990_FIRMWARE_WM		"mediatek/mt7996/mt7990_wm.bin"
 #define MT7990_FIRMWARE_DSP		""
+#define MT7990_FIRMWARE_WM_TM           "mediatek/mt7996/mt7990_wm_tm.bin"
 #define MT7990_ROM_PATCH		"mediatek/mt7996/mt7990_rom_patch.bin"

 #define MT7996_EEPROM_DEFAULT		"mediatek/mt7996/mt7996_eeprom.bin"
 #define MT7996_EEPROM_DEFAULT_INT	"mediatek/mt7996/mt7996_eeprom_2i5i6i.bin"
 #define MT7996_EEPROM_DEFAULT_233	"mediatek/mt7996/mt7996_eeprom_233.bin"
 #define MT7996_EEPROM_DEFAULT_233_INT	"mediatek/mt7996/mt7996_eeprom_233_2i5i6i.bin"
+#define MT7996_EEPROM_DEFAULT_404	"mediatek/mt7996/mt7996_eeprom_dual_404.bin"

 #define MT7992_EEPROM_DEFAULT		"mediatek/mt7996/mt7992_eeprom.bin"
 #define MT7992_EEPROM_DEFAULT_INT	"mediatek/mt7996/mt7992_eeprom_2i5i.bin"
 #define MT7992_EEPROM_DEFAULT_MIX	"mediatek/mt7996/mt7992_eeprom_2i5e.bin"
 #define MT7992_EEPROM_DEFAULT_23	"mediatek/mt7996/mt7992_eeprom_23.bin"
 #define MT7992_EEPROM_DEFAULT_23_INT	"mediatek/mt7996/mt7992_eeprom_23_2i5i.bin"
+#define MT7992_EEPROM_DEFAULT_24	"mediatek/mt7996/mt7992_eeprom_24_2i5i.bin"

 #define MT7990_EEPROM_DEFAULT		"mediatek/mt7996/mt7990_eeprom.bin"
 #define MT7990_EEPROM_DEFAULT_INT	"mediatek/mt7996/mt7990_eeprom_2i5i.bin"
@@ -125,7 +144,11 @@
 #define MT7996_DRR_STA_AC2_QNTM_MASK	GENMASK(18, 16)
 #define MT7996_DRR_STA_AC3_QNTM_MASK	GENMASK(22, 20)

+/* RRO 3.1 */
+#define MT7996_RRO_MSDU_PG_CR_CNT 8
+#define MT7996_RRO_MSDU_PG_SIZE_PER_CR 0x10000
+
 #define to_rssi(field, rcpi)	((FIELD_GET(field, rcpi) - 220) / 2)

 #define MT7996_MAX_BEACON_LOSS		20
 #define MT7996_MAX_PROBE_TIMEOUT	500
@@ -132,11 +167,13 @@ struct mt7996_dfs_pattern;
 enum mt7996_var_type {
	MT7996_VAR_TYPE_444,
	MT7996_VAR_TYPE_233,
+	MT7996_VAR_TYPE_404,
 };

 enum mt7992_var_type {
	MT7992_VAR_TYPE_44,
	MT7992_VAR_TYPE_23,
+	MT7992_VAR_TYPE_24,
 };

 enum mt7990_var_type {
@@ -175,20 +222,23 @@ enum mt7996_rxq_id {
	MT7996_RXQ_BAND1 = 5, /* for mt7992 */
	MT7996_RXQ_BAND2 = 5,
	MT7996_RXQ_RRO_BAND0 = 8,
-	MT7996_RXQ_RRO_BAND1 = 8,/* unused */
+	MT7996_RXQ_RRO_BAND1 = 9,
	MT7996_RXQ_RRO_BAND2 = 6,
	MT7996_RXQ_MSDU_PG_BAND0 = 10,
	MT7996_RXQ_MSDU_PG_BAND1 = 11,
 struct mt7996_sta_link {
	struct mt76_wcid wcid; /* must be first */

	struct mt7996_sta *sta;

	struct list_head rc_list;

	s8 chain_signal[IEEE80211_MAX_CHAINS];
        int signal;
+        struct ewma_avg_signal chain_signal_avg[IEEE80211_MAX_CHAINS];
+        struct ewma_avg_signal signal_avg;
+
	int ack_signal;
        s8 chain_ack_signal[IEEE80211_MAX_CHAINS];
	struct ewma_avg_signal avg_ack_signal;

	s8 chain_ack_snr[IEEE80211_MAX_CHAINS];

	unsigned long changed;

	struct mt76_connac_sta_key_conf bip;
@@ -267,3 +442,7 @@ struct mt7996_hif {
	struct device *dev;
	void __iomem *regs;
	int irq;
+	enum pci_bus_speed speed;
+	enum pcie_link_width width;
+};
+
struct mt7996_scs_ctrl {
	u8 scs_enable;
	s8 sta_min_rssi;
@@ -310,10 +586,14 @@ struct mt7996_phy {

	struct mt76_mib_stats mib;
	struct mt76_channel_state state_ts;
+	struct delayed_work ipi_work;

	u16 orig_chainmask;
	u16 orig_antenna_mask;

	bool has_aux_rx;
	bool counter_reset;
+
+	u8 pp_mode;
	u16 punct_bitmap;
+
	struct mt7996_scs_ctrl scs_ctrl;
+	u32 red_drop;

	bool sku_limit_en;
	bool sku_path_en;

@@ -389,23 +724,44 @@ struct mt7996_dev {
			void *ptr;
			dma_addr_t phy_addr;
		} session;
+		struct {
+			void *ptr;
+			dma_addr_t phy_addr;
+		} msdu_pg[MT7996_RRO_MSDU_PG_CR_CNT];

		struct work_struct work;
		struct list_head poll_list;
		spinlock_t lock;
+
+		struct list_head pg_addr_cache;
+		struct list_head pg_hash_head[MT7996_RRO_MSDU_PG_HASH_SIZE];
	} wed_rro;

+	bool testmode_enable;
+	bool bin_file_mode;
+	u8 eeprom_mode;
+	u32 bg_nxt_freq;
+
+	u32 option_type;
+
	bool ibf;
	u8 fw_debug_wm;
	u8 fw_debug_wa;
	u8 fw_debug_bin;
	u16 fw_debug_seq;
	bool fw_debug_muru_disable;
	bool idxlog_enable;

	struct dentry *debugfs_dir;
	struct rchan *relay_fwlog;
	struct rchan *relay_idxlog;
+
+	void *cal;
+	u32 cur_prek_offset;
+	struct {
+		const u32 *rev;
+		u8 dpd_ch_num[DPD_CH_NUM_TYPE_MAX];
+	} prek;

	struct {
		u16 table_mask;
@@ -499,9 +900,12 @@ mt7996_band_valid(struct mt7996_dev *dev, u8 band)
	if (!is_mt7996(&dev->mt76))
		return band <= MT_BAND1;

+	if (dev->var.type == MT7996_VAR_TYPE_404 && band == MT_BAND1)
+		return false;
+
	return band <= MT_BAND2;
 }

 static inline struct mt7996_phy *
 mt7996_band_phy(struct mt7996_dev *dev, enum nl80211_band band)
 {
@@ -546,10 +959,12 @@ mt7996_vif_conf_link(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 extern const struct ieee80211_ops mt7996_ops;
 extern struct pci_driver mt7996_pci_driver;
 extern struct pci_driver mt7996_hif_driver;
+extern const struct mt76_testmode_ops mt7996_testmode_ops;

 struct mt7996_dev *mt7996_mmio_probe(struct device *pdev,
				     void __iomem *mem_base, u32 device_id);
 void mt7996_wfsys_reset(struct mt7996_dev *dev);
+void mt7996_rro_hw_init(struct mt7996_dev *dev);
 irqreturn_t mt7996_irq_handler(int irq, void *dev_instance);
 u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_vif_link *link);
 int mt7996_register_device(struct mt7996_dev *dev);
@@ -560,7 +975,9 @@ int mt7996_vif_link_add(struct mt76_phy *mphy, struct ieee80211_vif *vif,
 void mt7996_vif_link_remove(struct mt76_phy *mphy, struct ieee80211_vif *vif,
			    struct ieee80211_bss_conf *link_conf,
			    struct mt76_vif_link *mlink);
+const char *mt7996_eeprom_name(struct mt7996_dev *dev);
 int mt7996_eeprom_init(struct mt7996_dev *dev);
+int mt7996_eeprom_check_fw_mode(struct mt7996_dev *dev);
 int mt7996_eeprom_parse_hw_cap(struct mt7996_dev *dev, struct mt7996_phy *phy);
 int mt7996_eeprom_get_target_power(struct mt7996_dev *dev,
				   struct ieee80211_channel *chan);
@@ -575,6 +992,7 @@ int mt7996_init_tx_queues(struct mt7996_phy *phy, int idx,
			  int n_desc, int ring_base, struct mtk_wed_device *wed);
 void mt7996_init_txpower(struct mt7996_phy *phy);
 int mt7996_txbf_init(struct mt7996_dev *dev);
+int mt7996_get_chip_sku(struct mt7996_dev *dev);
 void mt7996_reset(struct mt7996_dev *dev);
 void mt7996_coredump(struct mt7996_dev *dev, u8 state);
 int mt7996_run(struct mt7996_phy *phy);
@@ -653,5 +1072,6 @@ int mt7996_mcu_get_chan_mib_info(struct mt7996_phy *phy, bool chan_switch);
 int mt7996_mcu_get_temperature(struct mt7996_phy *phy);
 int mt7996_mcu_set_thermal_throttling(struct mt7996_phy *phy, u8 state);
 int mt7996_mcu_set_thermal_protect(struct mt7996_phy *phy, bool enable);
-int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy);
+int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy,
+			       struct ieee80211_bss_conf *conf);
 int mt7996_mcu_rdd_cmd(struct mt7996_dev *dev, int cmd, u8 rdd_idx, u8 val);
@@ -663,2 +1085,9 @@ int mt7996_mcu_rf_regval(struct mt7996_dev *dev, u32 regidx, u32 *val, bool set)
 int mt7996_mcu_wed_rro_reset_sessions(struct mt7996_dev *dev, u16 id);
 int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled);
+int mt7996_mcu_set_tx_power_ctrl(struct mt7996_phy *phy, u8 power_ctrl_id, u8 data);
+int mt7996_mcu_get_tx_power_info(struct mt7996_phy *phy, u8 category, void *event);
+int mt7996_mcu_apply_group_cal(struct mt7996_dev *dev);
+int mt7996_mcu_apply_tx_dpd(struct mt7996_phy *phy);
+#ifdef CONFIG_NL80211_TESTMODE
+void mt7996_tm_rf_test_event(struct mt7996_dev *dev, struct sk_buff *skb);
+#endif
int mt7996_mcu_set_scs(struct mt7996_phy *phy, u8 enable);
void mt7996_mcu_scs_sta_poll(struct work_struct *work);
int mt7996_mcu_set_band_confg(struct mt7996_phy *phy, u16 option, bool enable);
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mt7996_trace.h b/drivers/net/wireless/mediatek/mt76/mt7996/mt7996_trace.h
new file mode 100644
index 000000000000..c19f24cd9abf
--- /dev/null
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mt7996_trace.h
@@ -0,0 +1,141 @@
+/* SPDX-License-Identifier: ISC */
+/*
+ * Copyright (C) 2022 MediaTek Inc.
+ */
+
+#if !defined(__MT7996_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)
+#define __MT7996_TRACE_H
+
+#include <linux/types.h>
+#include <linux/tracepoint.h>
+#include "mt7996.h"
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM mt7996
+
+#define MAXNAME		32
+#define DEV_ENTRY	__array(char, wiphy_name, 32)
+#define DEV_ASSIGN(_w)	strscpy(__entry->wiphy_name, wiphy_name(_w), MAXNAME)
+#define DEV_PR_FMT	"%s"
+#define DEV_PR_ARG	__entry->wiphy_name
+
+DECLARE_EVENT_CLASS(mt7996_mcu_debug,
+	TP_PROTO(struct mt7996_dev *dev, bool uni, u8 id, u8 ext_id,
+		 const void *data, size_t len),
+	TP_ARGS(dev, uni, id, ext_id, data, len),
+	TP_STRUCT__entry(
+		__field(bool, uni)
+		__field(u8, id)
+		__field(u8, ext_id)
+		__field(size_t, len)
+		__dynamic_array(u8, data, len)
+	),
+	TP_fast_assign(
+		__entry->uni = uni;
+		__entry->id = id;
+		__entry->ext_id = ext_id;
+		__entry->len = len;
+		memcpy(__get_dynamic_array(data), data, len);
+	),
+	TP_printk(
+		"uni: %d, id: %u, ext_id: %u, len: %zu",
+		__entry->uni,
+		__entry->id,
+		__entry->ext_id,
+		__entry->len
+	)
+);
+
+DEFINE_EVENT(mt7996_mcu_debug, mt7996_mcu_cmd,
+	TP_PROTO(struct mt7996_dev *dev, bool uni, u8 id, u8 ext_id,
+		 const void *data, size_t len),
+	TP_ARGS(dev, uni, id, ext_id, data, len)
+);
+
+DEFINE_EVENT(mt7996_mcu_debug, mt7996_mcu_event,
+	TP_PROTO(struct mt7996_dev *dev, bool uni, u8 id, u8 ext_id,
+		 const void *data, size_t len),
+	TP_ARGS(dev, uni, id, ext_id, data, len)
+);
+
+TRACE_EVENT(mt7996_tx_prepare,
+	TP_PROTO(struct mt7996_dev *dev, struct mt76_wcid *wcid, enum mt76_txq_id qid,
+		 const void *txwi, const void *data, size_t len),
+	TP_ARGS(dev, wcid, qid, txwi, data, len),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(u16, wcid)
+		__field(u8, qid)
+		__array(u8, txwi, MT_TXD_SIZE)
+		__field(size_t, len)
+		__dynamic_array(u8, data, len)
+	),
+
+	TP_fast_assign(
+		DEV_ASSIGN(dev->mt76.phys[wcid->phy_idx]->hw->wiphy);
+		__entry->wcid = wcid->idx;
+		__entry->qid = qid;
+		memcpy(__entry->txwi, txwi, MT_TXD_SIZE);
+		__entry->len = len;
+		memcpy(__get_dynamic_array(data), data, len);
+	),
+
+	TP_printk(
+		DEV_PR_FMT " wcid: %u, qid: %u, len: %zu",
+		DEV_PR_ARG, __entry->wcid, __entry->qid, __entry->len
+	)
+);
+
+TRACE_EVENT(mt7996_fill_rx,
+	TP_PROTO(struct mt7996_phy *phy, const void *data, size_t len),
+	TP_ARGS(phy, data, len),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(size_t, len)
+		__dynamic_array(u8, data, len)
+	),
+
+	TP_fast_assign(
+		DEV_ASSIGN(phy->mt76->hw->wiphy);
+		__entry->len = len;
+		memcpy(__get_dynamic_array(data), data, len);
+	),
+
+	TP_printk(
+		DEV_PR_FMT " len: %zu",
+		DEV_PR_ARG, __entry->len
+	)
+);
+
+TRACE_EVENT(mt7996_fill_rx_done,
+	TP_PROTO(struct mt7996_phy *phy, u16 seqno, u16 hdr_gap),
+	TP_ARGS(phy, seqno, hdr_gap),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(u16, seqno)
+		__field(u16, hdr_gap)
+	),
+
+	TP_fast_assign(
+		DEV_ASSIGN(phy->mt76->hw->wiphy);
+		__entry->seqno = seqno;
+		__entry->hdr_gap = hdr_gap;
+	),
+
+	TP_printk(
+		DEV_PR_FMT " seqno: %u, hdr_gap: %u",
+		DEV_PR_ARG, __entry->seqno, __entry->hdr_gap
+	)
+);
+
+#endif
+
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH .
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_FILE mt7996_trace
+
+#include <trace/define_trace.h>
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/pci.c b/drivers/net/wireless/mediatek/mt76/mt7996/pci.c
index 19e99bc1c6c4..4465f37c0eae 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/pci.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/pci.c
@@ -5,12 +5,14 @@

 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/pci.h>

 #include "mt7996.h"
 #include "mac.h"
 #include "../trace.h"

+static bool hif2_enable = false;
+module_param(hif2_enable, bool, 0644);
+
 static LIST_HEAD(hif_list);
 static DEFINE_SPINLOCK(hif_lock);
 static u32 hif_idx;
@@ -65,6 +67,9 @@ static struct mt7996_hif *mt7996_pci_init_hif2(struct pci_dev *pdev)
 {
	hif_idx++;

+	if (!hif2_enable)
+		return NULL;
+
	if (!pci_get_device(PCI_VENDOR_ID_MEDIATEK, MT7996_DEVICE_ID_2, NULL) &&
	    !pci_get_device(PCI_VENDOR_ID_MEDIATEK, MT7992_DEVICE_ID_2, NULL) &&
	    !pci_get_device(PCI_VENDOR_ID_MEDIATEK, MT7990_DEVICE_ID_2, NULL))
@@ -80,6 +85,9 @@ static int mt7996_pci_hif2_probe(struct pci_dev *pdev)
 {
	struct mt7996_hif *hif;

+	if (!hif2_enable)
+		return 0;
+
	hif = devm_kzalloc(&pdev->dev, sizeof(*hif), GFP_KERNEL);
	if (!hif)
		return -ENOMEM;
@@ -87,6 +95,7 @@ static int mt7996_pci_hif2_probe(struct pci_dev *pdev)
	hif->dev = &pdev->dev;
	hif->regs = pcim_iomap_table(pdev)[0];
	hif->irq = pdev->irq;
+	pcie_bandwidth_available(pdev, NULL, &hif->speed, &hif->width);
	spin_lock_bh(&hif_lock);
	list_add(&hif->list, &hif_list);
	spin_unlock_bh(&hif_lock);
@@ -101,9 +110,11 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
	struct pci_dev *hif2_dev;
	struct mt7996_hif *hif2;
	struct mt7996_dev *dev;
-	int irq, hif2_irq, ret;
+	int irq, ret;
	struct mt76_dev *mdev;

+	hif2_enable |= (id->device == 0x7990 || id->device == 0x7991 || id->device == 0x799a);
+
	ret = pcim_enable_device(pdev);
	if (ret)
		return ret;
@@ -137,6 +148,8 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
	mdev = &dev->mt76;
	mt7996_wfsys_reset(dev);
	hif2 = mt7996_pci_init_hif2(pdev);
+	if (hif2)
+		dev->hif2 = hif2;

	ret = mt7996_mmio_wed_init(dev, pdev, false, &irq);
	if (ret < 0)
@@ -161,11 +174,12 @@ static int mt7996_pci_probe(struct pci_dev *pdev,

	if (hif2) {
		hif2_dev = container_of(hif2->dev, struct pci_dev, dev);
-		dev->hif2 = hif2;
+		ret = 0;
+
+		ret = mt7996_mmio_wed_init(dev, hif2_dev, true, &irq);

-		ret = mt7996_mmio_wed_init(dev, hif2_dev, true, &hif2_irq);
		if (ret < 0)
-			goto free_hif2_wed_irq_vector;
+			goto free_wed_or_irq_vector;

		if (!ret) {
			ret = pci_alloc_irq_vectors(hif2_dev, 1, 1,
@@ -174,14 +188,15 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
				goto free_hif2;

			dev->hif2->irq = hif2_dev->irq;
-			hif2_irq = dev->hif2->irq;
+		} else {
+			dev->hif2->irq = irq;
		}

-		ret = devm_request_irq(mdev->dev, hif2_irq, mt7996_irq_handler,
-				       IRQF_SHARED, KBUILD_MODNAME "-hif",
-				       dev);
+		ret = devm_request_irq(mdev->dev, dev->hif2->irq,
+				       mt7996_irq_handler, IRQF_SHARED,
+				       KBUILD_MODNAME "-hif", dev);
		if (ret)
-			goto free_hif2_wed_irq_vector;
+			goto free_hif2_irq_vector;

		mt76_wr(dev, MT_INT1_MASK_CSR, 0);
		/* master switch of PCIe tnterrupt enable */
@@ -196,8 +211,8 @@ static int mt7996_pci_probe(struct pci_dev *pdev,

 free_hif2_irq:
	if (dev->hif2)
-		devm_free_irq(mdev->dev, hif2_irq, dev);
-free_hif2_wed_irq_vector:
+		devm_free_irq(mdev->dev, dev->hif2->irq, dev);
+free_hif2_irq_vector:
	if (dev->hif2) {
		if (mtk_wed_device_active(&dev->mt76.mmio.wed_hif2))
			mtk_wed_device_detach(&dev->mt76.mmio.wed_hif2);
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/regs.h b/drivers/net/wireless/mediatek/mt76/mt7996/regs.h
index e942c0058731..fcf0e50414d2 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/regs.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/regs.h
@@ -88,6 +88,8 @@ enum offs_rev {
 #define MT_RRO_BA_BITMAP_BASE1			MT_RRO_TOP(0xC)
 #define WF_RRO_AXI_MST_CFG			MT_RRO_TOP(0xB8)
 #define WF_RRO_AXI_MST_CFG_DIDX_OK		BIT(12)
+
+#define MT_RRO_ADDR_ARRAY_BASE0			MT_RRO_TOP(0x30)
 #define MT_RRO_ADDR_ARRAY_BASE1			MT_RRO_TOP(0x34)
 #define MT_RRO_ADDR_ARRAY_ELEM_ADDR_SEG_MODE	BIT(31)

@@ -108,6 +110,14 @@ enum offs_rev {

 #define MT_RRO_ADDR_ELEM_SEG_ADDR0		MT_RRO_TOP(0x400)

+#define MT_RRO_3_0_EMU_CONF			MT_RRO_TOP(0x600)
+#define MT_RRO_3_0_EMU_CONF_EN_MASK		BIT(11)
+
+#define MT_RRO_3_1_GLOBAL_CONFIG		MT_RRO_TOP(0x604)
+#define MT_RRO_3_1_GLOBAL_CONFIG_INTERLEAVE_EN	BIT(0)
+
+#define MT_RRO_MSDU_PG_SEG_ADDR0		MT_RRO_TOP(0x620)
+
 #define MT_RRO_ACK_SN_CTRL			MT_RRO_TOP(0x50)
 #define MT_RRO_ACK_SN_CTRL_SN_MASK		GENMASK(27, 16)
 #define MT_RRO_ACK_SN_CTRL_SESSION_MASK		GENMASK(11, 0)
@@ -340,6 +352,9 @@ enum offs_rev {
 #define MT_ARB_SCR_TX_DISABLE			BIT(8)
 #define MT_ARB_SCR_RX_DISABLE			BIT(9)

+#define MT_ARB_TQSAXM0(_band)			MT_WF_ARB(_band, 0x180)
+#define MT_ARB_TQSAXM_ALTX_START_MASK		GENMASK(12, 8)
+
 /* RMAC: band 0(0x820e5000), band 1(0x820f5000), band 2(0x830e5000), */
 #define MT_WF_RMAC_BASE(_band)			__BASE(WF_RMAC_BASE, (_band))
 #define MT_WF_RMAC(_band, ofs)			(MT_WF_RMAC_BASE(_band) + (ofs))
@@ -412,7 +427,9 @@ enum offs_rev {

 #define MT_WFDMA0_RX_INT_PCIE_SEL		MT_WFDMA0(0x154)
 #define MT_WFDMA0_RX_INT_SEL_RING3		BIT(3)
+#define MT_WFDMA0_RX_INT_SEL_RING5		BIT(5)
 #define MT_WFDMA0_RX_INT_SEL_RING6		BIT(6)
+#define MT_WFDMA0_RX_INT_SEL_RING9		BIT(9)

 #define MT_WFDMA0_MCU_HOST_INT_ENA		MT_WFDMA0(0x1f4)

@@ -432,6 +449,7 @@ enum offs_rev {
 #define WF_WFDMA0_GLO_CFG_EXT0			MT_WFDMA0(0x2b0)
 #define WF_WFDMA0_GLO_CFG_EXT0_RX_WB_RXD	BIT(18)
 #define WF_WFDMA0_GLO_CFG_EXT0_WED_MERGE_MODE	BIT(14)
+#define WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK	GENMASK(27, 24)

 #define WF_WFDMA0_GLO_CFG_EXT1			MT_WFDMA0(0x2b4)
 #define WF_WFDMA0_GLO_CFG_EXT1_CALC_MODE	BIT(31)
@@ -451,6 +469,8 @@ enum offs_rev {

 #define MT_WFDMA_HOST_CONFIG			MT_WFDMA_EXT_CSR(0x30)
 #define MT_WFDMA_HOST_CONFIG_PDMA_BAND		BIT(0)
+#define MT_WFDMA_HOST_CONFIG_BAND0_PCIE1	BIT(20)
+#define MT_WFDMA_HOST_CONFIG_BAND1_PCIE1	BIT(21)
 #define MT_WFDMA_HOST_CONFIG_BAND2_PCIE1	BIT(22)

 #define MT_WFDMA_EXT_CSR_HIF_MISC		MT_WFDMA_EXT_CSR(0x44)
@@ -459,6 +479,9 @@ enum offs_rev {
 #define MT_WFDMA_AXI_R2A_CTRL			MT_WFDMA_EXT_CSR(0x500)
 #define MT_WFDMA_AXI_R2A_CTRL_OUTSTAND_MASK	GENMASK(4, 0)

+#define MT_WFDMA_AXI_R2A_CTRL2			MT_WFDMA_EXT_CSR(0x508)
+#define MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK	GENMASK(31, 28)
+
 #define MT_PCIE_RECOG_ID			0xd7090
 #define MT_PCIE_RECOG_ID_MASK			GENMASK(30, 0)
 #define MT_PCIE_RECOG_ID_SEM			BIT(31)
@@ -514,7 +537,9 @@ enum offs_rev {
 #define MT_INT_RX_DONE_WA_EXT			BIT(3) /* for mt7992 */
 #define MT_INT_RX_DONE_WA_TRI			BIT(3)
 #define MT_INT_RX_TXFREE_MAIN			BIT(17)
+#define MT_INT_RX_TXFREE_BAND1			BIT(15)
 #define MT_INT_RX_TXFREE_TRI			BIT(15)
+#define MT_INT_RX_TXFREE_BAND1_EXT		BIT(19) /* for mt7992 two PCIE*/
 #define MT_INT_RX_TXFREE_BAND0_MT7990		BIT(14)
 #define MT_INT_RX_TXFREE_BAND1_MT7990		BIT(15)
 #define MT_INT_RX_DONE_BAND2_EXT		BIT(23)
@@ -722,25 +748,30 @@ enum offs_rev {
						 ((_wf) << 16) + (ofs))
 #define MT_WF_PHYRX_CSD_IRPI(_band, _wf)	MT_WF_PHYRX_CSD(_band, _wf, 0x1000)

-/* PHYRX CTRL */
-#define MT_WF_PHYRX_BAND_BASE			0x83080000
-#define MT_WF_PHYRX_BAND(_band, ofs)		(MT_WF_PHYRX_BAND_BASE + \
+/* PHYDFE CTRL */
+#define MT_WF_PHYDFE_TSSI_TXCTRL01(_band)	MT_WF_PHYRX_CSD(_band, 0, 0xc718)
+#define MT_WF_PHYDFE_TSSI_TXCTRL_POWER_TMAC	GENMASK(31, 24)
+
+/* PHY CTRL */
+#define MT_WF_PHY_BAND_BASE			0x83080000
+#define MT_WF_PHY_BAND(_band, ofs)		(MT_WF_PHY_BAND_BASE + \
						 ((_band) << 20) + (ofs))

-#define MT_WF_PHYRX_BAND_GID_TAB_VLD0(_band)	MT_WF_PHYRX_BAND(_band, 0x1054)
-#define MT_WF_PHYRX_BAND_GID_TAB_VLD1(_band)	MT_WF_PHYRX_BAND(_band, 0x1058)
-#define MT_WF_PHYRX_BAND_GID_TAB_POS0(_band)	MT_WF_PHYRX_BAND(_band, 0x105c)
-#define MT_WF_PHYRX_BAND_GID_TAB_POS1(_band)	MT_WF_PHYRX_BAND(_band, 0x1060)
-#define MT_WF_PHYRX_BAND_GID_TAB_POS2(_band)	MT_WF_PHYRX_BAND(_band, 0x1064)
-#define MT_WF_PHYRX_BAND_GID_TAB_POS3(_band)	MT_WF_PHYRX_BAND(_band, 0x1068)
+#define MT_WF_PHYRX_BAND_GID_TAB_VLD0(_band)	MT_WF_PHY_BAND(_band, 0x1054)
+#define MT_WF_PHYRX_BAND_GID_TAB_VLD1(_band)	MT_WF_PHY_BAND(_band, 0x1058)
+#define MT_WF_PHYRX_BAND_GID_TAB_POS0(_band)	MT_WF_PHY_BAND(_band, 0x105c)
+#define MT_WF_PHYRX_BAND_GID_TAB_POS1(_band)	MT_WF_PHY_BAND(_band, 0x1060)
+#define MT_WF_PHYRX_BAND_GID_TAB_POS2(_band)	MT_WF_PHY_BAND(_band, 0x1064)
+#define MT_WF_PHYRX_BAND_GID_TAB_POS3(_band)	MT_WF_PHY_BAND(_band, 0x1068)

-#define MT_WF_PHYRX_BAND_RX_CTRL1(_band)	MT_WF_PHYRX_BAND(_band, 0x2004)
+/* PHYRX CTRL */
+#define MT_WF_PHYRX_BAND_RX_CTRL1(_band)	MT_WF_PHY_BAND(_band, 0x2004)
 #define MT_WF_PHYRX_BAND_RX_CTRL1_IPI_EN	GENMASK(2, 0)
 #define MT_WF_PHYRX_BAND_RX_CTRL1_STSCNT_EN	GENMASK(11, 9)

 /* PHYRX CSD BAND */
-#define MT_WF_PHYRX_CSD_BAND_RXTD12(_band)		MT_WF_PHYRX_BAND(_band, 0x8230)
+#define MT_WF_PHYRX_CSD_BAND_RXTD12(_band)		MT_WF_PHY_BAND(_band, 0x8230)
 #define MT_WF_PHYRX_CSD_BAND_RXTD12_IRPI_SW_CLR_ONLY	BIT(18)
 #define MT_WF_PHYRX_CSD_BAND_RXTD12_IRPI_SW_CLR		BIT(29)

 /* CONN MCU EXCP CON */
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/testmode.c b/drivers/net/wireless/mediatek/mt76/mt7996/testmode.c
new file mode 100644
index 000000000000..1d380f87b537
--- /dev/null
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/testmode.c
@@ -0,0 +1,2199 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (C) 2022 MediaTek Inc.
+ */
+
+#include "mt7996.h"
+#include "mac.h"
+#include "mcu.h"
+#include "testmode.h"
+#include "eeprom.h"
+#include "mtk_mcu.h"
+
+enum {
+	TM_CHANGED_TXPOWER,
+	TM_CHANGED_FREQ_OFFSET,
+	TM_CHANGED_SKU_EN,
+	TM_CHANGED_TX_LENGTH,
+	TM_CHANGED_TX_TIME,
+	TM_CHANGED_CFG,
+	TM_CHANGED_OFF_CHAN_CH,
+	TM_CHANGED_OFF_CHAN_CENTER_CH,
+	TM_CHANGED_OFF_CHAN_BW,
+	TM_CHANGED_IPI_THRESHOLD,
+	TM_CHANGED_IPI_PERIOD,
+	TM_CHANGED_IPI_RESET,
+	TM_CHANGED_TXBF_ACT,
+	TM_CHANGED_TX_ANTENNA,
+	TM_CHANGED_TX_RATE_NSS,
+	TM_CHANGED_TX_RATE_IDX,
+
+	/* must be last */
+	NUM_TM_CHANGED
+};
+
+static const u8 tm_change_map[] = {
+	[TM_CHANGED_TXPOWER] = MT76_TM_ATTR_TX_POWER,
+	[TM_CHANGED_FREQ_OFFSET] = MT76_TM_ATTR_FREQ_OFFSET,
+	[TM_CHANGED_SKU_EN] = MT76_TM_ATTR_SKU_EN,
+	[TM_CHANGED_TX_LENGTH] = MT76_TM_ATTR_TX_LENGTH,
+	[TM_CHANGED_TX_TIME] = MT76_TM_ATTR_TX_TIME,
+	[TM_CHANGED_CFG] = MT76_TM_ATTR_CFG,
+	[TM_CHANGED_OFF_CHAN_CH] = MT76_TM_ATTR_OFF_CH_SCAN_CH,
+	[TM_CHANGED_OFF_CHAN_CENTER_CH] = MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH,
+	[TM_CHANGED_OFF_CHAN_BW] = MT76_TM_ATTR_OFF_CH_SCAN_BW,
+	[TM_CHANGED_IPI_THRESHOLD] = MT76_TM_ATTR_IPI_THRESHOLD,
+	[TM_CHANGED_IPI_PERIOD] = MT76_TM_ATTR_IPI_PERIOD,
+	[TM_CHANGED_IPI_RESET] = MT76_TM_ATTR_IPI_RESET,
+	[TM_CHANGED_TXBF_ACT] = MT76_TM_ATTR_TXBF_ACT,
+	[TM_CHANGED_TX_ANTENNA] = MT76_TM_ATTR_TX_ANTENNA,
+	[TM_CHANGED_TX_RATE_NSS] = MT76_TM_ATTR_TX_RATE_NSS,
+	[TM_CHANGED_TX_RATE_IDX] = MT76_TM_ATTR_TX_RATE_IDX,
+};
+
+static void mt7996_tm_ipi_work(struct work_struct *work);
+static int mt7996_tm_txbf_apply_tx(struct mt7996_phy *phy, u16 wlan_idx,
+				   bool ebf, bool ibf, bool phase_cal);
+
+static u32 mt7996_tm_bw_mapping(enum nl80211_chan_width width, enum bw_mapping_method method)
+{
+	static const u32 width_to_bw[][NUM_BW_MAP] = {
+		[NL80211_CHAN_WIDTH_40] = {FW_CDBW_40MHZ, TM_CBW_40MHZ, BF_CDBW_40MHZ, 40,
+					   FIRST_CONTROL_CHAN_BITMAP_BW40},
+		[NL80211_CHAN_WIDTH_80] = {FW_CDBW_80MHZ, TM_CBW_80MHZ, BF_CDBW_80MHZ, 80,
+					   FIRST_CONTROL_CHAN_BITMAP_BW80},
+		[NL80211_CHAN_WIDTH_80P80] = {FW_CDBW_8080MHZ, TM_CBW_8080MHZ, BF_CDBW_8080MHZ,
+					      80, 0x0},
+		[NL80211_CHAN_WIDTH_160] = {FW_CDBW_160MHZ, TM_CBW_160MHZ, BF_CDBW_160MHZ, 160,
+					    FIRST_CONTROL_CHAN_BITMAP_BW160},
+		[NL80211_CHAN_WIDTH_5] = {FW_CDBW_5MHZ, TM_CBW_5MHZ, BF_CDBW_5MHZ, 5, 0x0},
+		[NL80211_CHAN_WIDTH_10] = {FW_CDBW_10MHZ, TM_CBW_10MHZ, BF_CDBW_10MHZ, 10, 0x0},
+		[NL80211_CHAN_WIDTH_20] = {FW_CDBW_20MHZ, TM_CBW_20MHZ, BF_CDBW_20MHZ, 20, 0x0},
+		[NL80211_CHAN_WIDTH_20_NOHT] = {FW_CDBW_20MHZ, TM_CBW_20MHZ, BF_CDBW_20MHZ,
+						20, 0x0},
+		[NL80211_CHAN_WIDTH_320] = {FW_CDBW_320MHZ, TM_CBW_320MHZ, BF_CDBW_320MHZ,
+					    320, 0x0},
+	};
+
+	if (width >= ARRAY_SIZE(width_to_bw))
+		return 0;
+
+	return width_to_bw[width][method];
+}
+
+static u8 mt7996_tm_rate_mapping(u8 tx_rate_mode, enum rate_mapping_type type)
+{
+	static const u8 rate_to_phy[][NUM_RATE_MAP] = {
+		[MT76_TM_TX_MODE_CCK] = {MT_PHY_TYPE_CCK, BF_LM_LEGACY},
+		[MT76_TM_TX_MODE_OFDM] = {MT_PHY_TYPE_OFDM, BF_LM_LEGACY},
+		[MT76_TM_TX_MODE_HT] = {MT_PHY_TYPE_HT, BF_LM_HT},
+		[MT76_TM_TX_MODE_VHT] = {MT_PHY_TYPE_VHT, BF_LM_VHT},
+		[MT76_TM_TX_MODE_HE_SU] = {MT_PHY_TYPE_HE_SU, BF_LM_HE},
+		[MT76_TM_TX_MODE_HE_EXT_SU] = {MT_PHY_TYPE_HE_EXT_SU, BF_LM_HE},
+		[MT76_TM_TX_MODE_HE_TB] = {MT_PHY_TYPE_HE_TB, BF_LM_HE},
+		[MT76_TM_TX_MODE_HE_MU] = {MT_PHY_TYPE_HE_MU, BF_LM_HE},
+		[MT76_TM_TX_MODE_EHT_SU] = {MT_PHY_TYPE_EHT_SU, BF_LM_EHT},
+		[MT76_TM_TX_MODE_EHT_TRIG] = {MT_PHY_TYPE_EHT_TRIG, BF_LM_EHT},
+		[MT76_TM_TX_MODE_EHT_MU] = {MT_PHY_TYPE_EHT_MU, BF_LM_EHT},
+	};
+
+	if (tx_rate_mode > MT76_TM_TX_MODE_MAX)
+		return -EINVAL;
+
+	return rate_to_phy[tx_rate_mode][type];
+}
+
+static int
+mt7996_tm_check_antenna(struct mt7996_phy *phy)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	u8 band_idx = phy->mt76->band_idx;
+	u32 chainmask = phy->mt76->chainmask;
+	u32 aux_rx_mask;
+
+	chainmask = chainmask >> dev->chainshift[band_idx];
+	aux_rx_mask = BIT(fls(chainmask)) * phy->has_aux_rx;
+	if (td->tx_antenna_mask & ~(chainmask | aux_rx_mask)) {
+		dev_err(dev->mt76.dev,
+			"tx antenna mask 0x%x exceeds hw limit (chainmask 0x%x, has aux rx: %s)\n",
+			td->tx_antenna_mask, chainmask, phy->has_aux_rx ? "yes" : "no");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_set(struct mt7996_dev *dev, u32 func_idx, u32 data)
+{
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_SET,
+			.op.rf.func_idx = func_idx,
+			.op.rf.param.func_data = cpu_to_le32(data),
+		},
+	};
+	bool wait = (data == RF_CMD(START_TX)) ? true : false;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+				 sizeof(req), wait);
+}
+
+static int
+mt7996_tm_get(struct mt7996_dev *dev, u32 func_idx, u32 data, u32 *result)
+{
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_GET,
+			.op.rf.func_idx = func_idx,
+			.op.rf.param.func_data = cpu_to_le32(data),
+		},
+	};
+	struct mt7996_tm_event *event;
+	struct sk_buff *skb;
+	int ret;
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD_QUERY(TESTMODE_CTRL),
+					&req, sizeof(req), true, &skb);
+	if (ret)
+		return ret;
+
+	event = (struct mt7996_tm_event *)skb->data;
+	*result = event->result.payload_length;
+
+	dev_kfree_skb(skb);
+
+	return ret;
+}
+
+static void
+mt7996_tm_set_antenna(struct mt7996_phy *phy, u32 func_idx)
+{
+#define SPE_INDEX_MASK		BIT(31)
+#define TX_ANTENNA_MASK		GENMASK(4, 0)
+#define RX_ANTENNA_MASK		GENMASK(20, 16)
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	u32 antenna_mask;
+
+	if (!mt76_testmode_param_present(td, MT76_TM_ATTR_TX_ANTENNA))
+		return;
+
+	if (func_idx == SET_ID(TX_PATH))
+		antenna_mask = td->tx_spe_idx ? (SPE_INDEX_MASK | td->tx_spe_idx) :
+						td->tx_antenna_mask & TX_ANTENNA_MASK;
+	else if (func_idx == SET_ID(RX_PATH))
+		antenna_mask = u32_encode_bits(td->tx_antenna_mask, RX_ANTENNA_MASK);
+	else
+		return;
+
+	mt7996_tm_set(dev, func_idx, antenna_mask);
+}
+
+static void
+mt7996_tm_set_mac_addr(struct mt7996_dev *dev, u8 *addr, u32 func_idx)
+{
+#define REMAIN_PART_TAG		BIT(18)
+	u32 own_mac_first = 0, own_mac_remain = 0;
+	int len = sizeof(u32);
+
+	memcpy(&own_mac_first, addr, len);
+	mt7996_tm_set(dev, func_idx, own_mac_first);
+	/* Set the remain part of mac address */
+	memcpy(&own_mac_remain, addr + len, ETH_ALEN - len);
+	mt7996_tm_set(dev, func_idx | REMAIN_PART_TAG, own_mac_remain);
+}
+
+static int
+mt7996_tm_rf_switch_mode(struct mt7996_dev *dev, u32 op_mode)
+{
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_SWITCH_TO_RF_TEST,
+			.op.op_mode = cpu_to_le32(op_mode),
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+				 sizeof(req), false);
+}
+
+static void
+mt7996_tm_init(struct mt7996_phy *phy, bool en)
+{
+	struct ieee80211_vif *vif = phy->mt76->monitor_vif;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_vif_link *deflink = &mvif->deflink;
+	u8 rf_test_mode = en ? RF_OPER_RF_TEST : RF_OPER_NORMAL;
+	int state;
+
+	if (!test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
+		return;
+
+	mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(ATE_MODE), en);
+	mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(SKU_POWER_LIMIT), !en);
+	mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(BACKOFF_POWER_LIMIT), !en);
+
+	mt7996_tm_rf_switch_mode(dev, rf_test_mode);
+
+	mt7996_mcu_add_bss_info(phy, vif, &vif->bss_conf,
+				&deflink->mt76, &deflink->msta_link, en);
+	state = en ? CONN_STATE_PORT_SECURE : CONN_STATE_DISCONNECT;
+	// TODO:  Won't compile.  mt7996_mcu_add_sta(dev, &vif->bss_conf, &mvif->deflink,
+	//NULL, &mvif->sta.deflink, state, false);
+
+	mt7996_tm_set(dev, SET_ID(BAND_IDX), phy->mt76->band_idx);
+
+	/* use firmware counter for RX stats */
+	phy->mt76->test.flag |= MT_TM_FW_RX_COUNT;
+
+	if (en)
+		INIT_DELAYED_WORK(&phy->ipi_work, mt7996_tm_ipi_work);
+}
+
+void
+mt7996_tm_update_channel(struct mt7996_phy *phy)
+{
+#define CHAN_FREQ_BW_80P80_TAG		(SET_ID(CHAN_FREQ) | BIT(16))
+	struct mt7996_dev *dev = phy->dev;
+	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+	struct ieee80211_channel *chan = chandef->chan;
+	u8 width = chandef->width;
+	static const u8 ch_band[] = {
+		[NL80211_BAND_2GHZ] = 0,
+		[NL80211_BAND_5GHZ] = 1,
+		[NL80211_BAND_6GHZ] = 2,
+	};
+
+	if (!chan) {
+		dev_info(dev->mt76.dev, "no channel found, update failed!\n");
+		return;
+	}
+
+	/* system bw */
+	mt7996_tm_set(dev, SET_ID(CBW), mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+
+	if (width == NL80211_CHAN_WIDTH_80P80) {
+		width = NL80211_CHAN_WIDTH_160;
+		mt7996_tm_set(dev, CHAN_FREQ_BW_80P80_TAG, chandef->center_freq2 * 1000);
+	}
+
+	/* TODO: define per-packet bw */
+	/* per-packet bw */
+	mt7996_tm_set(dev, SET_ID(DBW), mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+
+	/* control channel selection index */
+	mt7996_tm_set(dev, SET_ID(PRIMARY_CH), 0);
+	mt7996_tm_set(dev, SET_ID(BAND), ch_band[chan->band]);
+
+	/* trigger switch channel calibration */
+	mt7996_tm_set(dev, SET_ID(CHAN_FREQ), chandef->center_freq1 * 1000);
+
+	// TODO: update power limit table
+}
+
+static void
+mt7996_tm_tx_stop(struct mt76_phy *mphy)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+
+	mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(STOP_TEST));
+	td->tx_pending = 0;
+}
+
+{
+#define FRAME_CONTROL		0x88
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+
+	//TODO: RU operation, replace mcs, nss, and ldpc
+	if (en) {
+		mt7996_tm_set(dev, SET_ID(MAC_HEADER), FRAME_CONTROL);
+		mt7996_tm_set(dev, SET_ID(SEQ_CTRL), 0);
+		mt7996_tm_set(dev, SET_ID(TX_COUNT), td->tx_count);
+		mt7996_tm_set(dev, SET_ID(TX_MODE),
+			      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+		mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+
+		if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER))
+			mt7996_tm_set(dev, SET_ID(POWER), td->tx_power[0]);
+
+		if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_TIME)) {
+			mt7996_tm_set(dev, SET_ID(TX_LEN), 0);
+			mt7996_tm_set(dev, SET_ID(TX_TIME), td->tx_time);
+		} else {
+			mt7996_tm_set(dev, SET_ID(TX_LEN), td->tx_mpdu_len);
+			mt7996_tm_set(dev, SET_ID(TX_TIME), 0);
+		}
+
+		mt7996_tm_set_antenna(phy, SET_ID(TX_PATH));
+		mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+		mt7996_tm_set(dev, SET_ID(STBC), td->tx_rate_stbc);
+		mt7996_tm_set(dev, SET_ID(ENCODE_MODE), td->tx_rate_ldpc);
+		mt7996_tm_set(dev, SET_ID(IBF_ENABLE), td->ibf);
+		mt7996_tm_set(dev, SET_ID(EBF_ENABLE), td->ebf);
+		mt7996_tm_set(dev, SET_ID(IPG), td->tx_ipg);
+		mt7996_tm_set(dev, SET_ID(GI), td->tx_rate_sgi);
+		mt7996_tm_set(dev, SET_ID(NSS), td->tx_rate_nss);
+		mt7996_tm_set(dev, SET_ID(AID_OFFSET), 0);
+		mt7996_tm_set(dev, SET_ID(PUNCTURE), td->tx_preamble_puncture);
+
+		mt7996_tm_set(dev, SET_ID(MAX_PE), 2);
+		mt7996_tm_set(dev, SET_ID(HW_TX_MODE), 0);
+		if (!td->bf_en)
+			mt7996_tm_update_channel(phy);
+
+		/* trigger firmware to start TX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(START_TX));
+	} else {
+		mt7996_tm_tx_stop(phy->mt76);
+	}
+}
+
+static int
+mt7996_tm_rx_stats_user_ctrl(struct mt7996_phy *phy, u16 user_idx)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_rx_req req = {
+		.band = phy->mt76->band_idx,
+		.user_ctrl = {
+			.tag = cpu_to_le16(UNI_TM_RX_STAT_SET_USER_CTRL),
+			.len = cpu_to_le16(sizeof(req.user_ctrl)),
+			.band_idx = phy->mt76->band_idx,
+			.user_idx = cpu_to_le16(user_idx),
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_RX_STAT), &req,
+				 sizeof(req), false);
+}
+
+static void
+mt7996_tm_set_rx_frames(struct mt7996_phy *phy, bool en)
+{
+#define RX_MU_DISABLE	0xf800
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	int ret;
+
+	if (en) {
+		ret = mt7996_tm_rx_stats_user_ctrl(phy, td->aid);
+		if (ret) {
+			dev_info(dev->mt76.dev, "Set RX stats user control failed!\n");
+			return;
+		}
+
+		if (!td->bf_en)
+			mt7996_tm_update_channel(phy);
+
+		if (td->tx_rate_mode >= MT76_TM_TX_MODE_HE_MU) {
+			if (td->aid)
+				ret = mt7996_tm_set(dev, SET_ID(RX_MU_AID), td->aid);
+			else
+				ret = mt7996_tm_set(dev, SET_ID(RX_MU_AID), RX_MU_DISABLE);
+		}
+		mt7996_tm_set(dev, SET_ID(TX_MODE),
+			      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+		mt7996_tm_set(dev, SET_ID(GI), td->tx_rate_sgi);
+		mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+		mt7996_tm_set(dev, SET_ID(MAX_PE), 2);
+
+		mt7996_tm_set_mac_addr(dev, td->addr[1], SET_ID(SA));
+
+		/* trigger firmware to start RX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(START_RX));
+	} else {
+		/* trigger firmware to stop RX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(STOP_TEST));
+	}
+}
+
+static void
+mt7996_tm_set_tx_cont(struct mt7996_phy *phy, bool en)
+{
+#define CONT_WAVE_MODE_OFDM	3
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+
+	if (en) {
+		mt7996_tm_update_channel(phy);
+		mt7996_tm_set(dev, SET_ID(TX_MODE),
+			      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+		mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+		/* fix payload is OFDM */
+		mt7996_tm_set(dev, SET_ID(CONT_WAVE_MODE), CONT_WAVE_MODE_OFDM);
+		mt7996_tm_set(dev, SET_ID(ANT_MASK), td->tx_antenna_mask);
+
+		/* trigger firmware to start CONT TX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(CONT_WAVE));
+	} else {
+		/* trigger firmware to stop CONT TX  */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(STOP_TEST));
+	}
+}
+
+static int
+mt7996_tm_group_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
+{
+	u8 *eeprom, do_precal;
+	u32 i, group_size, dpd_size, size, offs, *pre_cal;
+	int ret = 0;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_IN_RF_TEST,
+			.icap_len = RF_TEST_ICAP_LEN,
+			.op.rf.func_idx = cpu_to_le32(RF_TEST_RE_CAL),
+			.op.rf.param.cal_param.func_data = cpu_to_le32(RF_PRE_CAL),
+			.op.rf.param.cal_param.band_idx = phy->mt76->band_idx,
+		},
+	};
+
+	if (!dev->flash_mode) {
+		dev_err(dev->mt76.dev, "Currently not in FLASH or BIN FILE mode, return!\n");
+		return -EOPNOTSUPP;
+	}
+
+	eeprom = mdev->eeprom.data;
+	dev->cur_prek_offset = 0;
+	group_size = MT_EE_CAL_GROUP_SIZE;
+	dpd_size = MT_EE_CAL_DPD_SIZE;
+	size = group_size + dpd_size;
+	offs = MT_EE_DO_PRE_CAL;
+	do_precal = (MT_EE_WIFI_CAL_GROUP_2G * !!PREK(GROUP_SIZE_2G)) |
+		    (MT_EE_WIFI_CAL_GROUP_5G * !!PREK(GROUP_SIZE_5G)) |
+		    (MT_EE_WIFI_CAL_GROUP_6G * !!PREK(GROUP_SIZE_6G));
+
+	switch (state) {
+	case MT76_TM_STATE_GROUP_PREK:
+		if (!dev->cal) {
+			dev->cal = devm_kzalloc(mdev->dev, size, GFP_KERNEL);
+			if (!dev->cal)
+				return -ENOMEM;
+		}
+
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+					sizeof(req), false);
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == group_size,
+				   30 * HZ);
+
+		if (ret)
+			dev_err(dev->mt76.dev, "Group Pre-cal: mcu send msg failed!\n");
+		else
+			eeprom[offs] |= do_precal;
+		break;
+	case MT76_TM_STATE_GROUP_PREK_DUMP:
+		pre_cal = (u32 *)dev->cal;
+		if (!pre_cal) {
+			dev_info(dev->mt76.dev, "Not group pre-cal yet!\n");
+			return ret;
+		}
+		dev_info(dev->mt76.dev, "Group Pre-Cal:\n");
+		for (i = 0; i < (group_size / sizeof(u32)); i += 4) {
+			dev_info(dev->mt76.dev, "[0x%08lx] 0x%8x 0x%8x 0x%8x 0x%8x\n",
+				 i * sizeof(u32), pre_cal[i], pre_cal[i + 1],
+				 pre_cal[i + 2], pre_cal[i + 3]);
+		}
+		break;
+	case MT76_TM_STATE_GROUP_PREK_CLEAN:
+		pre_cal = (u32 *)dev->cal;
+		if (!pre_cal)
+			return ret;
+		memset(pre_cal, 0, group_size);
+		eeprom[offs] &= ~MT_EE_WIFI_CAL_GROUP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int
+mt7996_tm_dpd_prek_send_req(struct mt7996_phy *phy, struct mt7996_tm_req *req,
+			    const struct ieee80211_channel *chan_list, u32 channel_size,
+			    enum nl80211_chan_width width, u32 func_data)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_phy *mphy = phy->mt76;
+	struct cfg80211_chan_def chandef_backup, *chandef = &mphy->chandef;
+	struct ieee80211_channel chan_backup;
+	int i, ret, skip_ch_num = DPD_CH_NUM(BW20_5G_SKIP);
+
+	if (!chan_list)
+		return -EOPNOTSUPP;
+	if (!channel_size)
+		return 0;
+
+	req->rf_test.op.rf.param.cal_param.func_data = cpu_to_le32(func_data);
+
+	memcpy(&chan_backup, chandef->chan, sizeof(struct ieee80211_channel));
+	memcpy(&chandef_backup, chandef, sizeof(struct cfg80211_chan_def));
+
+	for (i = 0; i < channel_size; i++) {
+		if (chan_list[i].band == NL80211_BAND_5GHZ &&
+		    chan_list[i].hw_value >= dpd_5g_skip_ch_list[0].hw_value &&
+		    chan_list[i].hw_value <= dpd_5g_skip_ch_list[skip_ch_num - 1].hw_value)
+			continue;
+
+		memcpy(chandef->chan, &chan_list[i], sizeof(struct ieee80211_channel));
+		chandef->width = width;
+
+		/* set channel switch reason */
+		mphy->hw->conf.flags |= IEEE80211_CONF_OFFCHANNEL;
+		mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);
+
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), req,
+					sizeof(*req), false);
+		if (ret) {
+			dev_err(dev->mt76.dev, "DPD Pre-cal: mcu send msg failed!\n");
+			goto out;
+		}
+	}
+
+out:
+	mphy->hw->conf.flags &= ~IEEE80211_CONF_OFFCHANNEL;
+	memcpy(chandef, &chandef_backup, sizeof(struct cfg80211_chan_def));
+	memcpy(chandef->chan, &chan_backup, sizeof(struct ieee80211_channel));
+	mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);
+
+	return ret;
+}
+
+static int
+mt7996_tm_dpd_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt76_phy *mphy = phy->mt76;
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_IN_RF_TEST,
+			.icap_len = RF_TEST_ICAP_LEN,
+			.op.rf.func_idx = cpu_to_le32(RF_TEST_RE_CAL),
+			.op.rf.param.cal_param.band_idx = phy->mt76->band_idx,
+		},
+	};
+	u32 i, j, group_size, dpd_size, size, offs, *pre_cal;
+	u32 wait_on_prek_offset = 0;
+	u8 do_precal, *eeprom;
+	int ret = 0;
+
+	if (!dev->flash_mode) {
+		dev_err(dev->mt76.dev, "Currently not in FLASH or BIN FILE mode, return!\n");
+		return -EOPNOTSUPP;
+	}
+
+	eeprom = mdev->eeprom.data;
+	dev->cur_prek_offset = 0;
+	group_size = MT_EE_CAL_GROUP_SIZE;
+	dpd_size = MT_EE_CAL_DPD_SIZE;
+	size = group_size + dpd_size;
+	offs = MT_EE_DO_PRE_CAL;
+
+	if (!dev->cal && state < MT76_TM_STATE_DPD_DUMP) {
+		dev->cal = devm_kzalloc(mdev->dev, size, GFP_KERNEL);
+		if (!dev->cal)
+			return -ENOMEM;
+	}
+
+	switch (state) {
+	case MT76_TM_STATE_DPD_2G:
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_2g_ch_list_bw20,
+						  DPD_CH_NUM(BW20_2G),
+						  NL80211_CHAN_WIDTH_20, RF_DPD_FLAT_CAL);
+		wait_on_prek_offset += DPD_CH_NUM(BW20_2G) * DPD_PER_CH_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		do_precal = MT_EE_WIFI_CAL_DPD_2G;
+		break;
+	case MT76_TM_STATE_DPD_5G:
+		/* 5g channel bw20 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, mphy->sband_5g.sband.channels,
+						  mphy->sband_5g.sband.n_channels,
+						  NL80211_CHAN_WIDTH_20, RF_DPD_FLAT_5G_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 5g channel bw80 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_5g_ch_list_bw80,
+						  DPD_CH_NUM(BW80_5G),
+						  NL80211_CHAN_WIDTH_80, RF_DPD_FLAT_5G_MEM_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 5g channel bw160 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_5g_ch_list_bw160,
+						  DPD_CH_NUM(BW160_5G),
+						  NL80211_CHAN_WIDTH_160, RF_DPD_FLAT_5G_MEM_CAL);
+		wait_on_prek_offset += DPD_CH_NUM(BW160_5G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		do_precal = MT_EE_WIFI_CAL_DPD_5G;
+		break;
+	case MT76_TM_STATE_DPD_6G:
+		/* 6g channel bw20 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, mphy->sband_6g.sband.channels,
+						  mphy->sband_6g.sband.n_channels,
+						  NL80211_CHAN_WIDTH_20, RF_DPD_FLAT_6G_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW20_6G) * DPD_PER_CH_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 6g channel bw80 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw80,
+						  DPD_CH_NUM(BW80_6G),
+						  NL80211_CHAN_WIDTH_80, RF_DPD_FLAT_6G_MEM_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW80_6G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 6g channel bw160 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw160,
+						  DPD_CH_NUM(BW160_6G),
+						  NL80211_CHAN_WIDTH_160, RF_DPD_FLAT_6G_MEM_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW160_6G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 6g channel bw320 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw320,
+						  DPD_CH_NUM(BW320_6G),
+						  NL80211_CHAN_WIDTH_320, RF_DPD_FLAT_6G_MEM_CAL);
+		wait_on_prek_offset += DPD_CH_NUM(BW320_6G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		do_precal = MT_EE_WIFI_CAL_DPD_6G;
+		break;
+	case MT76_TM_STATE_DPD_DUMP:
+		if (!dev->cal) {
+			dev_info(dev->mt76.dev, "Not DPD pre-cal yet!\n");
+			return ret;
+		}
+		pre_cal = (u32 *)dev->cal;
+		dev_info(dev->mt76.dev, "DPD Pre-Cal:\n");
+		for (i = 0; i < dpd_size / sizeof(u32); i += 4) {
+			j = i + (group_size / sizeof(u32));
+			dev_info(dev->mt76.dev, "[0x%08lx] 0x%8x 0x%8x 0x%8x 0x%8x\n",
+				 j * sizeof(u32), pre_cal[j], pre_cal[j + 1],
+				 pre_cal[j + 2], pre_cal[j + 3]);
+		}
+		return 0;
+	case MT76_TM_STATE_DPD_CLEAN:
+		pre_cal = (u32 *)dev->cal;
+		if (!pre_cal)
+			return ret;
+		memset(pre_cal + (group_size / sizeof(u32)), 0, dpd_size);
+		do_precal = MT_EE_WIFI_CAL_DPD;
+		eeprom[offs] &= ~do_precal;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+
+	if (!ret)
+		eeprom[offs] |= do_precal;
+
+	return ret;
+}
+
+static int
+mt7996_tm_dump_precal(struct mt76_phy *mphy, struct sk_buff *msg, int flag, int type)
+{
+#define DPD_PER_CHAN_SIZE_MASK		GENMASK(31, 30)
+#define DPD_2G_RATIO_MASK		GENMASK(29, 20)
+#define DPD_5G_RATIO_MASK		GENMASK(19, 10)
+#define DPD_6G_RATIO_MASK		GENMASK(9, 0)
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	u32 i, group_size, dpd_size, total_size, size, dpd_info = 0;
+	u32 dpd_size_2g, dpd_size_5g, dpd_size_6g;
+	u32 base, offs, transmit_size = 1000;
+	u8 *pre_cal, *eeprom;
+	void *precal;
+	enum prek_ops {
+		PREK_GET_INFO,
+		PREK_SYNC_ALL,
+		PREK_SYNC_GROUP,
+		PREK_SYNC_DPD_2G,
+		PREK_SYNC_DPD_5G,
+		PREK_SYNC_DPD_6G,
+		PREK_CLEAN_GROUP,
+		PREK_CLEAN_DPD,
+	};
+
+	if (!dev->cal) {
+		dev_info(dev->mt76.dev, "Not pre-cal yet!\n");
+		return 0;
+	}
+
+	group_size = MT_EE_CAL_GROUP_SIZE;
+	dpd_size = MT_EE_CAL_DPD_SIZE;
+	total_size = group_size + dpd_size;
+	pre_cal = dev->cal;
+	eeprom = dev->mt76.eeprom.data;
+	offs = MT_EE_DO_PRE_CAL;
+
+	dpd_size_2g = MT_EE_CAL_DPD_SIZE_2G;
+	dpd_size_5g = MT_EE_CAL_DPD_SIZE_5G;
+	dpd_size_6g = MT_EE_CAL_DPD_SIZE_6G;
+
+	switch (type) {
+	case PREK_SYNC_ALL:
+		base = 0;
+		size = total_size;
+		break;
+	case PREK_SYNC_GROUP:
+		base = 0;
+		size = group_size;
+		break;
+	case PREK_SYNC_DPD_2G:
+		base = group_size;
+		size = dpd_size_2g;
+		break;
+	case PREK_SYNC_DPD_5G:
+		base = group_size + dpd_size_2g;
+		size = dpd_size_5g;
+		break;
+	case PREK_SYNC_DPD_6G:
+		base = group_size + dpd_size_2g + dpd_size_5g;
+		size = dpd_size_6g;
+		break;
+	case PREK_GET_INFO:
+		break;
+	default:
+		return 0;
+	}
+
+	if (!flag) {
+		if (eeprom[offs] & MT_EE_WIFI_CAL_DPD) {
+			dpd_info |= u32_encode_bits(1, DPD_PER_CHAN_SIZE_MASK) |
+				    u32_encode_bits(dpd_size_2g / MT_EE_CAL_UNIT,
+						    DPD_2G_RATIO_MASK) |
+				    u32_encode_bits(dpd_size_5g / MT_EE_CAL_UNIT,
+						    DPD_5G_RATIO_MASK) |
+				    u32_encode_bits(dpd_size_6g / MT_EE_CAL_UNIT,
+						    DPD_6G_RATIO_MASK);
+		}
+		dev->cur_prek_offset = 0;
+		precal = nla_nest_start(msg, MT76_TM_ATTR_PRECAL_INFO);
+		if (!precal)
+			return -ENOMEM;
+		nla_put_u32(msg, 0, group_size);
+		nla_put_u32(msg, 1, dpd_size);
+		nla_put_u32(msg, 2, dpd_info);
+		nla_put_u32(msg, 3, transmit_size);
+		nla_put_u32(msg, 4, eeprom[offs]);
+		nla_nest_end(msg, precal);
+	} else {
+		precal = nla_nest_start(msg, MT76_TM_ATTR_PRECAL);
+		if (!precal)
+			return -ENOMEM;
+
+		transmit_size = (dev->cur_prek_offset + transmit_size < size) ?
+				transmit_size : (size - dev->cur_prek_offset);
+		for (i = 0; i < transmit_size; i++) {
+			if (nla_put_u8(msg, i, pre_cal[base + dev->cur_prek_offset + i]))
+				return -ENOMEM;
+		}
+		dev->cur_prek_offset += transmit_size;
+
+		nla_nest_end(msg, precal);
+	}
+
+	return 0;
+}
+
+static void
+mt7996_tm_re_cal_event(struct mt7996_dev *dev, struct mt7996_tm_rf_test_result *result,
+		       struct mt7996_tm_rf_test_data *data)
+{
+	u32 base, dpd_size_2g, dpd_size_5g, dpd_size_6g, cal_idx, cal_type, len = 0;
+	u8 *pre_cal;
+
+	pre_cal = dev->cal;
+	dpd_size_2g = MT_EE_CAL_DPD_SIZE_2G;
+	dpd_size_5g = MT_EE_CAL_DPD_SIZE_5G;
+	dpd_size_6g = MT_EE_CAL_DPD_SIZE_6G;
+
+	cal_idx = le32_to_cpu(data->cal_idx);
+	cal_type = le32_to_cpu(data->cal_type);
+	len = le32_to_cpu(result->payload_length);
+	len = len - sizeof(struct mt7996_tm_rf_test_data);
+
+	switch (cal_type) {
+	case RF_PRE_CAL:
+		base = 0;
+		break;
+	case RF_DPD_FLAT_CAL:
+		base = MT_EE_CAL_GROUP_SIZE;
+		break;
+	case RF_DPD_FLAT_5G_CAL:
+	case RF_DPD_FLAT_5G_MEM_CAL:
+		base = MT_EE_CAL_GROUP_SIZE + dpd_size_2g;
+		break;
+	case RF_DPD_FLAT_6G_CAL:
+	case RF_DPD_FLAT_6G_MEM_CAL:
+		base = MT_EE_CAL_GROUP_SIZE + dpd_size_2g + dpd_size_5g;
+		break;
+	default:
+		dev_info(dev->mt76.dev, "Unknown calibration type!\n");
+		return;
+	}
+	pre_cal += (base + dev->cur_prek_offset);
+
+	memcpy(pre_cal, data->cal_data, len);
+	dev->cur_prek_offset += len;
+}
+
+void mt7996_tm_rf_test_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_tm_event *event;
+	struct mt7996_tm_rf_test_result *result;
+	struct mt7996_tm_rf_test_data *data;
+	static u32 event_type;
+
+	skb_pull(skb, sizeof(struct mt7996_mcu_rxd));
+	event = (struct mt7996_tm_event *)skb->data;
+	result = (struct mt7996_tm_rf_test_result *)&event->result;
+	data = (struct mt7996_tm_rf_test_data *)result->data;
+
+	event_type = le32_to_cpu(result->func_idx);
+
+	switch (event_type) {
+	case RF_TEST_RE_CAL:
+		mt7996_tm_re_cal_event(dev, result, data);
+		break;
+	default:
+		break;
+	}
+}
+
+static u8
+mt7996_tm_get_center_chan(struct mt7996_phy *phy, struct cfg80211_chan_def *chandef)
+{
+	struct mt76_phy *mphy = phy->mt76;
+	const struct ieee80211_channel *chan = mphy->sband_5g.sband.channels;
+	u32 bitmap, i, offset, width_mhz, size = mphy->sband_5g.sband.n_channels;
+	u16 first_control = 0, control_chan = chandef->chan->hw_value;
+	bool not_first;
+
+	bitmap = mt7996_tm_bw_mapping(chandef->width, BW_MAP_NL_TO_CONTROL_BITMAP_5G);
+	if (!bitmap)
+		return control_chan;
+
+	width_mhz = mt7996_tm_bw_mapping(chandef->width, BW_MAP_NL_TO_MHZ);
+	offset = width_mhz / 10 - 2;
+
+	for (i = 0; i < size; i++) {
+		not_first = (chandef->width != NL80211_CHAN_WIDTH_160) ?
+			    (i % bitmap) : (i >= 32) || !((1 << i) & bitmap);
+		if (not_first)
+			continue;
+
+		if (control_chan >= chan[i].hw_value)
+			first_control = chan[i].hw_value;
+		else
+			break;
+	}
+
+	if (first_control == 0)
+		return control_chan;
+
+	return first_control + offset;
+}
+
+static int
+mt7996_tm_set_offchan(struct mt7996_phy *phy, bool no_center)
+{
+	struct mt76_phy *mphy = phy->mt76;
+	struct mt7996_dev *dev = phy->dev;
+	struct ieee80211_hw *hw = mphy->hw;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct cfg80211_chan_def chandef = {};
+	struct ieee80211_channel *chan;
+	int ret, freq = ieee80211_channel_to_frequency(td->offchan_ch, NL80211_BAND_5GHZ);
+
+	if (!mphy->cap.has_5ghz || !freq) {
+		ret = -EINVAL;
+		dev_info(dev->mt76.dev, "Failed to set offchan (invalid band or channel)!\n");
+		goto out;
+	}
+
+	chandef.width = td->offchan_bw;
+	chan = ieee80211_get_channel(hw->wiphy, freq);
+	chandef.chan = chan;
+	if (no_center)
+		td->offchan_center_ch = mt7996_tm_get_center_chan(phy, &chandef);
+	chandef.center_freq1 = ieee80211_channel_to_frequency(td->offchan_center_ch,
+							      NL80211_BAND_5GHZ);
+	if (!cfg80211_chandef_valid(&chandef)) {
+		ret = -EINVAL;
+		dev_info(dev->mt76.dev, "Failed to set offchan, chandef is invalid!\n");
+		goto out;
+	}
+
+	memset(&dev->rdd2_chandef, 0, sizeof(struct cfg80211_chan_def));
+
+	ret = mt7996_mcu_rdd_background_enable(phy, &chandef);
+
+	if (ret)
+		goto out;
+
+	dev->rdd2_phy = phy;
+	dev->rdd2_chandef = chandef;
+
+	return 0;
+
+out:
+	td->offchan_ch = 0;
+	td->offchan_center_ch = 0;
+	td->offchan_bw = 0;
+
+	return ret;
+}
+
+static void
+mt7996_tm_ipi_hist_ctrl(struct mt7996_phy *phy, struct mt7996_tm_rdd_ipi_ctrl *data, u8 cmd)
+{
+#define MT_IPI_RESET		0x830a5dfc
+#define MT_IPI_RESET_MASK	BIT(28)
+#define MT_IPI_COUNTER_BASE	0x83041000
+#define MT_IPI_COUNTER(idx)	(MT_IPI_COUNTER_BASE + ((idx) * 4))
+	struct mt7996_dev *dev = phy->dev;
+	bool val;
+	int i;
+
+	if (cmd == RDD_SET_IPI_HIST_RESET) {
+		val = mt76_rr(dev, MT_IPI_RESET) & MT_IPI_RESET_MASK;
+		mt76_rmw_field(dev, MT_IPI_RESET, MT_IPI_RESET_MASK, !val);
+		return;
+	}
+
+	for (i = 0; i < POWER_INDICATE_HIST_MAX; i++)
+		data->ipi_hist_val[i] = mt76_rr(dev, MT_IPI_COUNTER(i));
+}
+
+static void
+mt7996_tm_ipi_work(struct work_struct *work)
+{
+#define PRECISION	100
+	struct mt7996_phy *phy = container_of(work, struct mt7996_phy, ipi_work.work);
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_tm_rdd_ipi_ctrl data;
+	u32 ipi_idx, ipi_free_count, ipi_percentage;
+	u32 ipi_hist_count_th = 0, ipi_hist_total_count = 0;
+	u32 self_idle_ratio, ipi_idle_ratio, channel_load;
+	u32 *ipi_hist_data;
+	const char *power_lower_bound, *power_upper_bound;
+	static const char * const ipi_idx_to_power_bound[] = {
+		[RDD_IPI_HIST_0] = "-92",
+		[RDD_IPI_HIST_1] = "-89",
+		[RDD_IPI_HIST_2] = "-86",
+		[RDD_IPI_HIST_3] = "-83",
+		[RDD_IPI_HIST_4] = "-80",
+		[RDD_IPI_HIST_5] = "-75",
+		[RDD_IPI_HIST_6] = "-70",
+		[RDD_IPI_HIST_7] = "-65",
+		[RDD_IPI_HIST_8] = "-60",
+		[RDD_IPI_HIST_9] = "-55",
+		[RDD_IPI_HIST_10] = "inf",
+	};
+
+	memset(&data, 0, sizeof(data));
+	mt7996_tm_ipi_hist_ctrl(phy, &data, RDD_IPI_HIST_ALL_CNT);
+
+	ipi_hist_data = data.ipi_hist_val;
+	for (ipi_idx = 0; ipi_idx < POWER_INDICATE_HIST_MAX; ipi_idx++) {
+		power_lower_bound = ipi_idx ? ipi_idx_to_power_bound[ipi_idx - 1] : "-inf";
+		power_upper_bound = ipi_idx_to_power_bound[ipi_idx];
+
+		dev_info(dev->mt76.dev, "IPI %d (power range: (%s, %s] dBm): ipi count = %d\n",
+			 ipi_idx, power_lower_bound, power_upper_bound, ipi_hist_data[ipi_idx]);
+
+		if (td->ipi_threshold <= ipi_idx && ipi_idx <= RDD_IPI_HIST_10)
+			ipi_hist_count_th += ipi_hist_data[ipi_idx];
+
+		ipi_hist_total_count += ipi_hist_data[ipi_idx];
+	}
+
+	ipi_free_count = ipi_hist_data[RDD_IPI_FREE_RUN_CNT];
+
+	dev_info(dev->mt76.dev, "IPI threshold %d: ipi_hist_count_th = %d, ipi_free_count = %d\n",
+		 td->ipi_threshold, ipi_hist_count_th, ipi_free_count);
+	dev_info(dev->mt76.dev, "TX assert time =  %d [ms]\n", data.tx_assert_time / 1000);
+
+	/* calculate channel load = (self idle ratio - idle ratio) / self idle ratio */
+	if (ipi_hist_count_th >= UINT_MAX / (100 * PRECISION))
+		ipi_percentage = 100 * PRECISION *
+				 (ipi_hist_count_th / (100 * PRECISION)) /
+				 (ipi_free_count / (100 * PRECISION));
+	else
+		ipi_percentage = PRECISION * 100 * ipi_hist_count_th / ipi_free_count;
+
+	ipi_idle_ratio = ((100 * PRECISION) - ipi_percentage) / PRECISION;
+
+	self_idle_ratio = PRECISION * 100 *
+			  (td->ipi_period - (data.tx_assert_time / 1000)) /
+			  td->ipi_period / PRECISION;
+
+	if (self_idle_ratio < ipi_idle_ratio)
+		channel_load = 0;
+	else
+		channel_load = self_idle_ratio - ipi_idle_ratio;
+
+	if (self_idle_ratio <= td->ipi_threshold) {
+		dev_info(dev->mt76.dev, "band[%d]: self idle ratio = %d%%, idle ratio = %d%%\n",
+			 phy->mt76->band_idx, self_idle_ratio, ipi_idle_ratio);
+		return;
+	}
+
+	channel_load = (100 * channel_load) / self_idle_ratio;
+	dev_info(dev->mt76.dev,
+		 "band[%d]: chan load = %d%%, self idle ratio = %d%%, idle ratio = %d%%\n",
+		 phy->mt76->band_idx, channel_load, self_idle_ratio, ipi_idle_ratio);
+}
+
+static int
+mt7996_tm_set_ipi(struct mt7996_phy *phy)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+
+	/* reset IPI CR */
+	mt7996_tm_ipi_hist_ctrl(phy, NULL, RDD_SET_IPI_HIST_RESET);
+
+	cancel_delayed_work(&phy->ipi_work);
+	ieee80211_queue_delayed_work(phy->mt76->hw, &phy->ipi_work,
+				     msecs_to_jiffies(td->ipi_period));
+
+	return 0;
+}
+
+static int
+mt7996_tm_set_trx_mac(struct mt7996_phy *phy, u8 type, bool en)
+{
+#define UNI_TM_TRX_CTRL 0
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_trx_req req = {
+		.param_num = 1,
+		.tag = cpu_to_le16(UNI_TM_TRX_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.param_idx = cpu_to_le16(TM_TRX_PARAM_SET_TRX),
+		.band_idx = phy->mt76->band_idx,
+		.testmode_en = 1,
+		.action = TM_TRX_ACTION_SET,
+		.set_trx = {
+			.type = type,
+			.enable = en,
+			.band_idx = phy->mt76->band_idx,
+		}
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_TRX_PARAM),
+				 &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_init(struct mt7996_phy *phy, u16 *val)
+{
+#define EBF_BBP_RX_OFFSET	0x10280
+#define EBF_BBP_RX_ENABLE	(BIT(0) | BIT(15))
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	bool enable = val[0];
+	void *phase_cal, *pfmu_data, *pfmu_tag;
+	u8 nss, band_idx = phy->mt76->band_idx;
+	enum nl80211_chan_width width = NL80211_CHAN_WIDTH_20;
+	u8 sub_addr = td->is_txbf_dut ? TXBF_DUT_MAC_SUBADDR : TXBF_GOLDEN_MAC_SUBADDR;
+	u8 peer_addr = td->is_txbf_dut ? TXBF_GOLDEN_MAC_SUBADDR : TXBF_DUT_MAC_SUBADDR;
+	u8 bss_addr = TXBF_DUT_MAC_SUBADDR;
+	u8 addr[ETH_ALEN] = {0x00, sub_addr, sub_addr, sub_addr, sub_addr, sub_addr};
+	u8 bssid[ETH_ALEN] = {0x00, bss_addr, bss_addr, bss_addr, bss_addr, bss_addr};
+	u8 peer_addrs[ETH_ALEN] = {0x00, peer_addr, peer_addr, peer_addr, peer_addr, peer_addr};
+	struct ieee80211_vif *vif = phy->mt76->monitor_vif;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_vif_link *deflink = &mvif->deflink;
+
+	if (!enable) {
+		td->bf_en = false;
+		return 0;
+	}
+
+	if (!dev->test.txbf_phase_cal) {
+		phase_cal = devm_kzalloc(dev->mt76.dev,
+					 sizeof(struct mt7996_txbf_phase) *
+					 MAX_PHASE_GROUP_NUM,
+					 GFP_KERNEL);
+		if (!phase_cal)
+			return -ENOMEM;
+
+		dev->test.txbf_phase_cal = phase_cal;
+	}
+
+	if (!dev->test.txbf_pfmu_data) {
+		/* allocate max size for 5x5 pfmu data */
+		pfmu_data = devm_kzalloc(dev->mt76.dev,
+					 MT7996_TXBF_PFMU_DATA_LEN_5X5,
+					 GFP_KERNEL);
+		if (!pfmu_data)
+			return -ENOMEM;
+
+		dev->test.txbf_pfmu_data = pfmu_data;
+	}
+
+	if (!dev->test.txbf_pfmu_tag) {
+		pfmu_tag = devm_kzalloc(dev->mt76.dev,
+					sizeof(struct mt7996_pfmu_tag), GFP_KERNEL);
+		if (!pfmu_tag)
+			return -ENOMEM;
+
+		dev->test.txbf_pfmu_tag = pfmu_tag;
+	}
+
+	td->bf_en = true;
+	dev->ibf = td->ibf;
+	memcpy(td->addr[0], peer_addrs, ETH_ALEN);
+	memcpy(td->addr[1], addr, ETH_ALEN);
+	memcpy(td->addr[2], bssid, ETH_ALEN);
+	memcpy(phy->mt76->monitor_vif->addr, addr, ETH_ALEN);
+	mt7996_tm_set_mac_addr(dev, td->addr[0], SET_ID(DA));
+	mt7996_tm_set_mac_addr(dev, td->addr[1], SET_ID(SA));
+	mt7996_tm_set_mac_addr(dev, td->addr[2], SET_ID(BSSID));
+
+	/* bss idx & omac idx should be set to band idx for ibf cal */
+	mvif->deflink.mt76.idx = band_idx;
+	dev->mt76.vif_mask |= BIT_ULL(mvif->deflink.mt76.idx);
+	mvif->deflink.mt76.omac_idx = band_idx;
+	phy->omac_mask |= BIT_ULL(mvif->deflink.mt76.omac_idx);
+
+	mt7996_mcu_add_dev_info(phy, phy->mt76->monitor_vif, &phy->mt76->monitor_vif->bss_conf, &mvif->deflink.mt76, true);
+	mt7996_mcu_add_bss_info(phy, vif, &vif->bss_conf, &deflink->mt76,
+				&deflink->msta_link, true);
+
+	if (td->ibf) {
+		if (td->is_txbf_dut) {
+			/* Enable ITxBF Capability */
+			mt7996_mcu_set_txbf(dev, BF_HW_EN_UPDATE);
+			mt7996_tm_set_trx_mac(phy, TM_TRX_MAC_TX, true);
+
+			td->tx_ipg = 999;
+			td->tx_mpdu_len = 1024;
+			td->tx_antenna_mask = phy->mt76->chainmask >> dev->chainshift[band_idx];
+			nss = hweight8(td->tx_antenna_mask);
+			if (nss > 1 && nss <= 4)
+				td->tx_rate_idx = 15 + 8 * (nss - 2);
+			else
+				td->tx_rate_idx = 31;
+		} else {
+			td->tx_antenna_mask = 1;
+			td->tx_mpdu_len = 1024;
+			td->tx_rate_idx = 0;
+			mt76_set(dev, EBF_BBP_RX_OFFSET, EBF_BBP_RX_ENABLE);
+			dev_info(dev->mt76.dev, "Set BBP RX CR = %x\n",
+				 mt76_rr(dev, EBF_BBP_RX_OFFSET));
+		}
+
+		td->tx_rate_mode = MT76_TM_TX_MODE_HT;
+		td->tx_rate_sgi = 0;
+		/* 5T5R ibf */
+		if (nss == 5) {
+			td->tx_rate_mode = MT76_TM_TX_MODE_VHT;
+			td->tx_rate_idx = 7;
+			td->tx_rate_nss = 4;
+		}
+	} else {
+		if (td->is_txbf_dut) {
+			/* Enable ETxBF Capability */
+			mt7996_mcu_set_txbf(dev, BF_HW_EN_UPDATE);
+			td->tx_antenna_mask = phy->mt76->chainmask >> dev->chainshift[band_idx];
+			td->tx_spe_idx = 24 + phy->mt76->band_idx;
+			if (td->tx_rate_mode == MT76_TM_TX_MODE_VHT ||
+			    td->tx_rate_mode == MT76_TM_TX_MODE_HE_SU)
+				mt7996_tm_set(dev, SET_ID(NSS), td->tx_rate_nss);
+
+			mt7996_tm_set(dev, SET_ID(ENCODE_MODE), td->tx_rate_ldpc);
+			mt7996_tm_set(dev, SET_ID(TX_COUNT), td->tx_count);
+		} else {
+			/* Turn On BBP CR for RX */
+			mt76_set(dev, EBF_BBP_RX_OFFSET, EBF_BBP_RX_ENABLE);
+			dev_info(dev->mt76.dev, "Set BBP RX CR = %x\n",
+				 mt76_rr(dev, EBF_BBP_RX_OFFSET));
+
+			td->tx_antenna_mask = 1;
+		}
+		width = phy->mt76->chandef.width;
+
+		if (td->tx_rate_mode == MT76_TM_TX_MODE_EHT_MU)
+			td->tx_rate_mode = MT76_TM_TX_MODE_EHT_SU;
+	}
+	mt76_testmode_param_set(td, MT76_TM_ATTR_TX_ANTENNA);
+
+	mt7996_tm_set(dev, SET_ID(TX_MODE),
+		      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+	mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+	mt7996_tm_set(dev, SET_ID(GI), td->tx_rate_sgi);
+	mt7996_tm_set(dev, SET_ID(CBW),
+		      mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+	mt7996_tm_set(dev, SET_ID(DBW),
+		      mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+	mt7996_tm_set_antenna(phy, SET_ID(TX_PATH));
+	mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+	mt7996_tm_set(dev, SET_ID(IPG), td->tx_ipg);
+	mt7996_tm_set(dev, SET_ID(TX_LEN), td->tx_mpdu_len);
+	mt7996_tm_set(dev, SET_ID(TX_TIME), 0);
+	mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(TX_COMMIT));
+
+	return 0;
+}
+
+static inline void
+mt7996_tm_txbf_phase_copy(struct mt7996_dev *dev, void *des, void *src, int group)
+{
+	int phase_size;
+
+	if (group && get_ibf_version(dev) == IBF_VER_1)
+		phase_size = sizeof(struct mt7996_txbf_phase_info_5g);
+	else if (get_ibf_version(dev) == IBF_VER_1)
+		phase_size = sizeof(struct mt7996_txbf_phase_info_2g);
+	else if (group)
+		phase_size = sizeof(struct mt7992_txbf_phase_info_5g);
+	else
+		phase_size = sizeof(struct mt7992_txbf_phase_info_2g);
+
+	memcpy(des, src, phase_size);
+}
+
+static int
+mt7996_tm_txbf_phase_comp(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.phase_comp = {
+			.tag = cpu_to_le16(BF_IBF_PHASE_COMP),
+			.len = cpu_to_le16(sizeof(req.phase_comp)),
+			.bw = val[0],
+			.jp_band = (val[2] == 1) ? 1 : 0,
+			.band_idx = phy->mt76->band_idx,
+			.read_from_e2p = val[3],
+			.disable = val[4],
+			.group = val[2],
+		}
+	};
+	struct mt7996_txbf_phase *phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+	int group = val[2];
+
+	wait_event_timeout(dev->mt76.tx_wait, phase[group].status != 0, HZ);
+	mt7996_tm_txbf_phase_copy(dev, req.phase_comp.buf, phase[group].buf, group);
+
+	pr_info("ibf cal process: phase comp info\n");
+	print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 1,
+		       &req, sizeof(req), 0);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req,
+				 sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_profile_tag_write(struct mt7996_phy *phy, u8 pfmu_idx, struct mt7996_pfmu_tag *tag)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.pfmu_tag = {
+			.tag = cpu_to_le16(BF_PFMU_TAG_WRITE),
+			.len = cpu_to_le16(sizeof(req.pfmu_tag)),
+			.pfmu_id = pfmu_idx,
+			.bfer = true,
+			.band_idx = phy->mt76->band_idx,
+		}
+	};
+
+	memcpy(req.pfmu_tag.buf, tag, sizeof(*tag));
+	wait_event_timeout(dev->mt76.tx_wait, tag->t1.pfmu_idx != 0, HZ);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req,
+				 sizeof(req), false);
+}
+
+static int
+mt7996_tm_add_txbf_sta(struct mt7996_phy *phy, u8 pfmu_idx, u8 nr, u8 nc, bool ebf)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct {
+		struct sta_req_hdr hdr;
+		struct sta_rec_bf bf;
+	} __packed req = {
+		.hdr = {
+			.bss_idx = phy->mt76->band_idx,
+			.wlan_idx_lo = to_wcid_lo(phy->mt76->band_idx + 1),
+			.tlv_num = 1,
+			.is_tlv_append = 1,
+			.muar_idx = 0,
+			.wlan_idx_hi = to_wcid_hi(phy->mt76->band_idx + 1),
+		},
+		.bf = {
+			.tag = cpu_to_le16(STA_REC_BF),
+			.len = cpu_to_le16(sizeof(req.bf)),
+			.pfmu = cpu_to_le16(pfmu_idx),
+			.sounding_phy = 1,
+			.bf_cap = ebf,
+			.ncol = nc,
+			.nrow = nr,
+			.ibf_timeout = 0xff,
+			.tx_mode = mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY),
+		},
+	};
+	u8 ndp_rate, ndpa_rate, rept_poll_rate, bf_bw;
+
+	if ((td->tx_rate_mode == MT76_TM_TX_MODE_HE_SU ||
+	     td->tx_rate_mode == MT76_TM_TX_MODE_EHT_SU) && !td->ibf) {
+		rept_poll_rate = 0x49;
+		ndpa_rate = 0x49;
+		ndp_rate = 0;
+	} else if (td->tx_rate_mode == MT76_TM_TX_MODE_VHT && !td->ibf) {
+		rept_poll_rate = 0x9;
+		ndpa_rate = 0x9;
+		ndp_rate = 0;
+	} else {
+		rept_poll_rate = 0;
+		ndpa_rate = 0;
+		if (nr == 1)
+			ndp_rate = 8;
+		else if (nr == 2)
+			ndp_rate = 16;
+		else if (nr == 4)
+			ndp_rate = 32;
+		else
+			ndp_rate = 24;
+
+		/* 5T5R ebf profile for ibf cal */
+		if (nr == 4 && td->ibf && ebf) {
+			ndp_rate = 0;
+			ndpa_rate = 11;
+		}
+	}
+
+	bf_bw = mt7996_tm_bw_mapping(phy->mt76->chandef.width, BW_MAP_NL_TO_BF);
+	req.bf.ndp_rate = ndp_rate;
+	req.bf.ndpa_rate = ndpa_rate;
+	req.bf.rept_poll_rate = rept_poll_rate;
+	req.bf.bw = bf_bw;
+	req.bf.tx_mode = (td->tx_rate_mode == MT76_TM_TX_MODE_EHT_SU) ? 0xf : req.bf.tx_mode;
+
+	if (ebf) {
+		req.bf.mem[0].row = 0;
+		req.bf.mem[1].row = 1;
+		req.bf.mem[2].row = 2;
+		req.bf.mem[3].row = 3;
+	} else {
+		req.bf.mem[0].row = 4;
+		req.bf.mem[1].row = 5;
+		req.bf.mem[2].row = 6;
+		req.bf.mem[3].row = 7;
+	}
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WMWA_UNI_CMD(STA_REC_UPDATE), &req,
+				 sizeof(req), true);
+}
+
+static int
+mt7996_tm_txbf_profile_update(struct mt7996_phy *phy, u16 *val, bool ebf)
+{
+#define MT_ARB_IBF_ENABLE			(BIT(0) | GENMASK(9, 8))
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_pfmu_tag *tag = dev->test.txbf_pfmu_tag;
+	u8 rate, pfmu_idx = val[0], nc = val[2], nr;
+	int ret;
+	bool is_atenl = val[5];
+
+	if (td->tx_antenna_mask == 3)
+		nr = 1;
+	else if (td->tx_antenna_mask == 7)
+		nr = 2;
+	else if (td->tx_antenna_mask == 31)
+		nr = 4;
+	else
+		nr = 3;
+
+	memset(tag, 0, sizeof(*tag));
+	tag->t1.pfmu_idx = pfmu_idx;
+	tag->t1.ebf = ebf;
+	tag->t1.nr = nr;
+	tag->t1.nc = nc;
+	tag->t1.invalid_prof = true;
+	tag->t1.data_bw = mt7996_tm_bw_mapping(phy->mt76->chandef.width, BW_MAP_NL_TO_BF);
+	tag->t2.se_idx = td->tx_spe_idx;
+
+	if (ebf) {
+		tag->t1.row_id1 = 0;
+		tag->t1.row_id2 = 1;
+		tag->t1.row_id3 = 2;
+		tag->t1.row_id4 = 3;
+		tag->t1.lm = mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_LM);
+	} else {
+		tag->t1.row_id1 = 4;
+		tag->t1.row_id2 = 5;
+		tag->t1.row_id3 = 6;
+		tag->t1.row_id4 = 7;
+		rate = nr == 4 ? td->tx_rate_mode : MT76_TM_TX_MODE_OFDM;
+		tag->t1.lm = mt7996_tm_rate_mapping(rate, RATE_MODE_TO_LM);
+
+		tag->t2.ibf_timeout = 0xff;
+		tag->t2.ibf_nr = nr;
+		tag->t2.ibf_nc = nc;
+	}
+
+	ret = mt7996_tm_txbf_profile_tag_write(phy, pfmu_idx, tag);
+	if (ret)
+		return ret;
+
+	ret = mt7996_tm_add_txbf_sta(phy, pfmu_idx, nr, nc, ebf);
+	if (ret)
+		return ret;
+
+	if (!is_atenl && !td->ibf) {
+		mt76_set(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx), MT_ARB_TQSAXM_ALTX_START_MASK);
+		dev_info(dev->mt76.dev, "Set TX queue start CR for AX management (0x%x) = 0x%x\n",
+			 MT_ARB_TQSAXM0(phy->mt76->band_idx),
+			 mt76_rr(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx)));
+	} else if (!is_atenl && td->ibf && ebf) {
+		/* iBF's ebf profile update */
+		mt76_set(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx), MT_ARB_IBF_ENABLE);
+		dev_info(dev->mt76.dev, "Set TX queue start CR for AX management (0x%x) = 0x%x\n",
+			 MT_ARB_TQSAXM0(phy->mt76->band_idx),
+			 mt76_rr(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx)));
+	}
+
+	if (!ebf && is_atenl)
+		return mt7996_tm_txbf_apply_tx(phy, 1, false, true, true);
+
+	return 0;
+}
+
+static int
+mt7996_tm_txbf_phase_cal(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.phase_cal = {
+			.tag = cpu_to_le16(BF_PHASE_CALIBRATION),
+			.len = cpu_to_le16(sizeof(req.phase_cal)),
+			.group = val[0],
+			.group_l_m_n = val[1],
+			.sx2 = val[2],
+			.cal_type = val[3],
+			.lna_gain_level = val[4],
+			.band_idx = phy->mt76->band_idx,
+			.version = val[5],
+		},
+	};
+	struct mt7996_txbf_phase *phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+
+	/* reset phase status before update phase cal data */
+	phase[req.phase_cal.group].status = 0;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req,
+				 sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_profile_update_all(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	u8 nss = hweight16(phy->mt76->chainmask);
+	u16 pfmu_idx = val[0];
+	u16 subc_id = val[1];
+	u16 angle11 = val[2];
+	u16 angle21 = val[3];
+	u16 angle31 = val[4];
+	u16 angle41 = val[5];
+	u16 angle51 = val[6];
+	s16 phi11 = 0, phi21 = 0, phi31 = 0, phi41 = 0;
+	s16 *pfmu_data;
+	int offs = subc_id * sizeof(struct mt7996_pfmu_data) / sizeof(*pfmu_data);
+
+	if (subc_id > MT7996_TXBF_SUBCAR_NUM - 1)
+		return -EINVAL;
+
+	if (nss == 2) {
+		phi11 = (s16)(angle21 - angle11);
+	} else if (nss == 3) {
+		phi11 = (s16)(angle31 - angle11);
+		phi21 = (s16)(angle31 - angle21);
+	} else if (nss == 5) {
+		phi11 = (s16)(angle51 - angle11);
+		phi21 = (s16)(angle51 - angle21);
+		phi31 = (s16)(angle51 - angle31);
+		phi41 = (s16)(angle51 - angle41);
+		offs = subc_id * sizeof(struct mt7996_pfmu_data_5x5) / sizeof(*pfmu_data);
+	} else {
+		phi11 = (s16)(angle41 - angle11);
+		phi21 = (s16)(angle41 - angle21);
+		phi31 = (s16)(angle41 - angle31);
+	}
+
+	pfmu_data = (s16 *)dev->test.txbf_pfmu_data;
+	pfmu_data += offs;
+
+	if (subc_id < 32)
+		pfmu_data[0] = cpu_to_le16(subc_id + 224);
+	else
+		pfmu_data[0] = cpu_to_le16(subc_id - 32);
+
+	pfmu_data[1] = cpu_to_le16(phi11);
+	pfmu_data[2] = cpu_to_le16(phi21);
+	pfmu_data[3] = cpu_to_le16(phi31);
+	if (nss == 5)
+		pfmu_data[4] = cpu_to_le16(phi41);
+
+	if (subc_id == MT7996_TXBF_SUBCAR_NUM - 1) {
+		struct mt7996_tm_bf_req req = {
+			.pfmu_data_all = {
+				.tag = cpu_to_le16(BF_PROFILE_WRITE_20M_ALL_5X5),
+				.len = cpu_to_le16(sizeof(req.pfmu_data_all)),
+				.pfmu_id = pfmu_idx,
+				.band_idx = phy->mt76->band_idx,
+			},
+		};
+		int size = MT7996_TXBF_PFMU_DATA_LEN_5X5;
+
+		if (nss != 5) {
+			size = MT7996_TXBF_PFMU_DATA_LEN;
+			req.pfmu_data_all.tag = cpu_to_le16(BF_PROFILE_WRITE_20M_ALL);
+			req.pfmu_data_all.len = cpu_to_le16(sizeof(req.pfmu_data_all) -
+							    MT7996_TXBF_PFMU_DATA_LEN_5X5 + size);
+		}
+		memcpy(req.pfmu_data_all.buf, dev->test.txbf_pfmu_data, size);
+
+		return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF),
+					 &req, sizeof(req), true);
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_txbf_e2p_update(struct mt7996_phy *phy)
+{
+#define TXBF_PHASE_EEPROM_START_OFFSET		0xc00
+#define TXBF_PHASE_GROUP_EEPROM_OFFSET_VER_1	46
+#define TXBF_PHASE_G0_EEPROM_OFFSET_VER_2	29
+#define TXBF_PHASE_GX_EEPROM_OFFSET_VER_2	sizeof(struct mt7992_txbf_phase_info_5g)
+	struct mt7996_txbf_phase *phase, *p;
+	struct mt7996_dev *dev = phy->dev;
+	u8 *eeprom = dev->mt76.eeprom.data;
+	u16 offset;
+	int i;
+
+	offset = TXBF_PHASE_EEPROM_START_OFFSET;
+	phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+	for (i = 0; i < MAX_PHASE_GROUP_NUM; i++) {
+		p = &phase[i];
+
+		if (!p->status)
+			continue;
+
+		/* copy phase cal data to eeprom */
+		mt7996_tm_txbf_phase_copy(dev, eeprom + offset, p->buf, i);
+		if (get_ibf_version(dev) == IBF_VER_1)
+			offset += TXBF_PHASE_GROUP_EEPROM_OFFSET_VER_1;
+		else
+			offset += i ? TXBF_PHASE_GX_EEPROM_OFFSET_VER_2 :
+				      TXBF_PHASE_G0_EEPROM_OFFSET_VER_2;
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_txbf_apply_tx(struct mt7996_phy *phy, u16 wlan_idx, bool ebf,
+			bool ibf, bool phase_cal)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.tx_apply = {
+			.tag = cpu_to_le16(BF_DATA_PACKET_APPLY),
+			.len = cpu_to_le16(sizeof(req.tx_apply)),
+			.wlan_idx = cpu_to_le16(wlan_idx),
+			.ebf = ebf,
+			.ibf = ibf,
+			.phase_cal = phase_cal,
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_set_tx(struct mt7996_phy *phy, u16 *val)
+{
+	bool bf_on = val[0], update = val[3];
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_pfmu_tag *tag = dev->test.txbf_pfmu_tag;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+
+	if (bf_on) {
+		mt7996_tm_set_rx_frames(phy, false);
+		mt7996_tm_set_tx_frames(phy, false);
+		mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, 2, true);
+		tag->t1.invalid_prof = false;
+		mt7996_tm_txbf_profile_tag_write(phy, 2, tag);
+		td->bf_ever_en = true;
+
+		if (update)
+			mt7996_tm_txbf_apply_tx(phy, 1, 0, 1, 1);
+	} else {
+		if (!td->bf_ever_en) {
+			mt7996_tm_set_rx_frames(phy, false);
+			mt7996_tm_set_tx_frames(phy, false);
+
+			if (update)
+				mt7996_tm_txbf_apply_tx(phy, 1, 0, 0, 0);
+		} else {
+			td->bf_ever_en = false;
+
+			mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, 2, true);
+			tag->t1.invalid_prof = true;
+			mt7996_tm_txbf_profile_tag_write(phy, 2, tag);
+		}
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_trigger_sounding(struct mt7996_phy *phy, u16 *val, bool en)
+{
+	struct mt7996_dev *dev = phy->dev;
+	u8 sounding_mode = val[0];
+	u8 sta_num = val[1];
+	u32 sounding_interval = (u32)val[2] << 2;	/* input unit: 4ms */
+	u16 tag = en ? BF_SOUNDING_ON : BF_SOUNDING_OFF;
+	struct mt7996_tm_bf_req req = {
+		.sounding = {
+			.tag = cpu_to_le16(tag),
+			.len = cpu_to_le16(sizeof(req.sounding)),
+			.snd_mode = sounding_mode,
+			.sta_num = sta_num,
+			.wlan_id = {
+				cpu_to_le16(val[3]),
+				cpu_to_le16(val[4]),
+				cpu_to_le16(val[5]),
+				cpu_to_le16(val[6])
+			},
+			.snd_period = cpu_to_le32(sounding_interval),
+		},
+	};
+
+	if (sounding_mode > SOUNDING_MODE_MAX)
+		return -EINVAL;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF),
+				 &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_txcmd(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.txcmd = {
+			.tag = cpu_to_le16(BF_CMD_TXCMD),
+			.len = cpu_to_le16(sizeof(req.txcmd)),
+			.action = val[0],
+			.bf_manual = val[1],
+			.bf_bit = val[2],
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_set_txbf(struct mt7996_phy *phy)
+{
+#define TXBF_IS_DUT_MASK	BIT(0)
+#define TXBF_IBF_MASK		BIT(1)
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	u16 *val = td->txbf_param;
+
+	dev_info(phy->dev->mt76.dev,
+		 "ibf cal process: act = %u, val = %u, %u, %u, %u, %u, %u, %u, %u\n",
+		 td->txbf_act, val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7]);
+
+	switch (td->txbf_act) {
+	case MT76_TM_TXBF_ACT_GOLDEN_INIT:
+	case MT76_TM_TXBF_ACT_INIT:
+	case MT76_TM_TX_EBF_ACT_GOLDEN_INIT:
+	case MT76_TM_TX_EBF_ACT_INIT:
+		td->ibf = !u32_get_bits(td->txbf_act, TXBF_IBF_MASK);
+		td->ebf = true;
+		td->is_txbf_dut = !!u32_get_bits(td->txbf_act, TXBF_IS_DUT_MASK);
+		return mt7996_tm_txbf_init(phy, val);
+	case MT76_TM_TXBF_ACT_UPDATE_CH:
+		mt7996_tm_update_channel(phy);
+		break;
+	case MT76_TM_TXBF_ACT_PHASE_COMP:
+		return mt7996_tm_txbf_phase_comp(phy, val);
+	case MT76_TM_TXBF_ACT_TX_PREP:
+		return mt7996_tm_txbf_set_tx(phy, val);
+	case MT76_TM_TXBF_ACT_IBF_PROF_UPDATE:
+		return mt7996_tm_txbf_profile_update(phy, val, false);
+	case MT76_TM_TXBF_ACT_EBF_PROF_UPDATE:
+		return mt7996_tm_txbf_profile_update(phy, val, true);
+	case MT76_TM_TXBF_ACT_PHASE_CAL:
+		return mt7996_tm_txbf_phase_cal(phy, val);
+	case MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD:
+	case MT76_TM_TXBF_ACT_PROF_UPDATE_ALL:
+		return mt7996_tm_txbf_profile_update_all(phy, val);
+	case MT76_TM_TXBF_ACT_E2P_UPDATE:
+		return mt7996_tm_txbf_e2p_update(phy);
+	case MT76_TM_TXBF_ACT_APPLY_TX: {
+		u16 wlan_idx = val[0];
+		bool ebf = !!val[1], ibf = !!val[2], phase_cal = !!val[4];
+
+		return mt7996_tm_txbf_apply_tx(phy, wlan_idx, ebf, ibf, phase_cal);
+	}
+	case MT76_TM_TXBF_ACT_TRIGGER_SOUNDING:
+		return mt7996_tm_trigger_sounding(phy, val, true);
+	case MT76_TM_TXBF_ACT_STOP_SOUNDING:
+		memset(val, 0, sizeof(td->txbf_param));
+		return mt7996_tm_trigger_sounding(phy, val, false);
+	case MT76_TM_TXBF_ACT_PROFILE_TAG_READ:
+	case MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE:
+	case MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID: {
+		u8 pfmu_idx = val[0];
+		bool bfer = !!val[1];
+		struct mt7996_dev *dev = phy->dev;
+		struct mt7996_pfmu_tag *tag = dev->test.txbf_pfmu_tag;
+
+		if (!tag) {
+			dev_err(dev->mt76.dev,
+				"pfmu tag is not initialized!\n");
+			return 0;
+		}
+
+		if (td->txbf_act == MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE)
+			return mt7996_tm_txbf_profile_tag_write(phy, pfmu_idx, tag);
+		else if (td->txbf_act == MT76_TM_TXBF_ACT_PROFILE_TAG_READ)
+			return mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, pfmu_idx, bfer);
+
+		tag->t1.invalid_prof = !!val[0];
+
+		return 0;
+	}
+	case MT76_TM_TXBF_ACT_STA_REC_READ:
+		return mt7996_mcu_set_txbf_internal(phy, BF_STA_REC_READ, val[0], 0);
+	case MT76_TM_TXBF_ACT_TXCMD:
+		return mt7996_tm_txbf_txcmd(phy, val);
+	default:
+		break;
+	};
+
+	return 0;
+}
+
+static void
+mt7996_tm_update_params(struct mt7996_phy *phy, u32 changed)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+
+	if (changed & BIT(TM_CHANGED_FREQ_OFFSET)) {
+		mt7996_tm_set(dev, SET_ID(FREQ_OFFSET), td->freq_offset);
+		mt7996_tm_set(dev, SET_ID(FREQ_OFFSET_C2), td->freq_offset);
+	}
+	if (changed & BIT(TM_CHANGED_TXPOWER))
+		mt7996_tm_set(dev, SET_ID(POWER), td->tx_power[0]);
+	if (changed & BIT(TM_CHANGED_SKU_EN)) {
+		mt7996_tm_update_channel(phy);
+		mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(SKU_POWER_LIMIT), td->sku_en);
+		mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(BACKOFF_POWER_LIMIT), td->sku_en);
+		mt7996_mcu_set_txpower_sku(phy, &phy->mt76->monitor_vif->bss_conf);
+	}
+	if (changed & BIT(TM_CHANGED_TX_LENGTH)) {
+		mt7996_tm_set(dev, SET_ID(TX_LEN), td->tx_mpdu_len);
+		mt7996_tm_set(dev, SET_ID(TX_TIME), 0);
+	}
+	if (changed & BIT(TM_CHANGED_TX_TIME)) {
+		mt7996_tm_set(dev, SET_ID(TX_LEN), 0);
+		mt7996_tm_set(dev, SET_ID(TX_TIME), td->tx_time);
+	}
+	if (changed & BIT(TM_CHANGED_CFG)) {
+		u32 func_idx = td->cfg.enable ? SET_ID(CFG_ON) : SET_ID(CFG_OFF);
+
+		mt7996_tm_set(dev, func_idx, td->cfg.type);
+	}
+	if ((changed & BIT(TM_CHANGED_OFF_CHAN_CH)) &&
+	    (changed & BIT(TM_CHANGED_OFF_CHAN_BW)))
+		mt7996_tm_set_offchan(phy, !(changed & BIT(TM_CHANGED_OFF_CHAN_CENTER_CH)));
+	if ((changed & BIT(TM_CHANGED_IPI_THRESHOLD)) &&
+	    (changed & BIT(TM_CHANGED_IPI_PERIOD)))
+		mt7996_tm_set_ipi(phy);
+	if (changed & BIT(TM_CHANGED_IPI_RESET))
+		mt7996_tm_ipi_hist_ctrl(phy, NULL, RDD_SET_IPI_HIST_RESET);
+	if (changed & BIT(TM_CHANGED_TXBF_ACT))
+		mt7996_tm_set_txbf(phy);
+	if (changed & BIT(TM_CHANGED_TX_ANTENNA)) {
+		mt7996_tm_set_antenna(phy, SET_ID(TX_PATH));
+		mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+	}
+	if (changed & BIT(TM_CHANGED_TX_RATE_NSS))
+		mt7996_tm_set(dev, SET_ID(NSS), td->tx_rate_nss);
+	if (changed & BIT(TM_CHANGED_TX_RATE_IDX))
+		mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+}
+
+static int
+mt7996_tm_set_state(struct mt76_phy *mphy, enum mt76_testmode_state state)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	enum mt76_testmode_state prev_state = td->state;
+
+	if (!dev->testmode_enable)
+		return -EPERM;
+
+	mphy->test.state = state;
+
+	if (prev_state != MT76_TM_STATE_OFF)
+		mt7996_tm_set(dev, SET_ID(BAND_IDX), mphy->band_idx);
+
+	if (prev_state == MT76_TM_STATE_TX_FRAMES ||
+	    state == MT76_TM_STATE_TX_FRAMES)
+		mt7996_tm_set_tx_frames(phy, state == MT76_TM_STATE_TX_FRAMES);
+	else if (prev_state == MT76_TM_STATE_RX_FRAMES ||
+		 state == MT76_TM_STATE_RX_FRAMES)
+		mt7996_tm_set_rx_frames(phy, state == MT76_TM_STATE_RX_FRAMES);
+	else if (prev_state == MT76_TM_STATE_TX_CONT ||
+		 state == MT76_TM_STATE_TX_CONT)
+		mt7996_tm_set_tx_cont(phy, state == MT76_TM_STATE_TX_CONT);
+	else if (prev_state == MT76_TM_STATE_OFF ||
+		 state == MT76_TM_STATE_OFF)
+		mt7996_tm_init(phy, !(state == MT76_TM_STATE_OFF));
+	else if (state >= MT76_TM_STATE_GROUP_PREK && state <= MT76_TM_STATE_GROUP_PREK_CLEAN)
+		return mt7996_tm_group_prek(phy, state);
+	else if (state >= MT76_TM_STATE_DPD_2G && state <= MT76_TM_STATE_DPD_CLEAN)
+		return mt7996_tm_dpd_prek(phy, state);
+
+	if ((state == MT76_TM_STATE_IDLE &&
+	     prev_state == MT76_TM_STATE_OFF) ||
+	    (state == MT76_TM_STATE_OFF &&
+	     prev_state == MT76_TM_STATE_IDLE)) {
+		u32 changed = 0;
+		int i, ret;
+
+		for (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {
+			u16 cur = tm_change_map[i];
+
+			if (mt76_testmode_param_present(td, cur))
+				changed |= BIT(i);
+		}
+
+		ret = mt7996_tm_check_antenna(phy);
+		if (ret)
+			return ret;
+
+		mt7996_tm_update_params(phy, changed);
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_set_params(struct mt76_phy *mphy, struct nlattr **tb,
+		     enum mt76_testmode_state new_state)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	u32 changed = 0;
+	int i, ret;
+
+	BUILD_BUG_ON(NUM_TM_CHANGED >= 32);
+
+	if (new_state == MT76_TM_STATE_OFF ||
+	    td->state == MT76_TM_STATE_OFF)
+		return 0;
+
+	ret = mt7996_tm_check_antenna(phy);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {
+		if (tb[tm_change_map[i]])
+			changed |= BIT(i);
+	}
+
+	mt7996_tm_set(dev, SET_ID(BAND_IDX), mphy->band_idx);
+	mt7996_tm_update_params(phy, changed);
+
+	return 0;
+}
+
+static int
+mt7996_tm_get_rx_stats(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_rx_req req = {
+		.band = phy->mt76->band_idx,
+		.rx_stat_all = {
+			.tag = cpu_to_le16(UNI_TM_RX_STAT_GET_ALL_V2),
+			.len = cpu_to_le16(sizeof(req.rx_stat_all)),
+			.band_idx = phy->mt76->band_idx,
+		},
+	};
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_tm_rx_event *rx_stats;
+	struct mt7996_tm_rx_event_stat_all *rx_stats_all;
+	struct sk_buff *skb;
+	enum mt76_rxq_id qid;
+	int i, ret = 0;
+	u32 mac_rx_mdrdy_cnt;
+	u16 mac_rx_len_mismatch, fcs_err_count;
+
+	if (td->state != MT76_TM_STATE_RX_FRAMES)
+		return 0;
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD_QUERY(TESTMODE_RX_STAT),
+					&req, sizeof(req), true, &skb);
+
+	if (ret)
+		return ret;
+
+	rx_stats = (struct mt7996_tm_rx_event *)skb->data;
+	rx_stats_all = &rx_stats->rx_stat_all;
+
+	phy->test.last_freq_offset = le32_to_cpu(rx_stats_all->user_info[0].freq_offset);
+	phy->test.last_snr = le32_to_cpu(rx_stats_all->user_info[0].snr);
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_rcpi); i++) {
+		phy->test.last_rcpi[i] = le16_to_cpu(rx_stats_all->rxv_info[i].rcpi);
+		phy->test.last_rssi[i] = le16_to_cpu(rx_stats_all->rxv_info[i].rssi);
+		phy->test.last_ib_rssi[i] = rx_stats_all->fagc[i].ib_rssi;
+		phy->test.last_wb_rssi[i] = rx_stats_all->fagc[i].wb_rssi;
+	}
+
+	if (phy->mt76->band_idx == 2)
+		qid = MT_RXQ_BAND2;
+	else if (phy->mt76->band_idx == 1)
+		qid = MT_RXQ_BAND1;
+	else
+		qid = MT_RXQ_MAIN;
+
+	fcs_err_count = le16_to_cpu(rx_stats_all->band_info.mac_rx_fcs_err_cnt);
+	mac_rx_len_mismatch = le16_to_cpu(rx_stats_all->band_info.mac_rx_len_mismatch);
+	mac_rx_mdrdy_cnt = le32_to_cpu(rx_stats_all->band_info.mac_rx_mdrdy_cnt);
+	td->rx_stats.packets[qid] += mac_rx_mdrdy_cnt;
+	td->rx_stats.packets[qid] += fcs_err_count;
+	td->rx_stats.fcs_error[qid] += fcs_err_count;
+	td->rx_stats.len_mismatch += mac_rx_len_mismatch;
+
+	dev_kfree_skb(skb);
+
+	return ret;
+}
+
+static void
+mt7996_tm_reset_trx_stats(struct mt76_phy *mphy)
+{
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+
+	memset(&mphy->test.rx_stats, 0, sizeof(mphy->test.rx_stats));
+	mt7996_tm_set(dev, SET_ID(TRX_COUNTER_RESET), 0);
+}
+
+static int
+mt7996_tm_get_tx_stats(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	int ret;
+
+	if (td->state != MT76_TM_STATE_TX_FRAMES)
+		return 0;
+
+	ret = mt7996_tm_get(dev, GET_ID(TXED_COUNT), 0, &td->tx_done);
+	if (ret)
+		return ret;
+
+	td->tx_pending = td->tx_count - td->tx_done;
+
+	return ret;
+}
+
+static int
+mt7996_tm_dump_stats(struct mt76_phy *mphy, struct sk_buff *msg)
+{
+	struct mt7996_phy *phy = mphy->priv;
+	void *rx, *rssi;
+	int i;
+
+	mt7996_tm_set(phy->dev, SET_ID(BAND_IDX), mphy->band_idx);
+	mt7996_tm_get_rx_stats(phy);
+	mt7996_tm_get_tx_stats(phy);
+
+	rx = nla_nest_start(msg, MT76_TM_STATS_ATTR_LAST_RX);
+	if (!rx)
+		return -ENOMEM;
+
+	if (nla_put_s32(msg, MT76_TM_RX_ATTR_FREQ_OFFSET, phy->test.last_freq_offset))
+		return -ENOMEM;
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_RCPI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_rcpi); i++)
+		if (nla_put_u8(msg, i, phy->test.last_rcpi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_RSSI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_rssi); i++)
+		if (nla_put_s8(msg, i, phy->test.last_rssi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_IB_RSSI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_ib_rssi); i++)
+		if (nla_put_s8(msg, i, phy->test.last_ib_rssi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_WB_RSSI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_wb_rssi); i++)
+		if (nla_put_s8(msg, i, phy->test.last_wb_rssi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	if (nla_put_u8(msg, MT76_TM_RX_ATTR_SNR, phy->test.last_snr))
+		return -ENOMEM;
+
+	nla_nest_end(msg, rx);
+
+	return 0;
+}
+
+static int
+mt7996_tm_write_back_to_efuse(struct mt7996_dev *dev)
+{
+	struct mt7996_mcu_eeprom_info req = {
+		.tag = cpu_to_le16(UNI_EFUSE_ACCESS),
+		.len = cpu_to_le16(sizeof(req) - 4),
+	};
+	u8 read_buf[MT76_TM_EEPROM_BLOCK_SIZE], *eeprom = dev->mt76.eeprom.data;
+	int i, ret = -EINVAL;
+
+	/* prevent from damaging chip id in efuse */
+	if (mt76_chip(&dev->mt76) != get_unaligned_le16(eeprom))
+		goto out;
+
+	for (i = 0; i < MT7996_EEPROM_SIZE; i += MT76_TM_EEPROM_BLOCK_SIZE) {
+		req.addr = cpu_to_le32(i);
+		memcpy(req.data, eeprom + i, MT76_TM_EEPROM_BLOCK_SIZE);
+
+		ret = mt7996_mcu_get_eeprom(dev, i, read_buf, sizeof(read_buf));
+		if (ret) {
+			if (ret != -EINVAL)
+				return ret;
+
+			memset(read_buf, 0, MT76_TM_EEPROM_BLOCK_SIZE);
+		}
+
+		if (!memcmp(req.data, read_buf, MT76_TM_EEPROM_BLOCK_SIZE))
+			continue;
+
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),
+					&req, sizeof(req), true);
+		if (ret)
+			return ret;
+	}
+
+out:
+	return ret;
+}
+
+static int
+mt7996_tm_set_eeprom(struct mt76_phy *mphy, u32 offset, u8 *val, u8 action)
+{
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	u8 *eeprom = dev->mt76.eeprom.data;
+	int ret = 0;
+
+	if (offset >= MT7996_EEPROM_SIZE)
+		return -EINVAL;
+
+	switch (action) {
+	case MT76_TM_EEPROM_ACTION_UPDATE_DATA:
+		memcpy(eeprom + offset, val, MT76_TM_EEPROM_BLOCK_SIZE);
+		break;
+	case MT76_TM_EEPROM_ACTION_UPDATE_BUFFER_MODE:
+		ret = mt7996_mcu_set_eeprom(dev);
+		break;
+	case MT76_TM_EEPROM_ACTION_WRITE_TO_EFUSE:
+		ret = mt7996_tm_write_back_to_efuse(dev);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+const struct mt76_testmode_ops mt7996_testmode_ops = {
+	.set_state = mt7996_tm_set_state,
+	.set_params = mt7996_tm_set_params,
+	.dump_stats = mt7996_tm_dump_stats,
+	.reset_rx_stats = mt7996_tm_reset_trx_stats,
+	.tx_stop = mt7996_tm_tx_stop,
+	.set_eeprom = mt7996_tm_set_eeprom,
+	.dump_precal = mt7996_tm_dump_precal,
+};
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/testmode.h b/drivers/net/wireless/mediatek/mt76/mt7996/testmode.h
new file mode 100644
index 000000000000..ba1767aed195
--- /dev/null
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/testmode.h
@@ -0,0 +1,378 @@
+/* SPDX-License-Identifier: ISC */
+/* Copyright (C) 2020 MediaTek Inc. */
+
+#ifndef __MT7996_TESTMODE_H
+#define __MT7996_TESTMODE_H
+
+enum {
+	TM_CBW_20MHZ,
+	TM_CBW_40MHZ,
+	TM_CBW_80MHZ,
+	TM_CBW_10MHZ,
+	TM_CBW_5MHZ,
+	TM_CBW_160MHZ,
+	TM_CBW_8080MHZ,
+	TM_CBW_320MHZ = 12,
+};
+
+/* BW defined in FW hal_cal_flow_rom.h */
+enum {
+	FW_CDBW_20MHZ,
+	FW_CDBW_40MHZ,
+	FW_CDBW_80MHZ,
+	FW_CDBW_160MHZ,
+	FW_CDBW_320MHZ,
+	FW_CDBW_5MHZ,
+	FW_CDBW_10MHZ,
+	FW_CDBW_8080MHZ,
+};
+
+enum {
+	BF_CDBW_20MHZ,
+	BF_CDBW_40MHZ,
+	BF_CDBW_80MHZ,
+	BF_CDBW_160MHZ,
+	BF_CDBW_320MHZ,
+	BF_CDBW_10MHZ = BF_CDBW_320MHZ,
+	BF_CDBW_5MHZ,
+	BF_CDBW_8080MHZ,
+};
+
+#define FIRST_CONTROL_CHAN_BITMAP_BW40		2
+#define FIRST_CONTROL_CHAN_BITMAP_BW80		4
+#define FIRST_CONTROL_CHAN_BITMAP_BW160		0x10010101
+
+enum bw_mapping_method {
+	BW_MAP_NL_TO_FW,
+	BW_MAP_NL_TO_TM,
+	BW_MAP_NL_TO_BF,
+	BW_MAP_NL_TO_MHZ,
+	BW_MAP_NL_TO_CONTROL_BITMAP_5G,
+
+	NUM_BW_MAP,
+};
+
+enum rate_mapping_type {
+	RATE_MODE_TO_PHY,
+	RATE_MODE_TO_LM,
+
+	NUM_RATE_MAP,
+};
+
+struct tm_cal_param {
+	__le32 func_data;
+	u8 band_idx;
+	u8 rsv[3];
+};
+
+struct mt7996_tm_rf_test {
+	__le16 tag;
+	__le16 len;
+
+	u8 action;
+	u8 icap_len;
+	u8 _rsv[2];
+	union {
+		__le32 op_mode;
+		__le32 freq;
+
+		struct {
+			__le32 func_idx;
+			union {
+				__le32 func_data;
+				__le32 cal_dump;
+				struct tm_cal_param cal_param;
+				u8 _pad[80];
+			} param;
+		} rf;
+	} op;
+} __packed;
+
+struct mt7996_tm_req {
+	u8 _rsv[4];
+
+	struct mt7996_tm_rf_test rf_test;
+} __packed;
+
+struct mt7996_tm_rf_test_data {
+	__le32 cal_idx;
+	__le32 cal_type;
+	u8 cal_data[0];
+} __packed;
+
+struct mt7996_tm_rf_test_result {
+	__le32 func_idx;
+	__le32 payload_length;
+	u8 data[0];
+};
+
+struct mt7996_tm_event {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+	struct mt7996_tm_rf_test_result result;
+} __packed;
+
+#define RF_TEST_RE_CAL		0x01
+
+enum {
+	RF_ACTION_SWITCH_TO_RF_TEST,
+	RF_ACTION_IN_RF_TEST,
+	RF_ACTION_SET = 3,
+	RF_ACTION_GET,
+};
+
+#define RF_TEST_ICAP_LEN	120
+
+enum {
+	RF_OPER_NORMAL,
+	RF_OPER_RF_TEST,
+	RF_OPER_ICAP,
+	RF_OPER_ICAP_OVERLAP,
+	RF_OPER_WIFI_SPECTRUM,
+};
+
+enum {
+	UNI_RF_TEST_CTRL,
+};
+
+#define RF_CMD(cmd)		RF_TEST_CMD_##cmd
+
+enum {
+	RF_TEST_CMD_STOP_TEST = 0,
+	RF_TEST_CMD_START_TX = 1,
+	RF_TEST_CMD_START_RX = 2,
+	RF_TEST_CMD_CONT_WAVE = 10,
+	RF_TEST_CMD_TX_COMMIT = 18,
+	RF_TEST_CMD_RX_COMMIT = 19,
+};
+
+#define SET_ID(id)		RF_TEST_ID_SET_##id
+#define GET_ID(id)		RF_TEST_ID_GET_##id
+
+enum {
+	RF_TEST_ID_SET_COMMAND = 1,
+	RF_TEST_ID_SET_POWER = 2,
+	RF_TEST_ID_SET_TX_RATE = 3,
+	RF_TEST_ID_SET_TX_MODE = 4,
+	RF_TEST_ID_SET_TX_LEN = 6,
+	RF_TEST_ID_SET_TX_COUNT = 7,
+	RF_TEST_ID_SET_IPG = 8,
+	RF_TEST_ID_SET_GI = 16,
+	RF_TEST_ID_SET_STBC = 17,
+	RF_TEST_ID_SET_CHAN_FREQ = 18,
+	RF_TEST_ID_GET_TXED_COUNT = 32,
+	RF_TEST_ID_SET_CONT_WAVE_MODE = 65,
+	RF_TEST_ID_SET_DA = 68,
+	RF_TEST_ID_SET_SA = 69,
+	RF_TEST_ID_SET_CBW = 71,
+	RF_TEST_ID_SET_DBW = 72,
+	RF_TEST_ID_SET_PRIMARY_CH = 73,
+	RF_TEST_ID_SET_ENCODE_MODE = 74,
+	RF_TEST_ID_SET_BAND = 90,
+	RF_TEST_ID_SET_TRX_COUNTER_RESET = 91,
+	RF_TEST_ID_SET_MAC_HEADER = 101,
+	RF_TEST_ID_SET_SEQ_CTRL = 102,
+	RF_TEST_ID_SET_PAYLOAD = 103,
+	RF_TEST_ID_SET_BAND_IDX = 104,
+	RF_TEST_ID_SET_RX_PATH = 106,
+	RF_TEST_ID_SET_FREQ_OFFSET = 107,
+	RF_TEST_ID_GET_FREQ_OFFSET = 108,
+	RF_TEST_ID_SET_TX_PATH = 113,
+	RF_TEST_ID_SET_NSS = 114,
+	RF_TEST_ID_SET_ANT_MASK = 115,
+	RF_TEST_ID_SET_IBF_ENABLE = 126,
+	RF_TEST_ID_SET_EBF_ENABLE = 127,
+	RF_TEST_ID_GET_TX_POWER = 136,
+	RF_TEST_ID_SET_RX_MU_AID = 157,
+	RF_TEST_ID_SET_HW_TX_MODE = 167,
+	RF_TEST_ID_SET_PUNCTURE = 168,
+	RF_TEST_ID_SET_FREQ_OFFSET_C2 = 171,
+	RF_TEST_ID_GET_FREQ_OFFSET_C2 = 172,
+	RF_TEST_ID_SET_CFG_ON = 176,
+	RF_TEST_ID_SET_CFG_OFF = 177,
+	RF_TEST_ID_SET_BSSID = 189,
+	RF_TEST_ID_SET_TX_TIME = 190,
+	RF_TEST_ID_SET_MAX_PE = 191,
+	RF_TEST_ID_SET_AID_OFFSET = 204,
+};
+
+#define POWER_CTRL(type)	UNI_TXPOWER_##type##_CTRL
+
+struct mt7996_tm_rx_stat_user_ctrl {
+	__le16 tag;
+	__le16 len;
+
+	u8 band_idx;
+	u8 rsv;
+	__le16 user_idx;
+} __packed;
+
+struct mt7996_tm_rx_stat_all {
+	__le16 tag;
+	__le16 len;
+
+	u8 band_idx;
+	u8 rsv[3];
+} __packed;
+
+struct mt7996_tm_rx_req {
+	u8 band;
+	u8 _rsv[3];
+
+	union {
+		struct mt7996_tm_rx_stat_user_ctrl user_ctrl;
+		struct mt7996_tm_rx_stat_all rx_stat_all;
+	};
+} __packed;
+
+enum {
+	UNI_TM_RX_STAT_SET_USER_CTRL = 7,
+	UNI_TM_RX_STAT_GET_ALL_V2 = 9,
+};
+
+struct rx_band_info {
+	/* mac part */
+	__le16 mac_rx_fcs_err_cnt;
+	__le16 mac_rx_len_mismatch;
+	__le16 mac_rx_fcs_ok_cnt;
+	u8 rsv1[2];
+	__le32 mac_rx_mdrdy_cnt;
+
+	/* phy part */
+	__le16 phy_rx_fcs_err_cnt_cck;
+	__le16 phy_rx_fcs_err_cnt_ofdm;
+	__le16 phy_rx_pd_cck;
+	__le16 phy_rx_pd_ofdm;
+	__le16 phy_rx_sig_err_cck;
+	__le16 phy_rx_sfd_err_cck;
+	__le16 phy_rx_sig_err_ofdm;
+	__le16 phy_rx_tag_err_ofdm;
+	__le16 phy_rx_mdrdy_cnt_cck;
+	__le16 phy_rx_mdrdy_cnt_ofdm;
+} __packed;
+
+struct rx_band_info_ext {
+	/* mac part */
+	__le32 mac_rx_mpdu_cnt;
+
+	/* phy part */
+	u8 rsv[4];
+} __packed;
+
+struct rx_common_info {
+	__le16 rx_fifo_full;
+	u8 rsv[2];
+	__le32 aci_hit_low;
+	__le32 aci_hit_high;
+} __packed;
+
+struct rx_common_info_ext {
+	__le32 driver_rx_count;
+	__le32 sinr;
+	__le32 mu_pkt_count;
+
+	/* mac part */
+	u8 _rsv[4];
+
+	/* phy part */
+	u8 sig_mcs;
+	u8 rsv[3];
+} __packed;
+
+struct rx_rxv_info {
+	__le16 rcpi;
+	s16 rssi;
+	s16 snr;
+	s16 adc_rssi;
+} __packed;
+
+struct rx_rssi_info {
+	s8 ib_rssi;
+	s8 wb_rssi;
+	u8 rsv[2];
+} __packed;
+
+struct rx_user_info {
+	s32 freq_offset;
+	s32 snr;
+	__le32 fcs_err_count;
+} __packed;
+
+struct rx_user_info_ext {
+	s8 ne_var_db_all_user;
+	u8 rsv[3];
+} __packed;
+
+#define MAX_ANTENNA_NUM		8
+#define MAX_USER_NUM		16
+
+struct mt7996_tm_rx_event_stat_all {
+	__le16 tag;
+	__le16 len;
+
+	struct rx_band_info band_info;
+	struct rx_band_info_ext band_info_ext;
+	struct rx_common_info common_info;
+	struct rx_common_info_ext common_info_ext;
+
+	/* RXV info */
+	struct rx_rxv_info rxv_info[MAX_ANTENNA_NUM];
+
+	/* RSSI info */
+	struct rx_rssi_info fagc[MAX_ANTENNA_NUM];
+	struct rx_rssi_info inst[MAX_ANTENNA_NUM];
+
+	/* User info */
+	struct rx_user_info user_info[MAX_USER_NUM];
+	struct rx_user_info_ext user_info_ext[MAX_USER_NUM];
+} __packed;
+
+struct mt7996_tm_rx_event {
+	u8 _rsv[4];
+
+	union {
+		struct mt7996_tm_rx_event_stat_all rx_stat_all;
+	};
+} __packed;
+
+enum {
+	RDD_SET_IPI_CR_INIT,		/* CR initialization */
+	RDD_SET_IPI_HIST_RESET,		/* Reset IPI histogram counter */
+	RDD_SET_IDLE_POWER,		/* Idle power info */
+	RDD_SET_IPI_HIST_NUM
+};
+
+enum {
+	RDD_IPI_HIST_0,			/* IPI count for power <= -92 (dBm) */
+	RDD_IPI_HIST_1,			/* IPI count for -92 < power <= -89 (dBm) */
+	RDD_IPI_HIST_2,			/* IPI count for -89 < power <= -86 (dBm) */
+	RDD_IPI_HIST_3,			/* IPI count for -86 < power <= -83 (dBm) */
+	RDD_IPI_HIST_4,			/* IPI count for -83 < power <= -80 (dBm) */
+	RDD_IPI_HIST_5,			/* IPI count for -80 < power <= -75 (dBm) */
+	RDD_IPI_HIST_6,			/* IPI count for -75 < power <= -70 (dBm) */
+	RDD_IPI_HIST_7,			/* IPI count for -70 < power <= -65 (dBm) */
+	RDD_IPI_HIST_8,			/* IPI count for -65 < power <= -60 (dBm) */
+	RDD_IPI_HIST_9,			/* IPI count for -60 < power <= -55 (dBm) */
+	RDD_IPI_HIST_10,		/* IPI count for -55 < power        (dBm) */
+	RDD_IPI_FREE_RUN_CNT,		/* IPI count for counter++ per 8 us */
+	RDD_IPI_HIST_ALL_CNT,		/* Get all IPI */
+	RDD_IPI_HIST_0_TO_10_CNT,	/* Get IPI histogram 0 to 10 */
+	RDD_IPI_HIST_2_TO_10_CNT,	/* Get IPI histogram 2 to 10 */
+	RDD_TX_ASSERT_TIME,		/* Get band 1 TX assert time */
+	RDD_IPI_HIST_NUM
+};
+
+#define POWER_INDICATE_HIST_MAX		RDD_IPI_FREE_RUN_CNT
+#define IPI_HIST_TYPE_NUM		(POWER_INDICATE_HIST_MAX + 1)
+
+struct mt7996_tm_rdd_ipi_ctrl {
+	u8 ipi_hist_idx;
+	u8 band_idx;
+	u8 rsv[2];
+	__le32 ipi_hist_val[IPI_HIST_TYPE_NUM];
+	__le32 tx_assert_time;		/* unit: us */
+} __packed;
+
+#endif
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/trace.c b/drivers/net/wireless/mediatek/mt76/mt7996/trace.c
new file mode 100644
index 000000000000..ba36f79a3acb
--- /dev/null
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/trace.c
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: ISC */
+/*
+ * Copyright (C) 2022 MediaTek Inc.
+ */
+
+#include <linux/module.h>
+
+#ifndef __CHECKER__
+#define CREATE_TRACE_POINTS
+#include "mt7996_trace.h"
+
+#endif
diff --git a/drivers/net/wireless/mediatek/mt76/scripts/single-sku.pl b/drivers/net/wireless/mediatek/mt76/scripts/single-sku.pl
new file mode 100644
index 000000000000..9e381d2a21b9
--- /dev/null
+++ b/drivers/net/wireless/mediatek/mt76/scripts/single-sku.pl
@@ -0,0 +1,333 @@
+#!/usr/bin/perl
+use strict;
+use 5.010;
+
+my $indent = 0;
+
+my %chip_types = (
+	mt7615 => "mt7615",
+	mt7622 => "mt7615",
+	mt7663 => "mt7615"
+);
+
+my $chip = shift @ARGV;
+my $chip_type;
+
+$chip or usage();
+
+sub usage() {
+	print STDERR <<EOF;
+Usage: $0 <chip> [options] <file> [[options] <file>...]
+
+Options:
+	country=XX:		Set country code
+	regdomain=XX:		Set regdomain
+
+Multiple country codes/regdomains per file are supported
+
+EOF
+	exit(1);
+}
+
+sub convert_array($) {
+	my $array = shift;
+
+	return unless $array;
+	foreach my $i (0 .. $#{$array}) {
+		$array->[$i] = int($array->[$i] * 2);
+	}
+
+	return $array;
+}
+
+sub parse_channel($$$) {
+	my $band = shift;
+	my $channels = $band->{channels};
+
+	my $ch = shift;
+	my $line = shift;
+
+	my @data = split /\s+/, $line;
+	my $data = join(" ", @data);
+
+	my $channel = {
+		chlist => [ ],
+		data => $data,
+		mcs => [],
+	};
+
+	$channels->{$ch} = $channel;
+
+	$band->{type} eq '2' and do {
+		$channel->{"rates-cck"} = convert_array([
+			$data[0], $data[0],
+			$data[1], $data[1]
+		]);
+		splice @data, 0, 2;
+	};
+
+	$channel->{"rates-ofdm"} = convert_array([
+		$data[0], $data[0],
+		$data[1], $data[1],
+		$data[2], $data[2],
+		$data[3], $data[4]
+	]);
+	splice @data, 0, 5;
+
+	my @bw = ( "bw20", "bw40", "bw80", "bw160" );
+	$band->{type} eq '2' and @bw = ( "bw20", "bw40" );
+
+	foreach my $bw (@bw) {
+		push @{$channel->{"rates-mcs"}}, convert_array([
+			$data[0],
+			$data[1], $data[1],
+			$data[2], $data[2],
+			$data[3], $data[3],
+			$data[4],
+			$data[5],
+			$data[6],
+		]);
+		splice @data, 0, 7;
+	};
+
+	@data > 0 and do {
+		$channel->{"txs-delta"} = convert_array([ reverse splice @data, 0, 3 ]);
+		delete $channel->{"txs-delta"} if join("", @{$channel->{"txs-delta"}}) =~ /^0+$/;
+	};
+}
+
+sub read_data($) {
+	my $file = shift;
+	my $band;
+	my %bands;
+
+	open FILE, "<", $file or die "Can't open file $file\n";
+	while (<FILE>) {
+		chomp;
+
+		/^Band: (2.4|5)G / and do {
+			$band = $1;
+			$band eq '2.4' and $band = "2";
+			$bands{$band} = {
+				type => $band,
+				channels => {},
+			};
+		};
+		/^Ch(\d+)\s+(.+?)\s*$/ and parse_channel($bands{$band}, $1, $2);
+	}
+	close FILE;
+
+	return \%bands;
+}
+
+sub find_matching_channel($$) {
+	my $band = shift;
+	my $channels = $band->{channels};
+
+	my $ch_idx = shift;
+	my $ch = $channels->{$ch_idx};
+
+	foreach my $cur (sort { $a <=> $b } keys %$channels) {
+		my $cur_ch;
+
+		return undef if $cur >= $ch_idx;
+
+		$cur_ch = $channels->{$cur};
+		$cur_ch->{data} eq $ch->{data} and return $cur_ch;
+	}
+}
+
+sub optimize_channels($) {
+	my $band = shift;
+	my $channels = $band->{channels};
+	my $prev;
+	my $prev_chlist;
+
+	foreach my $ch_idx (sort { $a <=> $b } keys %$channels) {
+		my $ch = $channels->{$ch_idx};
+
+		$prev and ($ch->{data} eq $prev->{data}) and do {
+			$prev_chlist->[1] = $ch_idx;
+			delete $channels->{$ch_idx};
+			next;
+		};
+
+		$prev = find_matching_channel($band, $ch_idx);
+		if ($prev) {
+			delete $channels->{$ch_idx};
+		} else {
+			$prev = $ch;
+		}
+
+		$prev_chlist = [ $ch_idx, $ch_idx ];
+		push @{$prev->{chlist}}, $prev_chlist;
+	}
+}
+
+sub add_line {
+	my $line = shift;
+	print "".("\t" x $indent).$line;
+}
+
+sub array_str($) {
+	my $a = shift;
+
+	return "<".join(" ", @$a).">";
+}
+
+sub string_array_str($) {
+	my $a = shift;
+
+	return join(", ", map { "\"$_\"" } @$a);
+}
+
+sub add_named_array($$) {
+	my $ch = shift;
+	my $type = shift;
+
+	return unless $ch->{$type};
+	add_line("$type = ".array_str($ch->{$type}).";\n");
+}
+
+sub add_named_string_array($$) {
+	my $ch = shift;
+	my $type = shift;
+
+	return unless $ch->{$type} and @{$ch->{$type}} > 0;
+	add_line("$type = ".string_array_str($ch->{$type}).";\n");
+}
+
+sub add_multi_array($$) {
+	my $name = shift;
+	my $a = shift;
+
+	add_line("$name =");
+	if (@$a > 1) {
+		my $first = 1;
+
+		print "\n";
+		$indent++;
+		foreach my $v (@$a) {
+			$first or print ",\n";
+			undef $first;
+
+			add_line(array_str($v));
+		}
+		$indent--;
+	} else {
+		print " ".array_str($a->[0]);
+	}
+	print ";\n";
+}
+
+sub print_txpower($) {
+	my $ch = shift;
+	my @data;
+
+	add_named_array($ch, "txs-delta");
+	add_named_array($ch, "rates-cck");
+	add_named_array($ch, "rates-ofdm");
+
+	my $prev;
+	foreach my $v (@{$ch->{"rates-mcs"}}) {
+		my $val = [1, @{$v}];
+
+		if ($prev and (array_str($v) eq array_str($prev))) {
+			$data[$#data]->[0]++;
+		} else {
+			push @data, $val;
+		}
+
+		$prev = $v;
+	}
+
+	add_multi_array("rates-mcs", \@data);
+};
+
+sub print_channels($) {
+	my $band = shift;
+	my $channels = $band->{channels};
+	my $r = 0;
+
+	foreach my $ch_idx (sort { $a <=> $b } keys %$channels) {
+		my $ch = $channels->{$ch_idx};
+		my $first = 1;
+
+		add_line("r$r {\n");
+		$indent++;
+
+		add_multi_array("channels", $ch->{chlist});
+		print_txpower($ch);
+
+		$indent--;
+		add_line("};\n");
+
+		$r++;
+	}
+}
+
+sub print_bands($) {
+	my $bands = shift;
+
+	foreach my $band_idx (sort keys %$bands) {
+		my $band = $bands->{$band_idx};
+
+		optimize_channels($band);
+
+		add_line("txpower-".$band->{type}."g {\n");
+		$indent++;
+
+		print_channels($band);
+
+		$indent--;
+		add_line("};\n");
+	};
+}
+
+my @files;
+my $cur = {};
+
+$chip_type = $chip_types{$chip} or die "Unsupported chip type '$chip', supported chip types: ".join(", ",sort keys %chip_types)."\n";
+
+while (@ARGV > 0) {
+	my $arg = shift @ARGV;
+
+	$cur or $cur = {
+		country => [],
+		regdomain => [],
+	};
+
+	if ($arg =~ /country=(\w+)$/) {
+		push @{$cur->{country}}, $1;
+	} elsif ($arg =~ /regdomain=(\w+)$/) {
+		push @{$cur->{regdomain}}, $1;
+	} else {
+		$cur->{bands} = read_data($arg);
+		push @files, $cur;
+		$cur = undef;
+	}
+}
+
+
+add_line("power-limits {\n");
+$indent++;
+
+my $count = 0;
+
+foreach my $domain (@files) {
+	my $name = "r$count";
+	$count++;
+
+	add_line("$name {\n");
+	$indent++;
+
+	add_named_string_array($domain, "country");
+	add_named_string_array($domain, "regdomain");
+	print_bands($domain->{bands});
+
+	$indent--;
+	add_line("};\n");
+}
+
+$indent--;
+add_line("};\n");
diff --git a/drivers/net/wireless/mediatek/mt76/testmode.c b/drivers/net/wireless/mediatek/mt76/testmode.c
index ca4feccf38ca..d1344fdeff7e 100644
--- a/drivers/net/wireless/mediatek/mt76/testmode.c
+++ b/drivers/net/wireless/mediatek/mt76/testmode.c
@@ -2,11 +2,13 @@
 /* Copyright (C) 2020 Felix Fietkau <nbd@nbd.name> */

 #include <linux/random.h>
+#include "mt76_connac.h"
 #include "mt76.h"

 const struct nla_policy mt76_tm_policy[NUM_MT76_TM_ATTRS] = {
	[MT76_TM_ATTR_RESET] = { .type = NLA_FLAG },
	[MT76_TM_ATTR_STATE] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_SKU_EN] = { .type = NLA_U8 },
	[MT76_TM_ATTR_TX_COUNT] = { .type = NLA_U32 },
	[MT76_TM_ATTR_TX_LENGTH] = { .type = NLA_U32 },
	[MT76_TM_ATTR_TX_RATE_MODE] = { .type = NLA_U8 },
@@ -25,9 +27,21 @@ const struct nla_policy mt76_tm_policy[NUM_MT76_TM_ATTRS] = {
	[MT76_TM_ATTR_TX_TIME] = { .type = NLA_U32 },
	[MT76_TM_ATTR_FREQ_OFFSET] = { .type = NLA_U32 },
	[MT76_TM_ATTR_DRV_DATA] = { .type = NLA_NESTED },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_BW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_PATH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_THRESHOLD] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_PERIOD] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_IPI_RESET] = { .type = NLA_U8 },
 };
 EXPORT_SYMBOL_GPL(mt76_tm_policy);

+static inline bool mt76_testmode_offload(struct mt76_dev *dev)
+{
+	return is_mt7996(dev) || is_mt7992(dev);
+}
+
 void mt76_testmode_tx_pending(struct mt76_phy *phy)
 {
	struct mt76_testmode_data *td = &phy->test;
@@ -82,6 +96,11 @@ mt76_testmode_max_mpdu_len(struct mt76_phy *phy, u8 tx_rate_mode)
		    IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991)
			return IEEE80211_MAX_MPDU_LEN_VHT_7991;
		return IEEE80211_MAX_MPDU_LEN_VHT_11454;
+	case MT76_TM_TX_MODE_EHT_SU:
+	case MT76_TM_TX_MODE_EHT_TRIG:
+	case MT76_TM_TX_MODE_EHT_MU:
+		/* TODO: check the limit */
+		return UINT_MAX;
	case MT76_TM_TX_MODE_CCK:
	case MT76_TM_TX_MODE_OFDM:
	default:
@@ -174,6 +193,114 @@ int mt76_testmode_alloc_skb(struct mt76_phy *phy, u32 len)
 }
 EXPORT_SYMBOL(mt76_testmode_alloc_skb);

+static int
+mt76_testmode_tx_config_check(struct mt76_phy *phy)
+{
+	struct mt76_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->test;
+	struct cfg80211_chan_def *chandef = &phy->chandef;
+	u8 max_nss = hweight8(phy->antenna_mask);
+	enum invalid_type {
+		INVALID_TYPE_TX_LEN,
+		INVALID_TYPE_RATE_MODE,
+		INVALID_TYPE_RATE_IDX,
+		INVALID_TYPE_RATE_NSS,
+		INVALID_TYPE_LDPC,
+	} type;
+	static const char * const invalid_msg[] = {
+		[INVALID_TYPE_TX_LEN] = "tx length",
+		[INVALID_TYPE_RATE_MODE] = "tx rate mode",
+		[INVALID_TYPE_RATE_IDX] = "tx rate idx",
+		[INVALID_TYPE_RATE_NSS] = "tx rate nss",
+		[INVALID_TYPE_LDPC] = "tx rate ldpc",
+	};
+	u32 max_tx_len;
+
+	max_tx_len = mt76_testmode_max_mpdu_len(phy, td->tx_rate_mode);
+	if (max_tx_len < td->tx_mpdu_len ||
+	    sizeof(struct ieee80211_hdr) > td->tx_mpdu_len) {
+		type = INVALID_TYPE_TX_LEN;
+		goto fail;
+	}
+
+	if (td->tx_antenna_mask)
+		max_nss = min_t(u8, max_nss, hweight8(td->tx_antenna_mask));
+
+	switch (td->tx_rate_mode) {
+	case MT76_TM_TX_MODE_CCK:
+		if (chandef->chan->band != NL80211_BAND_2GHZ) {
+			type = INVALID_TYPE_RATE_MODE;
+			goto fail;
+		}
+		if (td->tx_rate_idx > 3) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_OFDM:
+		if (td->tx_rate_idx > 7) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_HT:
+		if (td->tx_rate_idx > 8 * max_nss - 1) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_VHT:
+		if (td->tx_rate_nss > max_nss) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (td->tx_rate_idx > 9) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_HE_SU:
+	case MT76_TM_TX_MODE_HE_EXT_SU:
+	case MT76_TM_TX_MODE_HE_TB:
+	case MT76_TM_TX_MODE_HE_MU:
+		if (td->tx_rate_nss > max_nss) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (td->tx_rate_idx > 11) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (chandef->width > NL80211_CHAN_WIDTH_20 &&
+		    !td->tx_rate_ldpc) {
+			type = INVALID_TYPE_LDPC;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_EHT_SU:
+	case MT76_TM_TX_MODE_EHT_TRIG:
+	case MT76_TM_TX_MODE_EHT_MU:
+		if (td->tx_rate_idx > 15) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (chandef->width > NL80211_CHAN_WIDTH_20 &&
+		    !td->tx_rate_ldpc) {
+			type = INVALID_TYPE_LDPC;
+			goto fail;
+		}
+		break;
+	default:
+		type = INVALID_TYPE_RATE_MODE;
+		goto fail;
+	}
+
+	return 0;
+fail:
+	dev_err(dev->dev, "Invalid %s\n", invalid_msg[type]);
+	return -EINVAL;
+}
+
 static int
 mt76_testmode_tx_init(struct mt76_phy *phy)
 {
@@ -183,6 +310,13 @@ mt76_testmode_tx_init(struct mt76_phy *phy)
	u8 max_nss = hweight8(phy->antenna_mask);
	int ret;

+	ret = mt76_testmode_tx_config_check(phy);
+	if (ret)
+		return ret;
+
+	if (mt76_testmode_offload(phy->dev))
+		return 0;
+
	ret = mt76_testmode_alloc_skb(phy, td->tx_mpdu_len);
	if (ret)
		return ret;
@@ -200,36 +334,17 @@ mt76_testmode_tx_init(struct mt76_phy *phy)

	switch (td->tx_rate_mode) {
	case MT76_TM_TX_MODE_CCK:
-		if (phy->chandef.chan->band != NL80211_BAND_2GHZ)
-			return -EINVAL;
-
-		if (rate->idx > 4)
-			return -EINVAL;
		break;
	case MT76_TM_TX_MODE_OFDM:
		if (phy->chandef.chan->band != NL80211_BAND_2GHZ)
			break;

-		if (rate->idx > 8)
-			return -EINVAL;
-
		rate->idx += 4;
		break;
	case MT76_TM_TX_MODE_HT:
-		if (rate->idx > 8 * max_nss &&
-			!(rate->idx == 32 &&
-			  phy->chandef.width >= NL80211_CHAN_WIDTH_40))
-			return -EINVAL;
-
		rate->flags |= IEEE80211_TX_RC_MCS;
		break;
	case MT76_TM_TX_MODE_VHT:
-		if (rate->idx > 9)
-			return -EINVAL;
-
-		if (td->tx_rate_nss > max_nss)
-			return -EINVAL;
-
		ieee80211_rate_set_vht(rate, td->tx_rate_idx, td->tx_rate_nss);
		rate->flags |= IEEE80211_TX_RC_VHT_MCS;
		break;
@@ -275,7 +390,9 @@ mt76_testmode_tx_start(struct mt76_phy *phy)
	td->tx_queued = 0;
	td->tx_done = 0;
	td->tx_pending = td->tx_count;
-	mt76_worker_schedule(&dev->tx_worker);
+
+	if (!mt76_testmode_offload(dev))
+		mt76_worker_schedule(&dev->tx_worker);
 }

 static void
@@ -284,6 +401,11 @@ mt76_testmode_tx_stop(struct mt76_phy *phy)
	struct mt76_testmode_data *td = &phy->test;
	struct mt76_dev *dev = phy->dev;

+	if (mt76_testmode_offload(dev) && dev->test_ops->tx_stop) {
+		dev->test_ops->tx_stop(phy);
+		return;
+	}
+
	mt76_worker_disable(&dev->tx_worker);

	td->tx_pending = 0;
@@ -296,22 +418,11 @@ mt76_testmode_tx_stop(struct mt76_phy *phy)
	mt76_testmode_free_skb(phy);
 }

-static inline void
-mt76_testmode_param_set(struct mt76_testmode_data *td, u16 idx)
-{
-	td->param_set[idx / 32] |= BIT(idx % 32);
-}
-
-static inline bool
-mt76_testmode_param_present(struct mt76_testmode_data *td, u16 idx)
-{
-	return td->param_set[idx / 32] & BIT(idx % 32);
-}
-
 static void
 mt76_testmode_init_defaults(struct mt76_phy *phy)
 {
	struct mt76_testmode_data *td = &phy->test;
+	u8 addr[ETH_ALEN] = {phy->band_idx, 0x11, 0x22, 0xaa, 0xbb, 0xcc};

	if (td->tx_mpdu_len > 0)
		return;
@@ -353,7 +471,7 @@ __mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state)
	if (state == MT76_TM_STATE_TX_FRAMES)
		mt76_testmode_tx_start(phy);
	else if (state == MT76_TM_STATE_RX_FRAMES) {
-		memset(&phy->test.rx_stats, 0, sizeof(phy->test.rx_stats));
+		dev->test_ops->reset_rx_stats(phy);
	}

	phy->test.state = state;
@@ -371,7 +489,8 @@ int mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state

	if (state > MT76_TM_STATE_OFF &&
	    (!test_bit(MT76_STATE_RUNNING, &phy->state) ||
-	     !(hw->conf.flags & IEEE80211_CONF_MONITOR)))
+	     (!(hw->conf.flags & IEEE80211_CONF_MONITOR) &&
+	      !phy->monitor_vif)))
		return -ENOTCONN;

	if (state != MT76_TM_STATE_IDLE &&
@@ -404,6 +523,82 @@ mt76_tm_get_u8(struct nlattr *attr, u8 *dest, u8 min, u8 max)
	return 0;
 }

+static int
+mt76_testmode_set_eeprom(struct mt76_phy *phy, struct nlattr **tb)
+{
+	struct mt76_dev *dev = phy->dev;
+	u8 action, val[MT76_TM_EEPROM_BLOCK_SIZE];
+	u32 offset = 0;
+	int err = -EINVAL;
+
+	if (!dev->test_ops->set_eeprom)
+		return -EOPNOTSUPP;
+
+	if (mt76_tm_get_u8(tb[MT76_TM_ATTR_EEPROM_ACTION], &action,
+			   0, MT76_TM_EEPROM_ACTION_MAX))
+		goto out;
+
+	if (tb[MT76_TM_ATTR_EEPROM_OFFSET]) {
+		struct nlattr *cur;
+		int rem, idx = 0;
+
+		offset = nla_get_u32(tb[MT76_TM_ATTR_EEPROM_OFFSET]);
+		if (!!(offset % MT76_TM_EEPROM_BLOCK_SIZE) ||
+		    !tb[MT76_TM_ATTR_EEPROM_VAL])
+			goto out;
+
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_EEPROM_VAL], rem) {
+			if (nla_len(cur) != 1 || idx >= ARRAY_SIZE(val))
+				goto out;
+
+			val[idx++] = nla_get_u8(cur);
+		}
+	}
+
+	err = dev->test_ops->set_eeprom(phy, offset, val, action);
+
+out:
+	return err;
+}
+
+static int
+mt76_testmode_txbf_profile_update_all_cmd(struct mt76_phy *phy, struct nlattr **tb, u32 state)
+{
+#define PARAM_UNIT	5
+#define PARAM_UNIT_5X5	6
+	static u8 pfmu_idx;
+	struct mt76_testmode_data *td = &phy->test;
+	struct mt76_dev *dev = phy->dev;
+	struct nlattr *cur;
+	u16 tmp_val[PARAM_UNIT_5X5], *val = td->txbf_param;
+	int idx, rem, ret, i = 0;
+	int param_len = hweight16(phy->chainmask) == 5 ? PARAM_UNIT_5X5 : PARAM_UNIT;
+
+	memset(td->txbf_param, 0, sizeof(td->txbf_param));
+	nla_for_each_nested(cur, tb[MT76_TM_ATTR_TXBF_PARAM], rem) {
+		if (nla_len(cur) != 2)
+			return -EINVAL;
+		idx = i % param_len;
+		tmp_val[idx] = nla_get_u16(cur);
+		if (idx == 1 && (tmp_val[idx] == 0xf0 || tmp_val[idx] == 0xff)) {
+			pfmu_idx = tmp_val[0];
+			return 0;
+		}
+		if (idx == param_len - 1) {
+			val[0] = pfmu_idx;
+			memcpy(val + 1, tmp_val, param_len * sizeof(u16));
+			if (dev->test_ops->set_params) {
+				ret = dev->test_ops->set_params(phy, tb, state);
+				if (ret)
+					return ret;
+			}
+		}
+		i++;
+	}
+
+	return 0;
+}
+
 int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
		      void *data, int len)
 {
@@ -427,6 +622,11 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,

	mutex_lock(&dev->mutex);

+	if (tb[MT76_TM_ATTR_EEPROM_ACTION]) {
+		err = mt76_testmode_set_eeprom(phy, tb);
+		goto out;
+	}
+
	if (tb[MT76_TM_ATTR_RESET]) {
		mt76_testmode_set_state(phy, MT76_TM_STATE_OFF);
		memset(td, 0, sizeof(*td));
@@ -434,12 +634,18 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,

	mt76_testmode_init_defaults(phy);

+	if (tb[MT76_TM_ATTR_SKU_EN])
+		td->sku_en = nla_get_u8(tb[MT76_TM_ATTR_SKU_EN]);
+
	if (tb[MT76_TM_ATTR_TX_COUNT])
		td->tx_count = nla_get_u32(tb[MT76_TM_ATTR_TX_COUNT]);

	if (tb[MT76_TM_ATTR_TX_RATE_IDX])
		td->tx_rate_idx = nla_get_u8(tb[MT76_TM_ATTR_TX_RATE_IDX]);

+	if (tb[MT76_TM_ATTR_IPI_PERIOD])
+		td->ipi_period = nla_get_u32(tb[MT76_TM_ATTR_IPI_PERIOD]);
+
	if (mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_MODE], &td->tx_rate_mode,
			   0, MT76_TM_TX_MODE_MAX) ||
	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_NSS], &td->tx_rate_nss,
@@ -454,7 +660,15 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_DUTY_CYCLE],
			   &td->tx_duty_cycle, 0, 99) ||
	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_POWER_CONTROL],
-			   &td->tx_power_control, 0, 1))
+			   &td->tx_power_control, 0, 1) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_AID], &td->aid, 0, 16) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_OFF_CH_SCAN_CH], &td->offchan_ch, 36, 196) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH], &td->offchan_center_ch,
+			   36, 196) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_OFF_CH_SCAN_BW],
+			   &td->offchan_bw, NL80211_CHAN_WIDTH_20_NOHT, NL80211_CHAN_WIDTH_160) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_IPI_THRESHOLD], &td->ipi_threshold, 0, 10) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_IPI_RESET], &td->ipi_reset, 0, 1))
		goto out;

	if (tb[MT76_TM_ATTR_TX_LENGTH]) {
@@ -494,7 +708,9 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			    idx >= ARRAY_SIZE(td->tx_power))
				goto out;

-			td->tx_power[idx++] = nla_get_u8(cur);
+			err = mt76_tm_get_u8(cur, &td->tx_power[idx++], 0, 63);
+			if (err)
+				return err;
		}
	}

@@ -512,6 +728,46 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
		}
	}

+	if (tb[MT76_TM_ATTR_CFG]) {
+		struct nlattr *cur;
+		int rem, idx = 0;
+
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_CFG], rem) {
+			if (nla_len(cur) != 1 || idx >= 2)
+				goto out;
+
+			if (idx == 0)
+				td->cfg.type = nla_get_u8(cur);
+			else
+				td->cfg.enable = nla_get_u8(cur);
+			idx++;
+		}
+	}
+
+	if (tb[MT76_TM_ATTR_TXBF_ACT]) {
+		struct nlattr *cur;
+		int rem, idx = 0;
+
+		if (!tb[MT76_TM_ATTR_TXBF_PARAM] ||
+		    mt76_tm_get_u8(tb[MT76_TM_ATTR_TXBF_ACT], &td->txbf_act,
+				   0, MT76_TM_TXBF_ACT_MAX))
+			goto out;
+
+		if (td->txbf_act == MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD) {
+			err = mt76_testmode_txbf_profile_update_all_cmd(phy, tb, state);
+			goto out;
+		}
+
+		memset(td->txbf_param, 0, sizeof(td->txbf_param));
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_TXBF_PARAM], rem) {
+			if (nla_len(cur) != 2 ||
+			    idx >= ARRAY_SIZE(td->txbf_param))
+				goto out;
+
+			td->txbf_param[idx++] = nla_get_u16(cur);
+		}
+	}
+
	if (dev->test_ops->set_params) {
		err = dev->test_ops->set_params(phy, tb, state);
		if (err)
@@ -561,6 +817,9 @@ mt76_testmode_dump_stats(struct mt76_phy *phy, struct sk_buff *msg)
	    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_PACKETS, rx_packets,
			      MT76_TM_STATS_ATTR_PAD) ||
	    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_FCS_ERROR, rx_fcs_error,
+			      MT76_TM_STATS_ATTR_PAD) ||
+	    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_LEN_MISMATCH,
+			      td->rx_stats.len_mismatch,
			      MT76_TM_STATS_ATTR_PAD))
		return -EMSGSIZE;

@@ -593,6 +852,18 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,

	mutex_lock(&dev->mutex);

+	if (tb[MT76_TM_ATTR_PRECAL] || tb[MT76_TM_ATTR_PRECAL_INFO]) {
+		int flag, type;
+
+		err = -EINVAL;
+		flag = tb[MT76_TM_ATTR_PRECAL] ? 1 : 0;
+		type = flag ? nla_get_u8(tb[MT76_TM_ATTR_PRECAL_INFO]) : 0;
+		if (dev->test_ops->dump_precal)
+			err = dev->test_ops->dump_precal(phy, msg, flag, type);
+
+		goto out;
+	}
+
	if (tb[MT76_TM_ATTR_STATS]) {
		err = -EINVAL;

@@ -611,6 +882,9 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
	if (nla_put_u32(msg, MT76_TM_ATTR_STATE, td->state))
		goto out;

+	if (nla_put_u8(msg, MT76_TM_ATTR_BAND_IDX, phy->band_idx))
+		goto out;
+
	if (dev->test_mtd.name &&
	    (nla_put_string(msg, MT76_TM_ATTR_MTD_PART, dev->test_mtd.name) ||
	     nla_put_u32(msg, MT76_TM_ATTR_MTD_OFFSET, dev->test_mtd.offset)))
@@ -624,6 +898,11 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_SGI, td->tx_rate_sgi) ||
	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_LDPC, td->tx_rate_ldpc) ||
	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_STBC, td->tx_rate_stbc) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_SKU_EN, td->sku_en) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_AID, td->aid) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_OFF_CH_SCAN_CH, td->offchan_ch) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH, td->offchan_center_ch) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_OFF_CH_SCAN_BW, td->offchan_bw) ||
	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_LTF) &&
	     nla_put_u8(msg, MT76_TM_ATTR_TX_LTF, td->tx_ltf)) ||
	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_ANTENNA) &&
@@ -639,7 +918,7 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER_CONTROL) &&
	     nla_put_u8(msg, MT76_TM_ATTR_TX_POWER_CONTROL, td->tx_power_control)) ||
	    (mt76_testmode_param_present(td, MT76_TM_ATTR_FREQ_OFFSET) &&
-	     nla_put_u8(msg, MT76_TM_ATTR_FREQ_OFFSET, td->freq_offset)))
+	     nla_put_u32(msg, MT76_TM_ATTR_FREQ_OFFSET, td->freq_offset)))
		goto out;

	if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER)) {
diff --git a/drivers/net/wireless/mediatek/mt76/testmode.h b/drivers/net/wireless/mediatek/mt76/testmode.h
index 1b0bcae83067..794a74f9f437 100644
--- a/drivers/net/wireless/mediatek/mt76/testmode.h
+++ b/drivers/net/wireless/mediatek/mt76/testmode.h
@@ -5,7 +5,8 @@
 #ifndef __MT76_TESTMODE_H
 #define __MT76_TESTMODE_H

-#define MT76_TM_TIMEOUT	10
+#define MT76_TM_TIMEOUT			10
+#define MT76_TM_EEPROM_BLOCK_SIZE	16

 /**
  * enum mt76_testmode_attr - testmode attributes inside NL80211_ATTR_TESTDATA
@@ -15,9 +16,11 @@
  * @MT76_TM_ATTR_RESET: reset parameters to default (flag)
  * @MT76_TM_ATTR_STATE: test state (u32), see &enum mt76_testmode_state
  *
- * @MT76_TM_ATTR_MTD_PART: mtd partition used for eeprom data (string)
+ * @MT76_TM_ATTR_MTD_PART: mtd partition or binfile used for eeprom data (string)
  * @MT76_TM_ATTR_MTD_OFFSET: offset of eeprom data within the partition (u32)
+ * @MT76_TM_ATTR_BAND_IDX: band idx of the chip (u8)
  *
+ * @MT76_TM_ATTR_SKU_EN: config txpower sku is enabled or disabled in testmode (u8)
  * @MT76_TM_ATTR_TX_COUNT: configured number of frames to send when setting
  *	state to MT76_TM_STATE_TX_FRAMES (u32)
  * @MT76_TM_ATTR_TX_PENDING: pending frames during MT76_TM_STATE_TX_FRAMES (u32)
@@ -38,6 +41,11 @@
  *
  * @MT76_TM_ATTR_STATS: statistics (nested, see &enum mt76_testmode_stats_attr)
  *
+ * @MT76_TM_ATTR_PRECAL: Pre-cal data (u8)
+ * @MT76_TM_ATTR_PRECAL_INFO: group size, dpd size, dpd_info, transmit size,
+ *                            eeprom cal indicator (u32),
+ *                            dpd_info = [dpd_per_chan_size, chan_num_2g,
+ *                                        chan_num_5g, chan_num_6g]
  * @MT76_TM_ATTR_TX_SPE_IDX: tx spatial extension index (u8)
  *
  * @MT76_TM_ATTR_TX_DUTY_CYCLE: packet tx duty cycle (u8)
@@ -47,6 +55,29 @@
  * @MT76_TM_ATTR_DRV_DATA: driver specific netlink attrs (nested)
  *
  * @MT76_TM_ATTR_MAC_ADDRS: array of nested MAC addresses (nested)
+ *
+ * @MT76_TM_ATTR_EEPROM_ACTION: eeprom setting actions
+ *	(u8, see &enum mt76_testmode_eeprom_action)
+ * @MT76_TM_ATTR_EEPROM_OFFSET: offset of eeprom data block for writing (u32)
+ * @MT76_TM_ATTR_EEPROM_VAL: values for writing into a 16-byte data block
+ *	(nested, u8 attrs)
+ *
+ * @MT76_TM_ATTR_CFG: config testmode rf feature (nested, see &mt76_testmode_cfg)
+ * @MT76_TM_ATTR_TXBF_ACT: txbf setting actions (u8)
+ * @MT76_TM_ATTR_TXBF_PARAM: txbf parameters (nested)
+ *
+ * @MT76_TM_ATTR_OFF_CH_SCAN_CH: config the channel of background chain (ZWDFS) (u8)
+ * @MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH: config the center channel of background chain (ZWDFS) (u8)
+ * @MT76_TM_ATTR_OFF_CH_SCAN_BW: config the bandwidth of background chain (ZWDFS) (u8)
+ * @MT76_TM_ATTR_OFF_CH_SCAN_PATH: config the tx path of background chain (ZWDFS) (u8)
+ *
+ * @MT76_TM_ATTR_IPI_THRESHOLD: config the IPI index you want to read (u8)
+ * @MT76_TM_ATTR_IPI_PERIOD: config the time period for reading
+ *			     the histogram of specific IPI index (u8)
+ * @MT76_TM_ATTR_IPI_ANTENNA_INDEX: config the antenna index for reading
+ *				    the histogram of specific IPI index (u8)
+ * @MT76_TM_ATTR_IPI_RESET: Reset the IPI counter
+ *
  */
 enum mt76_testmode_attr {
	MT76_TM_ATTR_UNSPEC,
@@ -56,7 +87,9 @@ enum mt76_testmode_attr {

	MT76_TM_ATTR_MTD_PART,
	MT76_TM_ATTR_MTD_OFFSET,
+	MT76_TM_ATTR_BAND_IDX,

+	MT76_TM_ATTR_SKU_EN,
	MT76_TM_ATTR_TX_COUNT,
	MT76_TM_ATTR_TX_LENGTH,
	MT76_TM_ATTR_TX_RATE_MODE,
@@ -74,6 +107,8 @@ enum mt76_testmode_attr {
	MT76_TM_ATTR_FREQ_OFFSET,

	MT76_TM_ATTR_STATS,
+	MT76_TM_ATTR_PRECAL,
+	MT76_TM_ATTR_PRECAL_INFO,

	MT76_TM_ATTR_TX_SPE_IDX,

@@ -84,6 +119,27 @@ enum mt76_testmode_attr {
	MT76_TM_ATTR_DRV_DATA,

	MT76_TM_ATTR_MAC_ADDRS,
+	MT76_TM_ATTR_AID,
+	MT76_TM_ATTR_RU_ALLOC,
+	MT76_TM_ATTR_RU_IDX,
+
+	MT76_TM_ATTR_EEPROM_ACTION,
+	MT76_TM_ATTR_EEPROM_OFFSET,
+	MT76_TM_ATTR_EEPROM_VAL,
+
+	MT76_TM_ATTR_CFG,
+	MT76_TM_ATTR_TXBF_ACT,
+	MT76_TM_ATTR_TXBF_PARAM,
+
+	MT76_TM_ATTR_OFF_CH_SCAN_CH,
+	MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH,
+	MT76_TM_ATTR_OFF_CH_SCAN_BW,
+	MT76_TM_ATTR_OFF_CH_SCAN_PATH,
+
+	MT76_TM_ATTR_IPI_THRESHOLD,
+	MT76_TM_ATTR_IPI_PERIOD,
+	MT76_TM_ATTR_IPI_ANTENNA_INDEX,
+	MT76_TM_ATTR_IPI_RESET,

	/* keep last */
	NUM_MT76_TM_ATTRS,
@@ -101,6 +157,8 @@ enum mt76_testmode_attr {
  * @MT76_TM_STATS_ATTR_RX_FCS_ERROR: number of rx packets with FCS error (u64)
  * @MT76_TM_STATS_ATTR_LAST_RX: information about the last received packet
  *	see &enum mt76_testmode_rx_attr
+ * @MT76_TM_STATS_ATTR_RX_LEN_MISMATCH: number of rx packets with length
+ *	mismatch error (u64)
  */
 enum mt76_testmode_stats_attr {
	MT76_TM_STATS_ATTR_UNSPEC,
@@ -113,6 +171,7 @@ enum mt76_testmode_stats_attr {
	MT76_TM_STATS_ATTR_RX_PACKETS,
	MT76_TM_STATS_ATTR_RX_FCS_ERROR,
	MT76_TM_STATS_ATTR_LAST_RX,
+	MT76_TM_STATS_ATTR_RX_LEN_MISMATCH,

	/* keep last */
	NUM_MT76_TM_STATS_ATTRS,
@@ -125,6 +184,7 @@ enum mt76_testmode_stats_attr {
  *
  * @MT76_TM_RX_ATTR_FREQ_OFFSET: frequency offset (s32)
  * @MT76_TM_RX_ATTR_RCPI: received channel power indicator (array, u8)
+ * @MT76_TM_RX_ATTR_RSSI: received signal strength indicator (array, s8)
  * @MT76_TM_RX_ATTR_IB_RSSI: internal inband RSSI (array, s8)
  * @MT76_TM_RX_ATTR_WB_RSSI: internal wideband RSSI (array, s8)
  * @MT76_TM_RX_ATTR_SNR: signal-to-noise ratio (u8)
@@ -134,6 +194,7 @@ enum mt76_testmode_rx_attr {

	MT76_TM_RX_ATTR_FREQ_OFFSET,
	MT76_TM_RX_ATTR_RCPI,
+	MT76_TM_RX_ATTR_RSSI,
	MT76_TM_RX_ATTR_IB_RSSI,
	MT76_TM_RX_ATTR_WB_RSSI,
	MT76_TM_RX_ATTR_SNR,
@@ -159,6 +220,14 @@ enum mt76_testmode_state {
	MT76_TM_STATE_TX_FRAMES,
	MT76_TM_STATE_RX_FRAMES,
	MT76_TM_STATE_TX_CONT,
+	MT76_TM_STATE_GROUP_PREK,
+	MT76_TM_STATE_GROUP_PREK_DUMP,
+	MT76_TM_STATE_GROUP_PREK_CLEAN,
+	MT76_TM_STATE_DPD_2G,
+	MT76_TM_STATE_DPD_5G,
+	MT76_TM_STATE_DPD_6G,
+	MT76_TM_STATE_DPD_DUMP,
+	MT76_TM_STATE_DPD_CLEAN,
	MT76_TM_STATE_ON,

	/* keep last */
@@ -177,6 +246,9 @@ enum mt76_testmode_state {
  * @MT76_TM_TX_MODE_HE_EXT_SU: 802.11ax extended-range SU
  * @MT76_TM_TX_MODE_HE_TB: 802.11ax trigger-based
  * @MT76_TM_TX_MODE_HE_MU: 802.11ax multi-user MIMO
+ * @MT76_TM_TX_MODE_EHT_SU: 802.11be single-user MIMO
+ * @MT76_TM_TX_MODE_EHT_TRIG: 802.11be trigger-based
+ * @MT76_TM_TX_MODE_EHT_MU: 802.11be multi-user MIMO
  */
 enum mt76_testmode_tx_mode {
	MT76_TM_TX_MODE_CCK,
@@ -187,10 +259,84 @@ enum mt76_testmode_tx_mode {
	MT76_TM_TX_MODE_HE_EXT_SU,
	MT76_TM_TX_MODE_HE_TB,
	MT76_TM_TX_MODE_HE_MU,
+	MT76_TM_TX_MODE_EHT_SU,
+	MT76_TM_TX_MODE_EHT_TRIG,
+	MT76_TM_TX_MODE_EHT_MU,

	/* keep last */
	NUM_MT76_TM_TX_MODES,
	MT76_TM_TX_MODE_MAX = NUM_MT76_TM_TX_MODES - 1,
 };

+/**
+ * enum mt76_testmode_eeprom_action - eeprom setting actions
+ *
+ * @MT76_TM_EEPROM_ACTION_UPDATE_DATA: update rf values to specific
+ *	eeprom data block
+ * @MT76_TM_EEPROM_ACTION_UPDATE_BUFFER_MODE: send updated eeprom data to fw
+ * @MT76_TM_EEPROM_ACTION_WRITE_TO_EFUSE: write eeprom data back to efuse
+ */
+enum mt76_testmode_eeprom_action {
+	MT76_TM_EEPROM_ACTION_UPDATE_DATA,
+	MT76_TM_EEPROM_ACTION_UPDATE_BUFFER_MODE,
+	MT76_TM_EEPROM_ACTION_WRITE_TO_EFUSE,
+
+	/* keep last */
+	NUM_MT76_TM_EEPROM_ACTION,
+	MT76_TM_EEPROM_ACTION_MAX = NUM_MT76_TM_EEPROM_ACTION - 1,
+};
+
+/**
+ * enum mt76_testmode_txbf_act - txbf action
+ *
+ * @MT76_TM_TXBF_ACT_GOLDEN_INIT: init ibf setting for golden device
+ * @MT76_TM_TXBF_ACT_INIT: init ibf setting for DUT
+ * @MT76_TM_TX_EBF_ACT_GOLDEN_INIT: init ebf setting for golden device
+ * @MT76_TM_TX_EBF_ACT_INIT: init ebf setting for DUT
+ * @MT76_TM_TXBF_ACT_UPDATE_CH: update channel info
+ * @MT76_TM_TXBF_ACT_PHASE_COMP: txbf phase compensation
+ * @MT76_TM_TXBF_ACT_TX_PREP: TX preparation for txbf
+ * @MT76_TM_TXBF_ACT_IBF_PROF_UPDATE: update ibf profile (pfmu tag, bf sta record)
+ * @MT76_TM_TXBF_ACT_EBF_PROF_UPDATE: update ebf profile
+ * @MT76_TM_TXBF_ACT_APPLY_TX: apply TX setting for txbf
+ * @MT76_TM_TXBF_ACT_PHASE_CAL: perform txbf phase calibration
+ * @MT76_TM_TXBF_ACT_PROF_UPDATE_ALL: update bf profile via instrument
+ * @MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD: update bf profile via instrument
+ * @MT76_TM_TXBF_ACT_E2P_UPDATE: write back txbf calibration result to eeprom
+ * @MT76_TM_TXBF_ACT_TRIGGER_SOUNDING: trigger beamformer to send sounding packet
+ * @MT76_TM_TXBF_ACT_STOP_SOUNDING: stop sending sounding packet
+ * @MT76_TM_TXBF_ACT_PROFILE_TAG_READ: read pfmu tag
+ * @MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE: update pfmu tag
+ * @MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID: invalidate pfmu tag
+ * @MT76_TM_TXBF_ACT_STA_REC_READ: read bf sta record
+ * @MT76_TM_TXBF_ACT_TXCMD: configure txcmd bf bit manually
+ */
+enum mt76_testmode_txbf_act {
+	MT76_TM_TXBF_ACT_GOLDEN_INIT,
+	MT76_TM_TXBF_ACT_INIT,
+	MT76_TM_TX_EBF_ACT_GOLDEN_INIT,
+	MT76_TM_TX_EBF_ACT_INIT,
+	MT76_TM_TXBF_ACT_UPDATE_CH,
+	MT76_TM_TXBF_ACT_PHASE_COMP,
+	MT76_TM_TXBF_ACT_TX_PREP,
+	MT76_TM_TXBF_ACT_IBF_PROF_UPDATE,
+	MT76_TM_TXBF_ACT_EBF_PROF_UPDATE,
+	MT76_TM_TXBF_ACT_APPLY_TX,
+	MT76_TM_TXBF_ACT_PHASE_CAL,
+	MT76_TM_TXBF_ACT_PROF_UPDATE_ALL,
+	MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD,
+	MT76_TM_TXBF_ACT_E2P_UPDATE,
+	MT76_TM_TXBF_ACT_TRIGGER_SOUNDING,
+	MT76_TM_TXBF_ACT_STOP_SOUNDING,
+	MT76_TM_TXBF_ACT_PROFILE_TAG_READ,
+	MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE,
+	MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID,
+	MT76_TM_TXBF_ACT_STA_REC_READ,
+	MT76_TM_TXBF_ACT_TXCMD,
+
+	/* keep last */
+	NUM_MT76_TM_TXBF_ACT,
+	MT76_TM_TXBF_ACT_MAX = NUM_MT76_TM_TXBF_ACT - 1,
+};
+
 #endif
diff --git a/drivers/net/wireless/mediatek/mt76/tools/CMakeLists.txt b/drivers/net/wireless/mediatek/mt76/tools/CMakeLists.txt
index 3a83e34dfe2d..6599c444bfd8 100644
--- a/drivers/net/wireless/mediatek/mt76/tools/CMakeLists.txt
+++ b/drivers/net/wireless/mediatek/mt76/tools/CMakeLists.txt
@@ -3,6 +3,13 @@ cmake_minimum_required(VERSION 2.8)
 PROJECT(mt76-test C)
 ADD_DEFINITIONS(-Os -Wall -Werror --std=gnu99 -g3)

+UNSET(backports_dir CACHE)
+FIND_PATH(
+	backports_dir
+	NAMES "mac80211/uapi/linux"
+)
+INCLUDE_DIRECTORIES("${backports_dir}/mac80211/uapi")
+
 ADD_EXECUTABLE(mt76-test main.c fields.c eeprom.c fwlog.c)
 TARGET_LINK_LIBRARIES(mt76-test nl-tiny)

diff --git a/drivers/net/wireless/mediatek/mt76/tools/eeprom.c b/drivers/net/wireless/mediatek/mt76/tools/eeprom.c
index d8fceaa567d5..cbb44d82de4c 100644
--- a/drivers/net/wireless/mediatek/mt76/tools/eeprom.c
+++ b/drivers/net/wireless/mediatek/mt76/tools/eeprom.c
@@ -132,6 +132,7 @@ mt76_eeprom_init_file(void)
 int mt76_eeprom_init(int phy)
 {
	struct nl_msg *msg;
+	int len;

	msg = unl_genl_msg(&unl, NL80211_CMD_TESTMODE, true);
	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
@@ -142,8 +143,9 @@ int mt76_eeprom_init(int phy)
		return -1;
	}

-	eeprom_file = malloc(sizeof(EEPROM_FILE_PATH_FMT) + strlen(mtd_part));
-	sprintf(eeprom_file, EEPROM_FILE_PATH_FMT, mtd_part);
+	len = sizeof(EEPROM_FILE_PATH_FMT) + strlen(mtd_part);
+	eeprom_file = malloc(len);
+	snprintf(eeprom_file, len, EEPROM_FILE_PATH_FMT, mtd_part);

	eeprom_fd = mt76_eeprom_init_file();
	if (eeprom_fd < 0)
diff --git a/drivers/net/wireless/mediatek/mt76/tools/fields.c b/drivers/net/wireless/mediatek/mt76/tools/fields.c
index e3f690896a08..f793d1a51430 100644
--- a/drivers/net/wireless/mediatek/mt76/tools/fields.c
+++ b/drivers/net/wireless/mediatek/mt76/tools/fields.c
@@ -10,6 +10,15 @@ static const char * const testmode_state[] = {
	[MT76_TM_STATE_IDLE] = "idle",
	[MT76_TM_STATE_TX_FRAMES] = "tx_frames",
	[MT76_TM_STATE_RX_FRAMES] = "rx_frames",
+	[MT76_TM_STATE_TX_CONT] = "tx_cont",
+	[MT76_TM_STATE_GROUP_PREK] = "group_prek",
+	[MT76_TM_STATE_GROUP_PREK_DUMP] = "group_prek_dump",
+	[MT76_TM_STATE_GROUP_PREK_CLEAN] = "group_prek_clean",
+	[MT76_TM_STATE_DPD_2G] = "dpd_2g",
+	[MT76_TM_STATE_DPD_5G] = "dpd_5g",
+	[MT76_TM_STATE_DPD_6G] = "dpd_6g",
+	[MT76_TM_STATE_DPD_DUMP] = "dpd_dump",
+	[MT76_TM_STATE_DPD_CLEAN] = "dpd_clean",
 };

 static const char * const testmode_tx_mode[] = {
@@ -21,6 +30,42 @@ static const char * const testmode_tx_mode[] = {
	[MT76_TM_TX_MODE_HE_EXT_SU] = "he_ext_su",
	[MT76_TM_TX_MODE_HE_TB] = "he_tb",
	[MT76_TM_TX_MODE_HE_MU] = "he_mu",
+	[MT76_TM_TX_MODE_EHT_SU] = "eht_su",
+	[MT76_TM_TX_MODE_EHT_TRIG] = "eht_tb",
+	[MT76_TM_TX_MODE_EHT_MU] = "eht_mu",
+};
+
+static const char * const testmode_offchan_bw[] = {
+	[NL80211_CHAN_WIDTH_20_NOHT] = "NOHT",
+	[NL80211_CHAN_WIDTH_20] = "20",
+	[NL80211_CHAN_WIDTH_40] = "40",
+	[NL80211_CHAN_WIDTH_80] = "80",
+	[NL80211_CHAN_WIDTH_80P80] = "80p80",
+	[NL80211_CHAN_WIDTH_160] = "160",
+};
+
+static const char * const testmode_txbf_act[] = {
+	[MT76_TM_TXBF_ACT_GOLDEN_INIT] = "golden_init",
+	[MT76_TM_TXBF_ACT_INIT] = "init",
+	[MT76_TM_TX_EBF_ACT_GOLDEN_INIT] = "ebf_golden_init",
+	[MT76_TM_TX_EBF_ACT_INIT] = "ebf_init",
+	[MT76_TM_TXBF_ACT_UPDATE_CH] = "update_ch",
+	[MT76_TM_TXBF_ACT_PHASE_COMP] = "phase_comp",
+	[MT76_TM_TXBF_ACT_TX_PREP] = "tx_prep",
+	[MT76_TM_TXBF_ACT_IBF_PROF_UPDATE] = "ibf_prof_update",
+	[MT76_TM_TXBF_ACT_EBF_PROF_UPDATE] = "ebf_prof_update",
+	[MT76_TM_TXBF_ACT_APPLY_TX] = "apply_tx",
+	[MT76_TM_TXBF_ACT_PHASE_CAL] = "phase_cal",
+	[MT76_TM_TXBF_ACT_PROF_UPDATE_ALL] = "prof_update",
+	[MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD] = "prof_update_all",
+	[MT76_TM_TXBF_ACT_E2P_UPDATE] = "e2p_update",
+	[MT76_TM_TXBF_ACT_TRIGGER_SOUNDING] = "trigger_sounding",
+	[MT76_TM_TXBF_ACT_STOP_SOUNDING] = "stop_sounding",
+	[MT76_TM_TXBF_ACT_PROFILE_TAG_READ] = "pfmu_tag_read",
+	[MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE] = "pfmu_tag_write",
+	[MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID] = "set_invalid_prof",
+	[MT76_TM_TXBF_ACT_STA_REC_READ] = "sta_rec_read",
+	[MT76_TM_TXBF_ACT_TXCMD] = "txcmd",
 };

 static void print_enum(const struct tm_field *field, struct nlattr *attr)
@@ -65,7 +110,7 @@ static bool parse_u8(const struct tm_field *field, int idx,

 static void print_u8(const struct tm_field *field, struct nlattr *attr)
 {
-	printf("%d", nla_get_u8(attr));
+	printf("%u", nla_get_u8(attr));
 }

 static void print_s8(const struct tm_field *field, struct nlattr *attr)
@@ -73,6 +118,17 @@ static void print_s8(const struct tm_field *field, struct nlattr *attr)
	printf("%d", (int8_t)nla_get_u8(attr));
 }

+static bool parse_u16_hex(const struct tm_field *field, int idx,
+			  struct nl_msg *msg, const char *val)
+{
+	return !nla_put_u16(msg, idx, strtoul(val, NULL, 16));
+}
+
+static void print_u16_hex(const struct tm_field *field, struct nlattr *attr)
+{
+	printf("%d", nla_get_u16(attr));
+}
+
 static bool parse_u32(const struct tm_field *field, int idx,
		      struct nl_msg *msg, const char *val)
 {
@@ -86,12 +142,12 @@ static void print_s32(const struct tm_field *field, struct nlattr *attr)

 static void print_u32(const struct tm_field *field, struct nlattr *attr)
 {
-	printf("%d", nla_get_u32(attr));
+	printf("%u", nla_get_u32(attr));
 }

 static void print_u64(const struct tm_field *field, struct nlattr *attr)
 {
-	printf("%lld", (unsigned long long)nla_get_u64(attr));
+	printf("%llu", (unsigned long long)nla_get_u64(attr));
 }

 static bool parse_flag(const struct tm_field *field, int idx,
@@ -201,6 +257,62 @@ static void print_extra_stats(const struct tm_field *field, struct nlattr **tb)
	printf("%srx_per=%.02f%%\n", prefix, 100 * failed / total);
 }

+static bool parse_mac(const struct tm_field *field, int idx,
+		      struct nl_msg *msg, const char *val)
+{
+#define ETH_ALEN	6
+	bool ret = true;
+	char *str, *cur, *ap;
+	void *a;
+
+	str = strdup(val);
+	ap = str;
+
+	a = nla_nest_start(msg, idx);
+
+	idx = 0;
+	while ((cur = strsep(&ap, ",")) != NULL) {
+		unsigned char addr[ETH_ALEN];
+		char *val, *tmp = cur;
+		int i = 0;
+
+		while ((val = strsep(&tmp, ":")) != NULL) {
+			if (i >= ETH_ALEN)
+				break;
+
+			addr[i++] = strtoul(val, NULL, 16);
+		}
+
+		nla_put(msg, idx, ETH_ALEN, addr);
+
+		idx++;
+	}
+
+	nla_nest_end(msg, a);
+
+	free(str);
+
+	return ret;
+}
+
+static void print_mac(const struct tm_field *field, struct nlattr *attr)
+{
+#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+	unsigned char addr[3][6];
+	struct nlattr *cur;
+	int idx = 0;
+	int rem;
+
+	nla_for_each_nested(cur, attr, rem) {
+		if (nla_len(cur) != 6)
+			continue;
+		memcpy(addr[idx++], nla_data(cur), 6);
+	}
+
+	printf("" MACSTR "," MACSTR "," MACSTR "",
+	       MAC2STR(addr[0]), MAC2STR(addr[1]), MAC2STR(addr[2]));
+}

 #define FIELD_GENERIC(_field, _name, ...)	\
	[FIELD_NAME(_field)] = {			\
@@ -250,10 +362,18 @@ static void print_extra_stats(const struct tm_field *field, struct nlattr **tb)
		 ##__VA_ARGS__				\
	)

+#define FIELD_MAC(_field, _name)			\
+	[FIELD_NAME(_field)] = {			\
+		.name = _name,				\
+		.parse = parse_mac,			\
+		.print = print_mac			\
+	}
+
 #define FIELD_NAME(_field) MT76_TM_RX_ATTR_##_field
 static const struct tm_field rx_fields[NUM_MT76_TM_RX_ATTRS] = {
	FIELD_RO(s32, FREQ_OFFSET, "freq_offset"),
	FIELD_ARRAY_RO(u8, RCPI, "rcpi"),
+	FIELD_ARRAY_RO(s8, RSSI, "rssi"),
	FIELD_ARRAY_RO(s8, IB_RSSI, "ib_rssi"),
	FIELD_ARRAY_RO(s8, WB_RSSI, "wb_rssi"),
	FIELD_RO(s8, SNR, "snr"),
@@ -261,6 +381,7 @@ static const struct tm_field rx_fields[NUM_MT76_TM_RX_ATTRS] = {
 static struct nla_policy rx_policy[NUM_MT76_TM_RX_ATTRS] = {
	[MT76_TM_RX_ATTR_FREQ_OFFSET] = { .type = NLA_U32 },
	[MT76_TM_RX_ATTR_RCPI] = { .type = NLA_NESTED },
+	[MT76_TM_RX_ATTR_RSSI] = { .type = NLA_NESTED },
	[MT76_TM_RX_ATTR_IB_RSSI] = { .type = NLA_NESTED },
	[MT76_TM_RX_ATTR_WB_RSSI] = { .type = NLA_NESTED },
	[MT76_TM_RX_ATTR_SNR] = { .type = NLA_U8 },
@@ -274,6 +395,7 @@ static const struct tm_field stats_fields[NUM_MT76_TM_STATS_ATTRS] = {
	FIELD_RO(u32, TX_DONE, "tx_done"),
	FIELD_RO(u64, RX_PACKETS, "rx_packets"),
	FIELD_RO(u64, RX_FCS_ERROR, "rx_fcs_error"),
+	FIELD_RO(u64, RX_LEN_MISMATCH, "rx_len_mismatch"),
	FIELD_NESTED_RO(LAST_RX, rx, "last_"),
 };
 static struct nla_policy stats_policy[NUM_MT76_TM_STATS_ATTRS] = {
@@ -282,6 +404,7 @@ static struct nla_policy stats_policy[NUM_MT76_TM_STATS_ATTRS] = {
	[MT76_TM_STATS_ATTR_TX_DONE] = { .type = NLA_U32 },
	[MT76_TM_STATS_ATTR_RX_PACKETS] = { .type = NLA_U64 },
	[MT76_TM_STATS_ATTR_RX_FCS_ERROR] = { .type = NLA_U64 },
+	[MT76_TM_STATS_ATTR_RX_LEN_MISMATCH] = { .type = NLA_U64 },
 };
 #undef FIELD_NAME

@@ -291,6 +414,7 @@ static const struct tm_field testdata_fields[NUM_MT76_TM_ATTRS] = {
	FIELD_ENUM(STATE, "state", testmode_state),
	FIELD_RO(string, MTD_PART, "mtd_part"),
	FIELD_RO(u32, MTD_OFFSET, "mtd_offset"),
+	FIELD(u8, SKU_EN, "sku_en"),
	FIELD(u32, TX_COUNT, "tx_count"),
	FIELD(u32, TX_LENGTH, "tx_length"),
	FIELD_ENUM(TX_RATE_MODE, "tx_rate_mode", testmode_tx_mode),
@@ -300,12 +424,28 @@ static const struct tm_field testdata_fields[NUM_MT76_TM_ATTRS] = {
	FIELD(u8, TX_RATE_LDPC, "tx_rate_ldpc"),
	FIELD(u8, TX_RATE_STBC, "tx_rate_stbc"),
	FIELD(u8, TX_LTF, "tx_ltf"),
+	FIELD(u8, TX_DUTY_CYCLE, "tx_duty_cycle"),
+	FIELD(u32, TX_IPG, "tx_ipg"),
+	FIELD(u32, TX_TIME, "tx_time"),
	FIELD(u8, TX_POWER_CONTROL, "tx_power_control"),
	FIELD_ARRAY(u8, TX_POWER, "tx_power"),
	FIELD(u8, TX_ANTENNA, "tx_antenna"),
	FIELD(u32, FREQ_OFFSET, "freq_offset"),
+	FIELD(u8, AID, "aid"),
+	FIELD(u8, RU_ALLOC, "ru_alloc"),
+	FIELD(u8, RU_IDX, "ru_idx"),
+	FIELD_ENUM(TXBF_ACT, "txbf_act", testmode_txbf_act),
+	FIELD_ARRAY(u16_hex, TXBF_PARAM, "txbf_param"),
+	FIELD(u8, OFF_CH_SCAN_CH, "offchan_ch"),
+	FIELD(u8, OFF_CH_SCAN_CENTER_CH, "offchan_center_ch"),
+	FIELD_ENUM(OFF_CH_SCAN_BW, "offchan_bw", testmode_offchan_bw),
+	FIELD(u8, IPI_THRESHOLD, "ipi_threshold"),
+	FIELD(u32, IPI_PERIOD, "ipi_period"),
+	FIELD(u8, IPI_RESET, "ipi_reset"),
+	FIELD_MAC(MAC_ADDRS, "mac_addrs"),
	FIELD_NESTED_RO(STATS, stats, "",
			.print_extra = print_extra_stats),
+
 };
 #undef FIELD_NAME

@@ -313,6 +453,7 @@ static struct nla_policy testdata_policy[NUM_MT76_TM_ATTRS] = {
	[MT76_TM_ATTR_STATE] = { .type = NLA_U8 },
	[MT76_TM_ATTR_MTD_PART] = { .type = NLA_STRING },
	[MT76_TM_ATTR_MTD_OFFSET] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_SKU_EN] = { .type = NLA_U8 },
	[MT76_TM_ATTR_TX_COUNT] = { .type = NLA_U32 },
	[MT76_TM_ATTR_TX_LENGTH] = { .type = NLA_U32 },
	[MT76_TM_ATTR_TX_RATE_MODE] = { .type = NLA_U8 },
@@ -322,10 +463,25 @@ static struct nla_policy testdata_policy[NUM_MT76_TM_ATTRS] = {
	[MT76_TM_ATTR_TX_RATE_LDPC] = { .type = NLA_U8 },
	[MT76_TM_ATTR_TX_RATE_STBC] = { .type = NLA_U8 },
	[MT76_TM_ATTR_TX_LTF] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_DUTY_CYCLE] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_IPG] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_TX_TIME] = { .type = NLA_U32 },
	[MT76_TM_ATTR_TX_POWER_CONTROL] = { .type = NLA_U8 },
	[MT76_TM_ATTR_TX_ANTENNA] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_SPE_IDX] = { .type = NLA_U8 },
	[MT76_TM_ATTR_FREQ_OFFSET] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_AID] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_ALLOC] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_IDX] = { .type = NLA_U8 },
	[MT76_TM_ATTR_STATS] = { .type = NLA_NESTED },
+	[MT76_TM_ATTR_TXBF_ACT] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_BW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_THRESHOLD] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_PERIOD] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_IPI_ANTENNA_INDEX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_RESET] = { .type = NLA_U8 },
 };

 const struct tm_field msg_field = {
diff --git a/drivers/net/wireless/mediatek/mt76/tools/fwlog.c b/drivers/net/wireless/mediatek/mt76/tools/fwlog.c
index e5d4a1051b5f..c894d31a9d9c 100644
--- a/drivers/net/wireless/mediatek/mt76/tools/fwlog.c
+++ b/drivers/net/wireless/mediatek/mt76/tools/fwlog.c
@@ -26,16 +26,36 @@ static const char *debugfs_path(const char *phyname, const char *file)
	return path;
 }

-static int mt76_set_fwlog_en(const char *phyname, bool en)
+static int mt76_set_fwlog_en(const char *phyname, bool en, char *val)
 {
	FILE *f = fopen(debugfs_path(phyname, "fw_debug_bin"), "w");
+	if (!f) {
+		perror("fopen");
+		return -1;
+	}
+
+	if (en && val)
+		fprintf(f, "%s", val);
+	else if (en)
+		fprintf(f, "7");
+	else
+		fprintf(f, "0");
+
+	fclose(f);
+
+	return 0;
+}

+static int mt76_set_idxlog_enable(const char *phyname, bool enable)
+{
+	FILE *f = fopen(debugfs_path(phyname, "idxlog_enable"), "w");
	if (!f) {
-		fprintf(stderr, "Could not open fw_debug_bin file\n");
-		return 1;
+		perror("fopen");
+		return -1;
	}

-	fprintf(f, "7");
+	fprintf(f, "%hhu", enable);
+
	fclose(f);

	return 0;
@@ -74,104 +94,215 @@ static void handle_signal(int sig)
	done = true;
 }

-int mt76_fwlog(const char *phyname, int argc, char **argv)
+static int mt76_log_socket(struct sockaddr_in *remote, char *ip, unsigned short port)
 {
	struct sockaddr_in local = {
		.sin_family = AF_INET,
		.sin_addr.s_addr = INADDR_ANY,
	};
-	struct sockaddr_in remote = {
-		.sin_family = AF_INET,
-		.sin_port = htons(55688),
-	};
-	char buf[1504];
-	int ret = 0;
-	int yes = 1;
-	int s, fd;
-
-	if (argc < 1) {
-		fprintf(stderr, "need destination address\n");
-		return 1;
-	}
+	int s, ret;

-	if (!inet_aton(argv[0], &remote.sin_addr)) {
-		fprintf(stderr, "invalid destination address\n");
-		return 1;
+	remote->sin_family = AF_INET;
+	remote->sin_port = htons(port);
+	if (!inet_aton(ip, &remote->sin_addr)) {
+		fprintf(stderr, "Invalid destination IP address: %s\n", ip);
+		return -EINVAL;
	}

	s = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (s < 0) {
		perror("socket");
-		return 1;
+		return s;
	}

-	setsockopt(s, SOL_SOCKET, SO_BROADCAST, &yes, sizeof(yes));
-	if (bind(s, (struct sockaddr *)&local, sizeof(local)) < 0) {
+	ret = bind(s, (struct sockaddr *)&local, sizeof(local));
+	if (ret) {
		perror("bind");
-		return 1;
+		close(s);
+		return ret;
	}

-	if (mt76_set_fwlog_en(phyname, true))
-		return 1;
+	return s;
+}
+
+static int mt76_log_relay(int in_fd, int out_fd, struct sockaddr_in *remote)
+{
+	char *buf = malloc(FWLOG_BUF_SIZE);
+	int ret = 0;

-	fd = open(debugfs_path(phyname, "fwlog_data"), O_RDONLY);
-	if (fd < 0) {
-		fprintf(stderr, "Could not open fwlog_data file: %s\n", strerror(errno));
-		ret = 1;
-		goto out;
+	if (!buf) {
+		perror("malloc");
+		return -ENOMEM;
	}

	signal(SIGTERM, handle_signal);
	signal(SIGINT, handle_signal);
	signal(SIGQUIT, handle_signal);

-	while (1) {
+	while (!done) {
		struct pollfd pfd = {
-			.fd = fd,
-			.events = POLLIN | POLLHUP | POLLERR,
+			.fd = in_fd,
+			.events = POLLIN,
		};
		uint32_t len;
-		int r;
-
-		if (done)
-			break;
+		int rc;

		poll(&pfd, 1, -1);

-		r = read_retry(fd, &len, sizeof(len));
-		if (r < 0)
+		rc = read_retry(in_fd, &len, sizeof(len));
+		if (rc < 0) {
+			if (!done) {
+				fprintf(stderr, "Failed to read relay file.\n");
+				ret = -1;
+			}
			break;
-
-		if (!r)
+		}
+		if (!rc)
			continue;

-		if (len > sizeof(buf)) {
-			fprintf(stderr, "Length error: %d > %d\n", len, (int)sizeof(buf));
-			ret = 1;
+		if (len > FWLOG_BUF_SIZE) {
+			fprintf(stderr, "Log size was too large: %u bytes\n", len);
+			ret = -ENOMEM;
			break;
		}

-		if (done)
+		rc = read_retry(in_fd, buf, len);
+		if (rc < 0) {
+			if (!done) {
+				fprintf(stderr, "Failed to read relay file.\n");
+				ret = -1;
+			}
			break;
-
-		r = read_retry(fd, buf, len);
-		if (done)
+		}
+		if (rc != len) {
+			fprintf(stderr, "Expected log size: %u bytes\n", len);
+			fprintf(stderr, "Read log size: %u bytes\n", rc);
+			ret = -EIO;
			break;
+		}

-		if (r != len) {
-			fprintf(stderr, "Short read: %d < %d\n", r, len);
-			ret = 1;
+		if (remote)
+			rc = sendto(out_fd, buf, len, 0, (struct sockaddr *)remote, sizeof(*remote));
+		else
+			rc = write(out_fd, buf, len);
+		if (rc < 0) {
+			perror("sendto/write");
+			ret = -1;
			break;
		}
+	}
+
+	free(buf);
+
+	return ret;
+}

-		/* send buf */
-		sendto(s, buf, len, 0, (struct sockaddr *)&remote, sizeof(remote));
+int mt76_fwlog(const char *phyname, int argc, char **argv)
+{
+	struct sockaddr_in remote;
+	int in_fd, out_fd, ret;
+	char dev_ip[16] = {};
+	unsigned short port;
+
+	if (argc < 2) {
+		fprintf(stderr, "need destination address and fw_debug_bin\n");
+		return -EINVAL;
	}

-	close(fd);

-out:
-	mt76_set_fwlog_en(phyname, false);
+	if (argc == 2) {
+		/* support ip:port format */
+		if (strchr(argv[0], ':')) {
+			sscanf(argv[0], "%[^:]:%hu", dev_ip, &port);
+		} else {
+			strncpy(dev_ip, argv[0], sizeof(dev_ip) - 1);
+			port = 55688;
+		}
+
+		out_fd = mt76_log_socket(&remote, dev_ip, port);
+		if (out_fd < 0)
+			return out_fd;
+	} else if (argc == 3) {
+		out_fd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR);
+		if (out_fd < 0) {
+			perror("open");
+			return out_fd;
+		}
+	} else {
+		fprintf(stderr, "Too many arguments.\n");
+		return -EINVAL;
+	}
+
+	ret = mt76_set_fwlog_en(phyname, true, argv[1]);
+	if (ret)
+		goto close;
+
+	in_fd = open(debugfs_path(phyname, "fwlog_data"), O_RDONLY);
+	if (in_fd < 0) {
+		perror("open");
+		goto disable;
+	}
+
+	if (mt76_log_relay(in_fd, out_fd, argc == 3 ? NULL : &remote))
+		fprintf(stderr, "Failed to relay FW log.\n");
+
+	close(in_fd);
+disable:
+	ret = mt76_set_fwlog_en(phyname, false, NULL);
+close:
+	close(out_fd);
+
+	return ret;
+}
+
+int mt76_idxlog(const char *phyname, int argc, char **argv)
+{
+#define IDXLOG_FILE_PATH	"/tmp/log/WIFI_FW.clog"
+	struct sockaddr_in remote;
+	int in_fd, out_fd, ret;
+
+	if (argc) {
+		out_fd = mt76_log_socket(&remote, argv[0], 55688);
+		if (out_fd < 0)
+			return out_fd;
+	} else {
+		out_fd = open(IDXLOG_FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR);
+		if (out_fd < 0) {
+			perror("open");
+			return -1;
+		}
+	}
+
+	ret = mt76_set_idxlog_enable(phyname, true);
+	if (ret)
+		goto close;
+
+	in_fd = open(debugfs_path(phyname, "idxlog_data"), O_RDONLY);
+	if (in_fd < 0) {
+		perror("open");
+		goto disable;
+	}
+
+	if (mt76_log_relay(in_fd, out_fd, argc ? &remote : NULL))
+		fprintf(stderr, "Failed to relay index log.\n");
+
+	close(in_fd);
+disable:
+	ret = mt76_set_idxlog_enable(phyname, false);
+close:
+	close(out_fd);
+
+	if (argc)
+		system("timestamp=$(date +\"%y%m%d_%H%M%S\");"
+		       "clog_dir=/tmp/log/clog_${timestamp};"
+		       "mkdir ${clog_dir};"
+		       "dmesg > ${clog_dir}/WIFI_KERNEL_${timestamp}.clog");
+	else
+		system("timestamp=$(date +\"%y%m%d_%H%M%S\");"
+		       "clog_dir=/tmp/log/clog_${timestamp};"
+		       "mkdir ${clog_dir};"
+		       "mv /tmp/log/WIFI_FW.clog ${clog_dir}/WIFI_FW_${timestamp}.clog;"
+		       "dmesg > ${clog_dir}/WIFI_KERNEL_${timestamp}.clog");

	return ret;
 }
diff --git a/drivers/net/wireless/mediatek/mt76/tools/main.c b/drivers/net/wireless/mediatek/mt76/tools/main.c
index 699a9eea625a..9e8f0bcfb7a5 100644
--- a/drivers/net/wireless/mediatek/mt76/tools/main.c
+++ b/drivers/net/wireless/mediatek/mt76/tools/main.c
@@ -13,6 +13,7 @@
 #include <poll.h>
 #include <fcntl.h>
 #include <signal.h>
+#include <net/if.h>
 #include "mt76-test.h"

 struct unl unl;
@@ -25,6 +26,7 @@ static int phy_lookup_idx(const char *name)
	FILE *f;
	int len;

+	/* TODO: Handle single wiphy radio index */
	snprintf(buf, sizeof(buf), "/sys/class/ieee80211/%s/index", name);
	f = fopen(buf, "r");
	if (!f)
@@ -43,12 +45,15 @@ static int phy_lookup_idx(const char *name)
 void usage(void)
 {
	static const char *const commands[] = {
+		"add <interface>",
+		"del <interface>",
		"set <var>=<val> [...]",
		"dump [stats]",
		"eeprom file",
		"eeprom set <addr>=<val> [...]",
		"eeprom changes",
		"eeprom reset",
+		"fwlog <ip> <fw_debug_bin input> <fwlog name>",
	};
	int i;

@@ -164,6 +169,122 @@ static int mt76_set(int phy, int argc, char **argv)
	return ret;
 }

+static int mt76_set_state(int phy, char *state)
+{
+	const struct tm_field *fields = msg_field.fields;
+	struct nl_msg *msg;
+	void *data;
+	int ret, i;
+
+	msg = unl_genl_msg(&unl, NL80211_CMD_TESTMODE, false);
+	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
+
+	data = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
+	for (i = 0; i < msg_field.len; i++) {
+		if (!fields[i].parse)
+			continue;
+
+		if (!strcmp(fields[i].name, "state"))
+			break;
+	}
+
+	if (!fields[i].parse(&fields[i], i, msg, state))
+		return 1;
+
+	tm_set_changed(i);
+	nla_nest_end(msg, data);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret)
+		fprintf(stderr, "Failed to set state %s: %s\n", state, strerror(-ret));
+
+	return ret;
+}
+
+static void mt76_set_tm_reg(void)
+{
+	struct nl_msg *msg;
+	char reg[3] = "VV\0";
+	int ret;
+
+	msg = unl_genl_msg(&unl, NL80211_CMD_REQ_SET_REG, false);
+	nla_put_string(msg, NL80211_ATTR_REG_ALPHA2, reg);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret)
+		fprintf(stderr, "Failed to set reg %s: %s\n", reg, strerror(-ret));
+}
+
+static int mt76_add_iface(int phy, int argc, char **argv)
+{
+	struct nl_msg *msg;
+	char *name, cmd[64];
+	int ret;
+
+	mt76_set_tm_reg();
+
+	if (argc < 1)
+		return 1;
+
+	name = argv[0];
+	msg = unl_genl_msg(&unl, NL80211_CMD_NEW_INTERFACE, false);
+	/* TODO: Handle single wiphy radio index */
+	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
+	nla_put_u32(msg, NL80211_ATTR_IFTYPE, NL80211_IFTYPE_MONITOR);
+	nla_put_string(msg, NL80211_ATTR_IFNAME, name);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret) {
+		fprintf(stderr, "nl80211 call failed: %s\n", strerror(-ret));
+		return ret;
+	}
+
+	snprintf(cmd, sizeof(cmd), "ifconfig %s up", name);
+	system(cmd);
+
+	/* turn on testmode */
+	ret = mt76_set_state(phy, "idle");
+	return ret;
+}
+
+static int mt76_delete_iface(int phy, int argc, char **argv)
+{
+	unsigned int devidx;
+	struct nl_msg *msg;
+	char *name, cmd[64];
+	int ret;
+
+	if (argc < 1)
+		return 1;
+
+	name = argv[0];
+	devidx = if_nametoindex(name);
+	if (!devidx) {
+		fprintf(stderr, "Failed to find ifindex for %s: %s\n",
+			name, strerror(errno));
+		return 2;
+	}
+
+	/* turn off testmode before deleting interface */
+	ret = mt76_set_state(phy, "off");
+	if (ret)
+		return ret;
+
+	snprintf(cmd, sizeof(cmd), "ifconfig %s down", name);
+	system(cmd);
+
+	/* delete interface */
+	msg = unl_genl_msg(&unl, NL80211_CMD_DEL_INTERFACE, false);
+	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
+	nla_put_u32(msg, NL80211_ATTR_IFINDEX, devidx);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret)
+		fprintf(stderr, "nl80211 call failed: %s\n", strerror(-ret));
+
+	return ret;
+}
+
 int main(int argc, char **argv)
 {
	const char *cmd, *phyname;
@@ -194,10 +315,16 @@ int main(int argc, char **argv)
		ret = mt76_dump(phy, argc, argv);
	else if (!strcmp(cmd, "set"))
		ret = mt76_set(phy, argc, argv);
+	else if (!strcmp(cmd, "add"))
+		ret = mt76_add_iface(phy, argc, argv);
+	else if (!strcmp(cmd, "del"))
+		ret = mt76_delete_iface(phy, argc, argv);
	else if (!strcmp(cmd, "eeprom"))
		ret = mt76_eeprom(phy, argc, argv);
	else if (!strcmp(cmd, "fwlog"))
		ret = mt76_fwlog(phyname, argc, argv);
+	else if (!strcmp(cmd, "idxlog"))
+		ret = mt76_idxlog(phyname, argc, argv);
	else
		usage();

diff --git a/drivers/net/wireless/mediatek/mt76/tools/mt76-test.h b/drivers/net/wireless/mediatek/mt76/tools/mt76-test.h
index d2fafa8623e9..b9d508c5cd7b 100644
--- a/drivers/net/wireless/mediatek/mt76/tools/mt76-test.h
+++ b/drivers/net/wireless/mediatek/mt76/tools/mt76-test.h
@@ -22,6 +22,8 @@
 #define EEPROM_FILE_PATH_FMT	"/tmp/mt76-test-%s"
 #define EEPROM_PART_SIZE	20480

+#define FWLOG_BUF_SIZE	1504
+
 struct nl_msg;
 struct nlattr;

@@ -61,5 +63,6 @@ extern unsigned char *eeprom_data;
 void usage(void);
 int mt76_eeprom(int phy, int argc, char **argv);
 int mt76_fwlog(const char *phyname, int argc, char **argv);
+int mt76_idxlog(const char *phyname, int argc, char **argv);

 #endif
diff --git a/drivers/net/wireless/mediatek/mt76/trace.h b/drivers/net/wireless/mediatek/mt76/trace.h
index 109a07f9733a..e697f5dd8747 100644
--- a/drivers/net/wireless/mediatek/mt76/trace.h
+++ b/drivers/net/wireless/mediatek/mt76/trace.h
@@ -101,6 +101,64 @@ DEFINE_EVENT(dev_txid_evt, mac_txdone,
	TP_ARGS(dev, wcid, pktid)
 );

+TRACE_EVENT(mt76_rx_complete,
+	TP_PROTO(struct mt76_dev *dev, struct mt76_rx_status *status, bool sub),
+	TP_ARGS(dev, status, sub),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(u16, seqno)
+		__field(u16, wcid)
+		__field(u8, first_amsdu)
+		__field(bool, sub)
+	),
+
+	TP_fast_assign(
+		strscpy(__entry->wiphy_name,
+			wiphy_name(mt76_dev_phy(dev, status->phy_idx)->hw->wiphy),
+			MAXNAME);
+		__entry->seqno = status->seqno;
+		__entry->wcid = status->wcid ? status->wcid->idx : 0;
+		__entry->first_amsdu = status->first_amsdu;
+		__entry->sub = sub;
+	),
+
+	TP_printk(
+		DEV_PR_FMT " seqno: %u, wcid: %u, first_amsdu: %x, sub: %d",
+		DEV_PR_ARG, __entry->seqno, __entry->wcid, __entry->first_amsdu,
+		__entry->sub
+	)
+);
+
+TRACE_EVENT(mt76_rx_aggr_reorder,
+	TP_PROTO(struct mt76_dev *dev, struct mt76_wcid *wcid, u16 _head, u16 seqno, bool sn_less),
+	TP_ARGS(dev, wcid, _head, seqno, sn_less),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(u16, wcid)
+		__field(u16, _head)
+		__field(u16, seqno)
+		__field(bool, sn_less)
+	),
+
+	TP_fast_assign(
+		strscpy(__entry->wiphy_name,
+			wiphy_name(dev->phys[wcid->phy_idx]->hw->wiphy),
+			MAXNAME);
+		__entry->wcid = wcid->idx;
+		__entry->_head = _head;
+		__entry->seqno = seqno;
+		__entry->sn_less = sn_less;
+	),
+
+	TP_printk(
+		DEV_PR_FMT " wcid: %u, head: %u, seqno: %u, sn_less: %d",
+		DEV_PR_ARG, __entry->wcid, __entry->_head, __entry->seqno,
+		__entry->sn_less
+	)
+);
+
 #endif

 #undef TRACE_INCLUDE_PATH
diff --git a/drivers/net/wireless/mediatek/mt76/tx.c b/drivers/net/wireless/mediatek/mt76/tx.c
index 513916469ca2..622f956f863a 100644
--- a/drivers/net/wireless/mediatek/mt76/tx.c
+++ b/drivers/net/wireless/mediatek/mt76/tx.c
@@ -336,8 +336,14 @@ mt76_tx(struct mt76_phy *phy, struct ieee80211_sta *sta,
	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
	struct sk_buff_head *head;

+	spin_lock_bh(&phy->tx_dbg_stats.lock);
+	phy->tx_dbg_stats.tx_from_mac80211++;
+	spin_unlock_bh(&phy->tx_dbg_stats.lock);
	if (mt76_testmode_enabled(phy)) {
		ieee80211_free_txskb(phy->hw, skb);
+		spin_lock_bh(&phy->tx_dbg_stats.lock);
+		phy->tx_dbg_stats.tx_drop[MT_TX_DROP_IN_TESTMODE]++;
+		spin_unlock_bh(&phy->tx_dbg_stats.lock);
		return;
	}

@@ -353,8 +359,19 @@ mt76_tx(struct mt76_phy *phy, struct ieee80211_sta *sta,
	if ((info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) ||
	    (info->control.flags & IEEE80211_TX_CTRL_DONT_USE_RATE_MASK))
		head = &wcid->tx_offchannel;
-	else
+	else {
+		if (!wcid->tx_pending.prev || !wcid->tx_pending.next) {
+			dev_warn(phy->dev->dev, "Un-initialized STA %pM wcid %d in mt76_tx\n",
+				 sta->addr, wcid->idx);
+
+			spin_lock_bh(&phy->tx_dbg_stats.lock);
+			phy->tx_dbg_stats.tx_drop[MT_TX_DROP_WCID_NOT_INIT]++;
+			spin_unlock_bh(&phy->tx_dbg_stats.lock);
+			ieee80211_free_txskb(phy->hw, skb);
+			return;
+		}
		head = &wcid->tx_pending;
+	}

	spin_lock_bh(&head->lock);
	__skb_queue_tail(head, skb);
@@ -383,6 +400,8 @@ mt76_txq_dequeue(struct mt76_phy *phy, struct mt76_txq *mtxq)
	info = IEEE80211_SKB_CB(skb);
	info->hw_queue |= FIELD_PREP(MT_TX_HW_QUEUE_PHY, phy->band_idx);

+	phy->dev->tx_dbg_stats.tx_from_mac80211++;
+
	return skb;
 }

@@ -623,7 +640,8 @@ mt76_txq_schedule_pending_wcid(struct mt76_phy *phy, struct mt76_wcid *wcid,
		q = phy->q_tx[qid];
		if (mt76_txq_stopped(q) || test_bit(MT76_RESET, &phy->state)) {
			ret = -1;
+			phy->tx_dbg_stats.tx_drop[MT_TX_DROP_STOPPED_QUEUE]++;
			break;
		}

 EXPORT_SYMBOL_GPL(mt76_wake_tx_queue);
@@ -843,13 +858,26 @@ EXPORT_SYMBOL_GPL(__mt76_set_tx_blocked);

 int mt76_token_consume(struct mt76_dev *dev, struct mt76_txwi_cache **ptxwi)
 {
-	int token;
+	int token; //, start = 0;

-	spin_lock_bh(&dev->token_lock);
+#if 0
+	/* BEN:  Won't compile, needs out-of-tree WED patches from owrt backports or something.
+	 * We don't use WED on x86 anyway.
+	 */
+	if (mtk_wed_device_active(&dev->mmio.wed))
+		start = dev->mmio.wed.wlan.nbuf;
+#endif

+	spin_lock_bh(&dev->token_lock);
	token = idr_alloc(&dev->token, *ptxwi, 0, dev->token_size, GFP_ATOMIC);
	if (token >= 0)
		dev->token_count++;
+#if 0
+	token = idr_alloc(&dev->token, *ptxwi, start, start + dev->token_size,
+			  GFP_ATOMIC);
+	if (token >= start)
+		dev->token_count++;
+#endif

 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
	if (mtk_wed_device_active(&dev->mmio.wed) &&
diff --git a/drivers/net/wireless/mediatek/mt76/wed.c b/drivers/net/wireless/mediatek/mt76/wed.c
index f89e4537555c..ea04c5943964 100644
--- a/drivers/net/wireless/mediatek/mt76/wed.c
+++ b/drivers/net/wireless/mediatek/mt76/wed.c
@@ -9,6 +9,7 @@
 void mt76_wed_release_rx_buf(struct mtk_wed_device *wed)
 {
	struct mt76_dev *dev = container_of(wed, struct mt76_dev, mmio.wed);
+	//struct page *page;
	int i;

	for (i = 0; i < dev->rx_token_size; i++) {
@@ -25,6 +26,31 @@ void mt76_wed_release_rx_buf(struct mtk_wed_device *wed)
	}

	mt76_free_pending_rxwi(dev);
+
+#if 0
+	/* BEN:  Won't compile, needs out-of-tree WED patches from owrt backports or something.
+	 * We don't use WED on x86 anyway.
+	 */
+	mt76_for_each_q_rx(dev, i) {
+		struct mt76_queue *q = &dev->q_rx[i];
+
+		if (mt76_queue_is_wed_rx(q)) {
+			if (!q->rx_page.va)
+				continue;
+
+			page = virt_to_page(q->rx_page.va);
+			__page_frag_cache_drain(page, q->rx_page.pagecnt_bias);
+			memset(&q->rx_page, 0, sizeof(q->rx_page));
+		}
+	}
+
+	if (!wed->rx_buf_ring.rx_page.va)
+		return;
+
+	page = virt_to_page(wed->rx_buf_ring.rx_page.va);
+	__page_frag_cache_drain(page, wed->rx_buf_ring.rx_page.pagecnt_bias);
+	memset(&wed->rx_buf_ring.rx_page, 0, sizeof(wed->rx_buf_ring.rx_page));
+#endif
 }
 EXPORT_SYMBOL_GPL(mt76_wed_release_rx_buf);

@@ -87,7 +113,7 @@ int mt76_wed_offload_enable(struct mtk_wed_device *wed)
	struct mt76_dev *dev = container_of(wed, struct mt76_dev, mmio.wed);

	spin_lock_bh(&dev->token_lock);
-	dev->token_size = wed->wlan.token_start;
+	dev->token_size = MT76_WED_SW_TOKEN_SIZE;
	spin_unlock_bh(&dev->token_lock);

	return !wait_event_timeout(dev->tx_wait, !dev->wed_token_count, HZ);
@@ -171,7 +197,7 @@ void mt76_wed_offload_disable(struct mtk_wed_device *wed)
	struct mt76_dev *dev = container_of(wed, struct mt76_dev, mmio.wed);

	spin_lock_bh(&dev->token_lock);
-	dev->token_size = dev->drv->token_size;
+	dev->token_size = MT76_WED_SW_TOKEN_SIZE;
	spin_unlock_bh(&dev->token_lock);
 }
 EXPORT_SYMBOL_GPL(mt76_wed_offload_disable);
