From 144d20c6e2872abdee6c535d56a50a55a09c5ee1 Mon Sep 17 00:00:00 2001
From: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
Date: Tue, 11 Feb 2025 09:09:34 +0800
Subject: [PATCH 1206/1306] mtk: mac80211: sync from felix

Sync from felix's patches for handling DFS restrictions during scanning

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mac80211: fixup felix: refactor the radar condition for offchannel

In the current design, if a user add a 5G ROC when the 5G radio is
on a DFS channel, the ROC request will be queued in roc_list and never
started, which blocks the subsequent 2G/6G ROC requests.
Therefore, if it is not allowed to perform ROC due to DFS regulatory
restrictions, return EBUSY.
Also, change the condition from ieee80211_is_radar_required to
ieee80211_can_leave_ch, so that the 5G ROC can be permitted if pre-CAC
is allowed.

This will be merged in felix's upstream patch.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mac80211: fixup felix: add missing radio assignment

Fix kernel crash

This will be merged in felix's upstream patch

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mac80211: fixup felix: use cfg80211_chandef_create

If the chandef->center_freq1 is not set, then
cfg80211_radio_chandef_valid will return true to all the radios.
Therefore, add a cfg80211_chandef_valid check to make sure the
chandef is valid.
Also, use cfg80211_chandef_create to create chandef in the radio
mask helper function to make sure the center_freq1 is set.

This will be merged in felix's upstream patch.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mac80211: fixup felix: refactor ieee80211_radar_detection_busy for channel switch

Refactor the scanning condition in ieee80211_channel_switch.
Also, rename ieee80211_radar_detection_busy to ieee80211_scanning_busy
to make it more general.

This will be merged in felix's upstream patch.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mac80211: fixup felix: add roc started flag

If the roc has not started yet, do not consider the
corresponding radio to be scanning.

This will be merged in felix's upstream patch.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
---
 net/mac80211/cfg.c         | 30 +++++++++----
 net/mac80211/chan.c        | 14 +++++-
 net/mac80211/ieee80211_i.h | 11 ++++-
 net/mac80211/offchannel.c  | 40 ++++++++++++++++-
 net/mac80211/scan.c        | 88 +++++++++++++++++++++++++++++++-------
 net/mac80211/util.c        | 17 ++++++++
 net/wireless/util.c        |  3 ++
 7 files changed, 173 insertions(+), 30 deletions(-)

diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index 459a90903127..5698038360f2 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -3693,13 +3693,25 @@ static int ieee80211_set_bitrate_mask(struct wiphy *wiphy,
	return 0;
 }

-static bool ieee80211_radar_detection_busy(struct ieee80211_local *local,
-					   struct cfg80211_chan_def *chandef)
+bool ieee80211_scanning_busy(struct ieee80211_local *local,
+			     struct cfg80211_chan_def *chandef)
 {
-	/* TODO:  Pulling this method in so we can compile, in mtk owrt
-	 * tree (and here too) it is fixed in a subsequent patch.
-	 */
-	return false;
+	struct cfg80211_scan_request *scan_req;
+	struct wiphy *wiphy = local->hw.wiphy;
+	u32 mask;
+
+	if (list_empty(&local->roc_list) && !local->scanning)
+		return false;
+
+	if (!wiphy->n_radio)
+		return true;
+
+	mask = ieee80211_offchannel_radio_mask(local);
+	scan_req = wiphy_dereference(wiphy, local->scan_req);
+	if (scan_req)
+		mask |= ieee80211_scan_req_radio_mask(local, scan_req);
+
+	return mask & ieee80211_chandef_radio_mask(local, chandef);
 }

 static int ieee80211_start_radar_detection(struct wiphy *wiphy,
@@ -3715,7 +3727,7 @@ static int ieee80211_start_radar_detection(struct wiphy *wiphy,

	lockdep_assert_wiphy(local->hw.wiphy);

-	if (!list_empty(&local->roc_list) || local->scanning) {
+	if (ieee80211_scanning_busy(local, chandef)) {
		sdata_info(sdata, "start-radar failed, roc-list-empty: %d  scanning: %ld\n",
			   list_empty(&local->roc_list), local->scanning);
		return -EBUSY;
@@ -3978,7 +3990,7 @@ static int ieee80211_start_radar_detection_post_csa(struct wiphy *wiphy,
	struct ieee80211_local *local = sdata->local;
	struct ieee80211_link_data *link;

-	if (ieee80211_radar_detection_busy(local, chandef))
+	if (ieee80211_scanning_busy(local, chandef))
		return -EBUSY;

	link = sdata_dereference(sdata->link[link_id], sdata);
@@ -4262,7 +4274,7 @@ __ieee80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,

	lockdep_assert_wiphy(local->hw.wiphy);

-	if (!list_empty(&local->roc_list) || local->scanning)
+	if (ieee80211_scanning_busy(local, &params->chandef))
		return -EBUSY;

	if (WARN_ON(link_id >= IEEE80211_MLD_MAX_NUM_LINKS))
diff --git a/net/mac80211/chan.c b/net/mac80211/chan.c
index a424802b98e5..4240f0d64807 100644
--- a/net/mac80211/chan.c
+++ b/net/mac80211/chan.c
@@ -654,14 +654,24 @@ ieee80211_find_chanctx(struct ieee80211_local *local,
	return NULL;
 }

-bool ieee80211_is_radar_required(struct ieee80211_local *local)
+bool ieee80211_is_radar_required(struct ieee80211_local *local, u32 radio_mask)
 {
+	struct ieee80211_chanctx_conf *conf;
	struct ieee80211_link_data *link;

	lockdep_assert_wiphy(local->hw.wiphy);

	for_each_sdata_link(local, link) {
-		if (link->radar_required)
+		if (!link->radar_required)
+			continue;
+		if (!local->hw.wiphy->n_radio)
+			return true;
+
+		conf = wiphy_dereference(local->hw.wiphy, link->conf->chanctx_conf);
+		if (!conf)
+			continue;
+
+		if (conf->radio_idx >= 0 && (radio_mask & BIT(conf->radio_idx)))
			return true;
	}

diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index 03c6b2f108cb..5b9bfed6927a 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -1998,6 +1998,12 @@ void ieee80211_check_all_rates_disabled(u8 bands_used,
					bool *disable_vht_cfg,
					bool *disable_ht,
					bool *disable_vht);
+u32 ieee80211_scan_req_radio_mask(struct ieee80211_local *local,
+				  struct cfg80211_scan_request *req);
+bool ieee80211_scanning_busy(struct ieee80211_local *local,
+			     struct cfg80211_chan_def *chandef);
+bool ieee80211_can_leave_ch(struct ieee80211_sub_if_data *sdata,
+			    u32 radio_mask);
 void ieee80211_scan_work(struct wiphy *wiphy, struct wiphy_work *work);
 int ieee80211_request_ibss_scan(struct ieee80211_sub_if_data *sdata,
				const u8 *ssid, u8 ssid_len,
@@ -2036,6 +2042,7 @@ void ieee80211_sched_scan_stopped_work(struct wiphy *wiphy,
 /* off-channel/mgmt-tx */
 void ieee80211_offchannel_stop_vifs(struct ieee80211_local *local);
 void ieee80211_offchannel_return(struct ieee80211_local *local);
+u32 ieee80211_offchannel_radio_mask(struct ieee80211_local *local);
 void ieee80211_roc_setup(struct ieee80211_local *local);
 void ieee80211_start_next_roc(struct ieee80211_local *local);
 void ieee80211_reconfig_roc(struct ieee80211_local *local);
@@ -2708,6 +2715,8 @@ bool ieee80211_chandef_s1g_oper(const struct ieee80211_s1g_oper_ie *oper,
				struct cfg80211_chan_def *chandef);
 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *chandef,
				 struct ieee80211_conn_settings *conn);
+u32 ieee80211_chandef_radio_mask(struct ieee80211_local *local,
+				 struct cfg80211_chan_def *chandef);
 static inline void
 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,
			    struct ieee80211_conn_settings *conn)
@@ -2764,7 +2773,7 @@ void ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,
				      struct ieee80211_chanctx *ctx,
				      struct ieee80211_link_data *rsvd_for,
				      bool check_reserved);
-bool ieee80211_is_radar_required(struct ieee80211_local *local);
+bool ieee80211_is_radar_required(struct ieee80211_local *local, u32 radio_mask);

 void ieee80211_dfs_cac_timer_work(struct wiphy *wiphy, struct wiphy_work *work);
 void ieee80211_dfs_cac_cancel(struct ieee80211_local *local,
diff --git a/net/mac80211/offchannel.c b/net/mac80211/offchannel.c
index 22949d311b3a..fa586f75a00a 100644
--- a/net/mac80211/offchannel.c
+++ b/net/mac80211/offchannel.c
@@ -168,6 +168,35 @@ void ieee80211_offchannel_return(struct ieee80211_local *local)
					false);
 }

+u32 ieee80211_offchannel_radio_mask(struct ieee80211_local *local)
+{
+	const struct wiphy_radio *radio;
+	struct ieee80211_roc_work *roc;
+	u32 mask = 0;
+	int r;
+
+	for (r = 0; r < local->hw.wiphy->n_radio; r++) {
+		radio = &local->hw.wiphy->radio[r];
+
+		list_for_each_entry(roc, &local->roc_list, list) {
+			struct cfg80211_chan_def chandef = {};
+
+			if (!roc->started)
+				continue;
+
+			cfg80211_chandef_create(&chandef, roc->chan,
+						NL80211_CHAN_NO_HT);
+			if (!cfg80211_radio_chandef_valid(radio, &chandef))
+				continue;
+
+			mask |= BIT(r);
+			break;
+		}
+	}
+
+	return mask;
+}
+
 static void ieee80211_roc_notify_destroy(struct ieee80211_roc_work *roc)
 {
	/* was never transmitted */
@@ -566,7 +595,9 @@ static int ieee80211_start_roc_work(struct ieee80211_local *local,
				    enum ieee80211_roc_type type)
 {
	struct ieee80211_roc_work *roc, *tmp;
+	struct cfg80211_chan_def chandef = {};
	bool queued = false, combine_started = true;
+	u32 radio_mask;
	int ret;

	lockdep_assert_wiphy(local->hw.wiphy);
@@ -578,6 +609,12 @@ static int ieee80211_start_roc_work(struct ieee80211_local *local,
	if (!local->emulate_chanctx && !local->ops->remain_on_channel)
		return -EOPNOTSUPP;

+	cfg80211_chandef_create(&chandef, channel, NL80211_CHAN_NO_HT);
+	radio_mask = ieee80211_chandef_radio_mask(local, &chandef);
+	if (!ieee80211_can_leave_ch(sdata, radio_mask) &&
+	    !ieee80211_scanning_busy(local, &chandef))
+		return -EBUSY;
+
	roc = kzalloc(sizeof(*roc), GFP_KERNEL);
	if (!roc)
		return -ENOMEM;
@@ -613,8 +650,7 @@ static int ieee80211_start_roc_work(struct ieee80211_local *local,
	}

	/* if there's no need to queue, handle it immediately */
-	if (list_empty(&local->roc_list) &&
-	    !local->scanning && !ieee80211_is_radar_required(local)) {
+	if (list_empty(&local->roc_list) && !local->scanning) {
		/* if not HW assist, just queue & schedule work */
		if (!local->ops->remain_on_channel) {
			list_add_tail(&roc->list, &local->roc_list);
diff --git a/net/mac80211/scan.c b/net/mac80211/scan.c
index 3546fa5c4818..5a0f14618caa 100644
--- a/net/mac80211/scan.c
+++ b/net/mac80211/scan.c
@@ -605,36 +605,83 @@ static int ieee80211_start_sw_scan(struct ieee80211_local *local,
	return 0;
 }

-static bool __ieee80211_can_leave_ch(struct ieee80211_sub_if_data *sdata)
+u32 ieee80211_scan_req_radio_mask(struct ieee80211_local *local,
+				  struct cfg80211_scan_request *req)
+{
+	const struct wiphy_radio *radio;
+	u32 mask = 0;
+	int i, r;
+
+	for (r = 0; r < local->hw.wiphy->n_radio; r++) {
+		radio = &local->hw.wiphy->radio[r];
+
+		for (i = 0; i < req->n_channels; i++) {
+			struct cfg80211_chan_def chandef = {};
+
+			chandef.chan = req->channels[i];
+			cfg80211_chandef_create(&chandef, req->channels[i],
+						NL80211_CHAN_NO_HT);
+			if (!cfg80211_radio_chandef_valid(radio, &chandef))
+				continue;
+
+			mask |= BIT(r);
+			break;
+		}
+	}
+
+	return mask;
+}
+
+bool ieee80211_can_leave_ch(struct ieee80211_sub_if_data *sdata,
+			    u32 radio_mask)
 {
	struct ieee80211_local *local = sdata->local;
	struct ieee80211_sub_if_data *sdata_iter;
+	struct wiphy *wiphy = local->hw.wiphy;
+	struct ieee80211_chanctx_conf *conf;
+	struct ieee80211_link_data *link;
	unsigned int link_id;

	lockdep_assert_wiphy(local->hw.wiphy);

-	if (!ieee80211_is_radar_required(local))
+	if (!ieee80211_is_radar_required(local, radio_mask))
		return true;

	if (!regulatory_pre_cac_allowed(local->hw.wiphy))
		return false;

	list_for_each_entry(sdata_iter, &local->interfaces, list) {
-		for_each_valid_link(&sdata_iter->wdev, link_id)
-			if (sdata_iter->wdev.links[link_id].cac_started)
+		for_each_valid_link(&sdata_iter->wdev, link_id) {
+			if (!sdata_iter->wdev.links[link_id].cac_started)
+				continue;
+
+			if (!wiphy->n_radio)
+				return false;
+
+			link = sdata_dereference(sdata->link[link_id], sdata);
+			if (!link)
+				continue;
+
+			conf = wiphy_dereference(wiphy, link->conf->chanctx_conf);
+			if (!conf)
+				continue;
+
+			if (conf->radio_idx >= 0 &&
+			    (radio_mask & BIT(conf->radio_idx)))
				return false;
+		}
	}

	return true;
 }

 static bool ieee80211_can_scan(struct ieee80211_local *local,
-			       struct ieee80211_sub_if_data *sdata)
+			       struct ieee80211_sub_if_data *sdata,
+			       u32 radio_mask)
 {
-	if (!__ieee80211_can_leave_ch(sdata))
-		return false;
-
-	if (!list_empty(&local->roc_list))
+	if (!list_empty(&local->roc_list) &&
+	    (!local->hw.wiphy->n_radio ||
+	     (radio_mask & ieee80211_offchannel_radio_mask(local))))
		return false;

	if (sdata->vif.type == NL80211_IFTYPE_STATION &&
@@ -646,15 +693,22 @@ static bool ieee80211_can_scan(struct ieee80211_local *local,

 void ieee80211_run_deferred_scan(struct ieee80211_local *local)
 {
+	struct ieee80211_sub_if_data *sdata;
+	struct cfg80211_scan_request *req;
+	u32 radio_mask;
+
	lockdep_assert_wiphy(local->hw.wiphy);

-	if (!local->scan_req || local->scanning)
+	req = wiphy_dereference(local->hw.wiphy, local->scan_req);
+	if (!req || local->scanning)
+		return;
+
+	radio_mask = ieee80211_scan_req_radio_mask(local, req);
+	sdata = wiphy_dereference(local->hw.wiphy, local->scan_sdata);
+	if (!ieee80211_can_leave_ch(sdata, radio_mask))
		return;

-	if (!ieee80211_can_scan(local,
-				rcu_dereference_protected(
-					local->scan_sdata,
-					lockdep_is_held(&local->hw.wiphy->mtx))))
+	if (!ieee80211_can_scan(local, sdata, radio_mask))
		return;

	wiphy_delayed_work_queue(local->hw.wiphy, &local->scan_work,
@@ -750,6 +804,7 @@ static int __ieee80211_start_scan(struct ieee80211_sub_if_data *sdata,
 {
	struct ieee80211_local *local = sdata->local;
	bool hw_scan = local->ops->hw_scan;
+	u32 radio_mask;
	int rc;

	lockdep_assert_wiphy(local->hw.wiphy);
@@ -767,10 +822,11 @@ static int __ieee80211_start_scan(struct ieee80211_sub_if_data *sdata,
		return -EINVAL;
	}

-	if (!__ieee80211_can_leave_ch(sdata))
+	radio_mask = ieee80211_scan_req_radio_mask(local, req);
+	if (!ieee80211_can_leave_ch(sdata, radio_mask))
		return -EBUSY;

-	if (!ieee80211_can_scan(local, sdata)) {
+	if (!ieee80211_can_scan(local, sdata, radio_mask)) {
		/* wait for the work to finish/time out */
		rcu_assign_pointer(local->scan_req, req);
		rcu_assign_pointer(local->scan_sdata, sdata);
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index 0148729610ae..5592331fd805 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -971,6 +971,23 @@ struct wireless_dev *ieee80211_vif_to_wdev(struct ieee80211_vif *vif)
 }
 EXPORT_SYMBOL_GPL(ieee80211_vif_to_wdev);

+u32 ieee80211_chandef_radio_mask(struct ieee80211_local *local,
+				 struct cfg80211_chan_def *chandef)
+{
+	struct wiphy *wiphy = local->hw.wiphy;
+	const struct wiphy_radio *radio;
+	u32 mask = 0;
+	int i;
+
+	for (i = 0; i < wiphy->n_radio; i++) {
+		radio = &wiphy->radio[i];
+		if (cfg80211_radio_chandef_valid(radio, chandef))
+			mask |= BIT(i);
+	}
+
+	return mask;
+}
+
 /*
  * Nothing should have been stuffed into the workqueue during
  * the suspend->resume cycle. Since we can't check each caller
diff --git a/net/wireless/util.c b/net/wireless/util.c
index 0b74518e1e9b..14fbc2d642d3 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -3012,6 +3012,9 @@ bool cfg80211_radio_chandef_valid(const struct wiphy_radio *radio,
 {
	u32 freq, width;

+	if (!cfg80211_chandef_valid(chandef))
+		return false;
+
	freq = ieee80211_chandef_to_khz(chandef);
	width = cfg80211_chandef_get_width(chandef);
	if (!ieee80211_radio_freq_range_valid(radio, freq, width))
--
2.42.0
